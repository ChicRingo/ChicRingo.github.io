<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ChicRingo.github.io</id>
    <title>ChicRingo个人博客</title>
    <updated>2020-08-28T05:07:16.390Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ChicRingo.github.io"/>
    <link rel="self" href="https://ChicRingo.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ChicRingo.github.io/images/avatar.png</logo>
    <icon>https://ChicRingo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ChicRingo个人博客</rights>
    <entry>
        <title type="html"><![CDATA[用 golang 实现的十大经典排序]]></title>
        <id>https://ChicRingo.github.io/post/yong-golang-shi-xian-de-shi-da-jing-dian-pai-xu/</id>
        <link href="https://ChicRingo.github.io/post/yong-golang-shi-xian-de-shi-da-jing-dian-pai-xu/">
        </link>
        <updated>2020-08-28T05:06:03.000Z</updated>
        <summary type="html"><![CDATA[<p>用go语言实现的十大经典排序</p>
]]></summary>
        <content type="html"><![CDATA[<p>用go语言实现的十大经典排序</p>
<!-- more -->
<h3 id="冒泡排序">冒泡排序</h3>
<pre><code class="language-go">// 冒泡排序
func bubble(nums []int) []int {
   numLen := len(nums)

   for i := 0; i &lt; numLen; i++ {
      // 按相邻两个一起比较，所以最后一个不用遍历 -1,已经排序的也不用重新排序，所以-i，不写也可
      for j := 0; j &lt; numLen-1-i; j++ {
         // 当前值大于后一个值，则对换位置
         if nums[j] &gt; nums[j+1] {
            nums[j], nums[j+1] = nums[j+1], nums[j]
         }
      }
   }

   return nums
}
</code></pre>
<h3 id="选择排序">选择排序</h3>
<pre><code class="language-go">func selection(nums []int) []int {
   numLen := len(nums)
   //最后一个不用排序了
   for i := 0; i &lt; numLen-1; i++ {
      //每次最小值的位置index
      var minIndex = i
      // 从第二个开始排序，也就是i+1
      for j := i + 1; j &lt; numLen; j++ {
         if nums[j] &lt; nums[minIndex] {
            minIndex = j
         }
      }
      nums[i], nums[minIndex] = nums[minIndex], nums[i]
   }

   return nums
}
</code></pre>
<h3 id="插入排序">插入排序</h3>
<pre><code class="language-go">func insertion(nums []int) []int {
   // 网上写法
   for i, tmp := range nums {
      // 前一个索引值
      preIndex := i - 1
      // 定义一个临时变量取当前的值（挖出来腾地方，给前面的往后挪位置的空间
      //tmp := nums[i]
      // 如果当前值 tmp 小于前面的值，就把前面的值往后挪，因为tmp已经保存过相当于空的
      for preIndex &gt;= 0 &amp;&amp; tmp &lt; nums[preIndex] {
         nums[preIndex+1] = nums[preIndex]
         preIndex--
      }
      // 不满足以上条件时，说明没有比tmp更小的，就保存tmp当前值到新的位置
      nums[preIndex+1] = tmp
   }

   // 自己写法
   //numLen := len(nums)
   //for i := 1; i &lt; numLen; i++ { //从第2个开始，i=1开始
   //
   // temp := nums[i] // 定义一个临时变量取当前的值
   // // 把该值tmp与之前的数 从后往前进行比较
   // for j := i - 1; j &gt;= 0; j-- {
   //    // 当 当前值tmp 比之前的某个值大,那么插入,否则把每个值往后移一位
   //    if temp &gt; nums[j] {
   //       nums[j+1] = temp
   //       break
   //    } else {
   //       nums[j+1] = nums[j]
   //    }
   //    // 如果都移动了,然后遍历到0了,说明当前值是最小的,把当前值放到最小的位置
   //    if j == 0 {
   //       nums[0] = temp
   //    }
   // }
   //}
   return nums
}
</code></pre>
<h3 id="希尔排序">希尔排序</h3>
<h3 id="归并排序">归并排序</h3>
<h3 id="快速排序">快速排序</h3>
<pre><code class="language-go">func partition(nums []int, left, right int) int {
   // 设基准值 privot 为left
   privot := left
   index := privot + 1
   for i := index; i &lt;= right; i++ {
      if nums[i] &lt; nums[privot] {
         nums[i], nums[index] = nums[index], nums[i]
         index++
      }
   }
   nums[privot], nums[index-1] = nums[index-1], nums[privot]
   return index - 1
}

func quickSort(nums []int, left, right int) {
   // 如果数组长度小于等于1，说明这个数组分区不需要再排序了，直接return
   if len(nums) &lt;= 1 {
      return
   }
   // 如果左小于右，
   if left &lt; right {
      partIndex := partition(nums, left, right)
      quickSort(nums, left, partIndex-1)
      quickSort(nums, partIndex+1, right)
   }
   return
}
</code></pre>
<h3 id="堆排序">堆排序</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我擦~字符串转字节切片后，切片的容量竟然千奇百怪]]></title>
        <id>https://ChicRingo.github.io/post/wo-ca-~zi-fu-chuan-zhuan-zi-jie-qie-pian-hou-qie-pian-de-rong-liang-jing-ran-qian-qi-bai-guai/</id>
        <link href="https://ChicRingo.github.io/post/wo-ca-~zi-fu-chuan-zhuan-zi-jie-qie-pian-hou-qie-pian-de-rong-liang-jing-ran-qian-qi-bai-guai/">
        </link>
        <updated>2020-08-25T00:56:36.000Z</updated>
        <summary type="html"><![CDATA[<p>字符串转字节切片步骤如下</p>
<ol>
<li>
<p>判断是否是常量， 如果是常量则转换为等容量等长的字节切片</p>
</li>
<li>
<p>如果是变量， 先判断生成的切片是否发生变量逃逸</p>
</li>
<li>
<ul>
<li>如果逃逸或者字符串长度&gt;32， 则根据字符串长度可以计算出不同的容量</li>
<li>如果未逃逸且字符串长度&lt;=32, 则字符切片容量为32</li>
</ul>
</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<p>字符串转字节切片步骤如下</p>
<ol>
<li>
<p>判断是否是常量， 如果是常量则转换为等容量等长的字节切片</p>
</li>
<li>
<p>如果是变量， 先判断生成的切片是否发生变量逃逸</p>
</li>
<li>
<ul>
<li>如果逃逸或者字符串长度&gt;32， 则根据字符串长度可以计算出不同的容量</li>
<li>如果未逃逸且字符串长度&lt;=32, 则字符切片容量为32</li>
</ul>
</li>
</ol>
<!-- more -->
<p>以下文章来源于新世界杂货铺 ，作者许文</p>
<p><a href="https://baijiahao.baidu.com/s?id=1671902920320901161"><strong>新世界杂货铺</strong>作为一名Gopher， 我愿称之为Go的干(杂)货铺子！</a></p>
<p>神奇的现象</p>
<p>切片， 切片， 又是切片!</p>
<p>今天遇到的神奇问题和切片有关， 具体怎么个神奇法， 我们来看看下面几个现象</p>
<h3 id="现象一">现象一</h3>
<pre><code>a := &quot;abc&quot;
bs := []byte(a)
fmt.Println(bs, len(bs), cap(bs))
// 输出： [97 98 99] 3 8
</code></pre>
<h3 id="现象二">现象二</h3>
<pre><code>a := &quot;abc&quot;
bs := []byte(a)
fmt.Println(len(bs), cap(bs))
// 输出: 3 32
</code></pre>
<h3 id="现象三">现象三</h3>
<pre><code>bs := []byte(&quot;abc&quot;)
fmt.Println(len(bs), cap(bs))
// 输出: 3 3
</code></pre>
<h3 id="现象四">现象四</h3>
<pre><code>a := &quot;&quot;
bs := []byte(a)
fmt.Println(bs, len(bs), cap(bs))
// 输出: [] 0 0
</code></pre>
<h3 id="现象五">现象五</h3>
<pre><code>a := &quot;&quot;
bs := []byte(a)
fmt.Println(len(bs), cap(bs))
// 输出: 0 32
</code></pre>
<h2 id="分析">分析</h2>
<p>到这儿我已经满脑子问号了</p>
<figure data-type="image" tabindex="1"><img src="https://pics4.baidu.com/feed/b7003af33a87e95024fc161f982aa645faf2b4f7.jpeg?token=851a11b97e2f5c17586d5100942c414e" alt="img" loading="lazy"></figure>
<h3 id="字符串变量转切片">字符串变量转切片</h3>
<p>一个小小的字符串转切片， 内部究竟发生了什么， 竟然如此的神奇。这种时候只好祭出汇编大法， 看看汇编代码(<code>希望之后有机会能够对go的汇编语法进行简单的介绍</code>)有没有什么关键词能够帮助我们</p>
<p>以下为现象一转换的汇编代码关键部分</p>
<pre><code>&quot;&quot;.main STEXT size=495 args=0x0 locals=0xd8
	0x0000 00000 (test.go:5)	TEXT	&quot;&quot;.main(SB), ABIInternal, $216-0
	0x0000 00000 (test.go:5)	MOVQ	(TLS), CX
	0x0009 00009 (test.go:5)	LEAQ	-88(SP), AX
	0x000e 00014 (test.go:5)	CMPQ	AX, 16(CX)
	0x0012 00018 (test.go:5)	JLS	485
	0x0018 00024 (test.go:5)	SUBQ	$216, SP
	0x001f 00031 (test.go:5)	MOVQ	BP, 208(SP)
	0x0027 00039 (test.go:5)	LEAQ	208(SP), BP
	0x002f 00047 (test.go:5)	FUNCDATA	$0, gclocals·7be4bbacbfdb05fb3044e36c22b41e8b(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$1, gclocals·648d0b72bb9d7f59fbfdbee57a078eee(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$2, gclocals·2dfddcc7190380b1ae77e69d81f0a101(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$3, &quot;&quot;.main.stkobj(SB)
	0x002f 00047 (test.go:6)	PCDATA	$0, $1
	0x002f 00047 (test.go:6)	PCDATA	$1, $0
	0x002f 00047 (test.go:6)	LEAQ	go.string.&quot;abc&quot;(SB), AX
	0x0036 00054 (test.go:6)	MOVQ	AX, &quot;&quot;.a+96(SP)
	0x003b 00059 (test.go:6)	MOVQ	$3, &quot;&quot;.a+104(SP)
	0x0044 00068 (test.go:7)	MOVQ	$0, (SP)
	0x004c 00076 (test.go:7)	PCDATA	$0, $0
	0x004c 00076 (test.go:7)	MOVQ	AX, 8(SP)
	0x0051 00081 (test.go:7)	MOVQ	$3, 16(SP)
	0x005a 00090 (test.go:7)	CALL	runtime.stringtoslicebyte(SB)
	0x005f 00095 (test.go:7)	MOVQ	40(SP), AX
	0x0064 00100 (test.go:7)	MOVQ	32(SP), CX
	0x0069 00105 (test.go:7)	PCDATA	$0, $2
	0x0069 00105 (test.go:7)	MOVQ	24(SP), DX
	0x006e 00110 (test.go:7)	PCDATA	$0, $0
	0x006e 00110 (test.go:7)	PCDATA	$1, $1
	0x006e 00110 (test.go:7)	MOVQ	DX, &quot;&quot;.bs+112(SP)
	0x0073 00115 (test.go:7)	MOVQ	CX, &quot;&quot;.bs+120(SP)
	0x0078 00120 (test.go:7)	MOVQ	AX, &quot;&quot;.bs+128(SP)
</code></pre>
<p>以下为现象二转换的汇编代码关键部分</p>
<pre><code>&quot;&quot;.main STEXT size=393 args=0x0 locals=0xe0
	0x0000 00000 (test.go:5)	TEXT	&quot;&quot;.main(SB), ABIInternal, $224-0
	0x0000 00000 (test.go:5)	MOVQ	(TLS), CX
	0x0009 00009 (test.go:5)	LEAQ	-96(SP), AX
	0x000e 00014 (test.go:5)	CMPQ	AX, 16(CX)
	0x0012 00018 (test.go:5)	JLS	383
	0x0018 00024 (test.go:5)	SUBQ	$224, SP
	0x001f 00031 (test.go:5)	MOVQ	BP, 216(SP)
	0x0027 00039 (test.go:5)	LEAQ	216(SP), BP
	0x002f 00047 (test.go:5)	FUNCDATA	$0, gclocals·0ce64bbc7cfa5ef04d41c861de81a3d7(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$1, gclocals·00590b99cfcd6d71bbbc6e05cb4f8bf8(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$2, gclocals·8dcadbff7c52509cfe2d26e4d7d24689(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$3, &quot;&quot;.main.stkobj(SB)
	0x002f 00047 (test.go:6)	PCDATA	$0, $1
	0x002f 00047 (test.go:6)	PCDATA	$1, $0
	0x002f 00047 (test.go:6)	LEAQ	go.string.&quot;abc&quot;(SB), AX
	0x0036 00054 (test.go:6)	MOVQ	AX, &quot;&quot;.a+120(SP)
	0x003b 00059 (test.go:6)	MOVQ	$3, &quot;&quot;.a+128(SP)
	0x0047 00071 (test.go:7)	PCDATA	$0, $2
	0x0047 00071 (test.go:7)	LEAQ	&quot;&quot;..autotmp_5+64(SP), CX
	0x004c 00076 (test.go:7)	PCDATA	$0, $1
	0x004c 00076 (test.go:7)	MOVQ	CX, (SP)
	0x0050 00080 (test.go:7)	PCDATA	$0, $0
	0x0050 00080 (test.go:7)	MOVQ	AX, 8(SP)
	0x0055 00085 (test.go:7)	MOVQ	$3, 16(SP)
	0x005e 00094 (test.go:7)	CALL	runtime.stringtoslicebyte(SB)
	0x0063 00099 (test.go:7)	MOVQ	40(SP), AX
	0x0068 00104 (test.go:7)	MOVQ	32(SP), CX
	0x006d 00109 (test.go:7)	PCDATA	$0, $3
	0x006d 00109 (test.go:7)	MOVQ	24(SP), DX
	0x0072 00114 (test.go:7)	PCDATA	$0, $0
	0x0072 00114 (test.go:7)	PCDATA	$1, $1
	0x0072 00114 (test.go:7)	MOVQ	DX, &quot;&quot;.bs+136(SP)
	0x007a 00122 (test.go:7)	MOVQ	CX, &quot;&quot;.bs+144(SP)
	0x0082 00130 (test.go:7)	MOVQ	AX, &quot;&quot;.bs+152(SP)
</code></pre>
<p>在看汇编代码之前， 我们首先来看一看<code>runtime.stringtoslicebyte</code>的函数签名</p>
<pre><code>func stringtoslicebyte(buf *tmpBuf, s string) []byte
</code></pre>
<p>到这里只靠关键词已经无法看出更多的信息了,还是需要稍微了解一下汇编的语法,笔者在这里列出一点简单的分析， 之后我们还是可以通过取巧的方法发现更多的东西</p>
<pre><code>// 现象一给runtime.stringtoslicebyte的传参
0x002f 00047 (test.go:6)	LEAQ	go.string.&quot;abc&quot;(SB), AX // 将字符串&quot;abc&quot;放入寄存器AX
0x0036 00054 (test.go:6)	MOVQ	AX, &quot;&quot;.a+96(SP) // 将AX中的内容存入变量a中
0x003b 00059 (test.go:6)	MOVQ	$3, &quot;&quot;.a+104(SP) // 将字符串长度3存入变量a中
0x0044 00068 (test.go:7)	MOVQ	$0, (SP) // 将0 传递个runtime.stringtoslicebyte(SB)的第一个参数(笔者猜测对应go中的nil)
0x004c 00076 (test.go:7)	PCDATA	$0, $0 // 据说和gc有关， 具体还不清楚， 一般情况可以忽略
0x004c 00076 (test.go:7)	MOVQ	AX, 8(SP) // 将AX中的内容传递给runtime.stringtoslicebyte(SB)的第二个参数
0x0051 00081 (test.go:7)	MOVQ	$3, 16(SP) // 将字符串长度传递给runtime.stringtoslicebyte(SB)的第二个参数
0x005a 00090 (test.go:7)	CALL	runtime.stringtoslicebyte(SB) // 调用函数， 此行后面的几行代码是将返回值赋值给变量bs

// 现象二给runtime.stringtoslicebyte的传参
0x002f 00047 (test.go:6)	LEAQ	go.string.&quot;abc&quot;(SB), AX // 将字符串&quot;abc&quot;放入寄存器AX
0x0036 00054 (test.go:6)	MOVQ	AX, &quot;&quot;.a+120(SP) // 将AX中的内容存入变量a中
0x003b 00059 (test.go:6)	MOVQ	$3, &quot;&quot;.a+128(SP) // 将字符串长度3存入变量a中
0x0047 00071 (test.go:7)	PCDATA	$0, $2
0x0047 00071 (test.go:7)	LEAQ	&quot;&quot;..autotmp_5+64(SP), CX // 将内部变量autotmp_5放入寄存器CX
0x004c 00076 (test.go:7)	PCDATA	$0, $1
0x004c 00076 (test.go:7)	MOVQ	CX, (SP) // 将CX中的内容传递给runtime.stringtoslicebyte(SB)的第一个参数
0x0050 00080 (test.go:7)	PCDATA	$0, $0
0x0050 00080 (test.go:7)	MOVQ	AX, 8(SP) // 将AX中的内容传递给runtime.stringtoslicebyte(SB)的第二个参数
0x0055 00085 (test.go:7)	MOVQ	$3, 16(SP) // 将字符串长度传递给runtime.stringtoslicebyte(SB)的第二个参数
0x005e 00094 (test.go:7)	CALL	runtime.stringtoslicebyte(SB)
</code></pre>
<p>通过上面汇编代码的分析可以知道，现象一和现象二的区别就是传递给<code>runtime.stringtoslicebyte</code>的第一个参数不同。通过对runtime包中<code>stringtoslicebyte</code>函数分析，第一个参数是否有值和字符串长度会影响代码执行的分支，从而生成不同的切片， 因此容量不一样也是常理之中， 下面我们看源码</p>
<pre><code>func stringtoslicebyte(buf *tmpBuf, s string) []byte {
	var b []byte
	if buf != nil &amp;&amp; len(s) &lt;= len(buf) {
		*buf = tmpBuf{}
		b = buf[:len(s)]
	} else {
		b = rawbyteslice(len(s))
	}
	copy(b, s)
	return b
}
</code></pre>
<p>然而， stringtoslicebyte的第一个参数什么情况下才会有值，什么情况下为nil, 我们仍然不清楚。那怎么办呢， 只好祭出全局搜索大法：</p>
<pre><code># 在go源码根目录执行下面的命令
grep stringtoslicebyte -r . | grep -v &quot;//&quot;
</code></pre>
<p>最终在go的编译器源码cmd/compile/internal/gc/walk.go发现了如下代码块</p>
<figure data-type="image" tabindex="2"><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" loading="lazy"></figure>
<p>我们查看<code>mkcall</code> 函数签名可以知道, 从第四个参数开始的所有变量都会作为参数传递给第一个参数对应的函数， 最后生成一个<code>*Node</code>的变量。其中Node结构体解释如下:</p>
<pre><code>// A Node is a single node in the syntax tree.
// Actually the syntax tree is a syntax DAG, because there is only one
// node with Op=ONAME for a given instance of a variable x.
// The same is true for Op=OTYPE and Op=OLITERAL. See Node.mayBeShared.
</code></pre>
<p>综合上述信息我们得出的结论是，编译器会对stringtoslicebyte的函数调用生成一个AST(抽象语法树)对应的节点。因此我们也知道传递给stringtoslicebyte函数的第一个变量也就对应于上图中的变量a.</p>
<p>其中a的初始值为<code>nodnil()</code>的返回值，即默认为<code>nil</code>. 但是<code>n.Esc == EscNone</code>时，a会变成一个数组。我们看一下EscNone的解释.</p>
<pre><code>// 此代码位于cmd/compile/internal/gc/esc.go中
const (
	// ...
	EscNone           // Does not escape to heap, result, or parameters.
    ...
)
</code></pre>
<p>由上可知, <code>EscNone</code>用来判断变量是否逃逸,到这儿了我们就很好办了，接下来我们对现象一和现象二的代码进行逃逸分析.</p>
<pre><code># 执行变量逃逸分析命令: go run -gcflags '-m -l' test.go
# 现象一逃逸分析如下：
./test.go:7:14: ([]byte)(a) escapes to heap
./test.go:8:13: main ... argument does not escape
./test.go:8:13: bs escapes to heap
./test.go:8:21: len(bs) escapes to heap
./test.go:8:30: cap(bs) escapes to heap
[97 98 99] 3 8
# 现象二逃逸分析如下：
./test.go:7:14: main ([]byte)(a) does not escape
./test.go:8:13: main ... argument does not escape
./test.go:8:17: len(bs) escapes to heap
./test.go:8:26: cap(bs) escapes to heap
3 32
</code></pre>
<p>根据上面的信息我们知道在现象一中，bs变量发生了逃逸，现象二中变量未发生逃逸，也就是说stringtoslicebyte函数的第一个参数在变量未发生逃逸时其值不为nil,变量发生逃逸时其值为nil。到这里我们已经搞明白stringtoslicebyte的第一个参数了， 那我们继续分析stringtoslicebyte的内部逻辑</p>
<p>我们在runtime/string.go中看到stringtoslicebyte第一个参数的类型定义如下：</p>
<pre><code>const tmpStringBufSize = 32

type tmpBuf [tmpStringBufSize]byte
</code></pre>
<p>综上: 现象二中bs变量未发生变量逃逸, stringtoslicebyte第一个参数不为空且是一个长度为32的byte数组, 因此在现象二中生成了一个容量为32的切片</p>
<p>根据对stringtoslicebyte的源码分析， 我们知道现象一调用了<code>rawbyteslice</code>函数</p>
<pre><code>func rawbyteslice(size int) (b []byte) {
	cap := roundupsize(uintptr(size))
	p := mallocgc(cap, nil, false)
	if cap != uintptr(size) {
		memclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size))
	}

	*(*slice)(unsafe.Pointer(&amp;b)) = slice{p, size, int(cap)}
	return
}
</code></pre>
<p>由上面的代码知道， 切片的容量通过runtime/msize.go中的<code>roundupsize</code>函数计算得出, 其中_MaxSmallSize和class_to_size均定义在runtime/sizeclasses.go</p>
<pre><code>func roundupsize(size uintptr) uintptr {
	if size &lt; _MaxSmallSize {
		if size &lt;= smallSizeMax-8 {
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
		} else {
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
		}
	}
	if size+_PageSize &lt; size {
		return size
	}
	return round(size, _PageSize)
}
</code></pre>
<p>由于字符串abc的长度小于_MaxSmallSize(32768)，故切片的长度只能取数组class_to_size中的值， 即<code>0, 8, 16, 32, 48, 64, 80, 96, 112, 128....</code>s</p>
<p>至此, 现象一中切片容量为什么为8也真相大白了。相信到这里很多人已经明白现象四和现象五是怎么回事儿了, 其逻辑分别与现象一和现象二是一致的， 有兴趣的， 可以在自己的电脑上面试一试。</p>
<h3 id="字符串直接转切片">字符串直接转切片</h3>
<p>那你说了这么多， 现象三还是不能解释啊。请各位看官莫急， 接下来我们继续分析。</p>
<p>相信各位细心的小伙伴应该早就发现了我们在上面的<code>cmd/compile/internal/gc/walk.go</code>源码图中折叠了部分代码， 现在我们就将这块神秘的代码赤裸裸的展示出来</p>
<p>我们分析这块代码发现,go编译器在将<code>字符串转字节切片</code>生成AST时，总共分为三步。</p>
<ol>
<li>先判断该变量是否是常量字符串,如果是常量字符串,则直接通过<code>types.NewArray</code>创建一个和字符串等长的数组</li>
<li>常量字符串生成的切片变量也要进行逃逸分析，并判断其大小是否大于函数栈允许分配给变量的最大长度， 从而判断节点是分配在栈上还是在堆上</li>
<li>最后，如果字符串长度是大于0， 将字符串内容复制到字节切片中， 然后返回。因此现象三中的切片容量是3也就完全清楚了</li>
</ol>
<h2 id="结论">结论</h2>
<p>字符串转字节切片步骤如下</p>
<ol>
<li>
<p>判断是否是常量， 如果是常量则转换为等容量等长的字节切片</p>
</li>
<li>
<p>如果是变量， 先判断生成的切片是否发生变量逃逸</p>
</li>
<li>
<ul>
<li>如果逃逸或者字符串长度&gt;32， 则根据字符串长度可以计算出不同的容量</li>
<li>如果未逃逸且字符串长度&lt;=32, 则字符切片容量为32</li>
</ul>
</li>
</ol>
<h2 id="扩展">扩展</h2>
<p>常见逃逸情况</p>
<ol>
<li>函数返回局部指针</li>
<li>栈空间不足逃逸</li>
<li>动态类型逃逸, 很多函数参数为interface类型，比如fmt.Println(a ...interface{})，编译期间很难确定其参数的具体类型, 也会发生逃逸</li>
<li>闭包引用对象逃逸</li>
</ol>
<blockquote>
<p>注: 写本文时， 笔者所用go版本为: go1.13.4</p>
</blockquote>
<blockquote>
<p>生命不息， 探索不止， 后续将持续更新有关于go的技术探索</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Hugo 搭建博客]]></title>
        <id>https://ChicRingo.github.io/post/shi-yong-hugo-da-jian-bo-ke/</id>
        <link href="https://ChicRingo.github.io/post/shi-yong-hugo-da-jian-bo-ke/">
        </link>
        <updated>2020-08-21T15:40:21.000Z</updated>
        <content type="html"><![CDATA[<p>https://www.diguage.com/post/building-blog-with-hugo/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用2个goroutine轮流打印一个数组]]></title>
        <id>https://ChicRingo.github.io/post/shi-yong-2-ge-goroutine-lun-liu-da-yin-yi-ge-shu-zu/</id>
        <link href="https://ChicRingo.github.io/post/shi-yong-2-ge-goroutine-lun-liu-da-yin-yi-ge-shu-zu/">
        </link>
        <updated>2020-08-21T11:11:56.000Z</updated>
        <summary type="html"><![CDATA[<p>今天遇到群友的一到面试题，感觉在各种地方看到很多次这种类似的题目，比如两个goroutine轮流打印奇偶数，所以记录整理下来。</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天遇到群友的一到面试题，感觉在各种地方看到很多次这种类似的题目，比如两个goroutine轮流打印奇偶数，所以记录整理下来。</p>
<!-- more -->
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

// 使用2个goroutine轮流打印一个数组
var wg sync.WaitGroup
var ch = make(chan bool)
var send = make(chan int)

func main() {
    wg.Add(3)
    nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
    l := len(nums)
    go Send(nums, l)      // 发送
    go printOdd(l)  // 打印奇数
    go printEven(l) // 打印偶数
    wg.Wait()
}

// 发送数组元素
func Send(nums []int, l int) {
    defer wg.Done()
    for i := 0; i &lt; l; i++ {
        a := nums[i]
        send &lt;- a
    }
}

// 打印奇数
func printEven(l int) {
    defer wg.Done()
    for i := 0; i &lt; l; i++ {
        ch &lt;- true
        if i&amp;1 == 0 {
            a := &lt;-send
            fmt.Println(&quot;printEven:&quot;, a)
        }
    }
}

// 打印偶数
func printOdd(l int) {
    defer wg.Done()
    for i := 0; i &lt; l; i++ {
        &lt;-ch
        if i&amp;1 == 1 {
            a := &lt;-send
            fmt.Println(&quot;printOdd: &quot;, a)
        }
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang 并发控制的两种模式]]></title>
        <id>https://ChicRingo.github.io/post/golang-bing-fa-kong-zhi-de-liang-chong-mo-shi/</id>
        <link href="https://ChicRingo.github.io/post/golang-bing-fa-kong-zhi-de-liang-chong-mo-shi/">
        </link>
        <updated>2020-08-20T14:38:27.000Z</updated>
        <summary type="html"><![CDATA[<p>Golang 两种常用的并发控制，使用 channel 和 WaitGroup 两种模式</p>
]]></summary>
        <content type="html"><![CDATA[<p>Golang 两种常用的并发控制，使用 channel 和 WaitGroup 两种模式</p>
<!-- more -->
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

func main() {
	fmt.Println(&quot;Hello, 世界&quot;)
	handle1()
	handle2()
}

func handle1() {
	// 通过无缓冲通道来实现多 goroutine 并发控制

	// create channel to synchronize
	done := make(chan bool) // 无缓冲通道
	defer close(done)

	go func() {
		time.Sleep(1 * time.Second)
		fmt.Println(&quot;one done&quot;)
		done &lt;- true
	}()

	go func() {
		time.Sleep(1 * time.Second)
		fmt.Println(&quot;two done&quot;)
		done &lt;- true
	}()

	// wait until both are done
	for c := 0; c &lt; 2; c++ {
		&lt;-done
	}
	fmt.Println(&quot;handle1 done&quot;)
	// 当主 goroutine 运行到 &lt;-done 接受 channel 的值的时候，如果该  channel 中没有数据，就会一直阻塞等待，直到有值。
}

func handle2() {
	// 通过sync包中的WaitGroup 实现并发控制

	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		time.Sleep(1 * time.Second)
		fmt.Println(&quot;1 done&quot;)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		time.Sleep(1 * time.Second)
		fmt.Println(&quot;2 done&quot;)
		wg.Done()
	}()
	wg.Wait()
	fmt.Println(&quot;handle2 done&quot;)

	// 在 sync 包中，提供了 WaitGroup ，它会等待它收集的所有 goroutine 任务全部完成，在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回。
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang并发模型：并发协程的优雅退出]]></title>
        <id>https://ChicRingo.github.io/post/golang-bing-fa-mo-xing-bing-fa-xie-cheng-de-you-ya-tui-chu/</id>
        <link href="https://ChicRingo.github.io/post/golang-bing-fa-mo-xing-bing-fa-xie-cheng-de-you-ya-tui-chu/">
        </link>
        <updated>2020-08-20T11:35:30.000Z</updated>
        <summary type="html"><![CDATA[<p>文章来源：<a href="https://lessisbetter.site/2018/12/02/golang-exit-goroutine-in-3-ways/">Golang并发模型：并发协程的优雅退出</a><br>
goroutine作为Golang并发的核心，我们不仅要关注它们的创建和管理，当然还要关注如何合理的退出这些协程，不（合理）退出不然可能会造成阻塞、panic、程序行为异常、数据结果不正确等问题。这篇文章介绍，如何合理的退出goroutine，减少软件bug。</p>
]]></summary>
        <content type="html"><![CDATA[<p>文章来源：<a href="https://lessisbetter.site/2018/12/02/golang-exit-goroutine-in-3-ways/">Golang并发模型：并发协程的优雅退出</a><br>
goroutine作为Golang并发的核心，我们不仅要关注它们的创建和管理，当然还要关注如何合理的退出这些协程，不（合理）退出不然可能会造成阻塞、panic、程序行为异常、数据结果不正确等问题。这篇文章介绍，如何合理的退出goroutine，减少软件bug。</p>
<!-- more -->
<p>goroutine在退出方面，不像线程和进程，不能通过某种手段<strong>强制</strong>关闭它们，只能等待goroutine主动退出。但也无需为退出、关闭goroutine而烦恼，下面就介绍3种优雅退出goroutine的方法，只要采用这种最佳实践去设计，基本上就可以确保goroutine退出上不会有问题，尽情享用。</p>
<h3 id="1使用for-range退出">1：使用for-range退出</h3>
<p><code>for-range</code>是使用频率很高的结构，常用它来遍历数据，<strong><code>range</code>能够感知channel的关闭，当channel被发送数据的协程关闭时，range就会结束</strong>，接着退出for循环。</p>
<p>它在并发中的使用场景是：当协程只从1个channel读取数据，然后进行处理，处理后协程退出。下面这个示例程序，当in通道被关闭时，协程可自动退出。</p>
<pre><code>go func(in &lt;-chan int) {
    // Using for-range to exit goroutine
    // range has the ability to detect the close/end of a channel
    for x := range in {
        fmt.Printf(&quot;Process %d\n&quot;, x)
    }
}(inCh)
</code></pre>
<h3 id="2使用ok退出">2：使用,ok退出</h3>
<p><code>for-select</code>也是使用频率很高的结构，select提供了多路复用的能力，所以for-select可以让函数具有持续多路处理多个channel的能力。<strong>但select没有感知channel的关闭，这引出了2个问题</strong>：</p>
<ol>
<li>继续在关闭的通道上读，会读到通道传输数据类型的零值，如果是指针类型，读到nil，继续处理还会产生nil。</li>
<li>继续在关闭的通道上写，将会panic。</li>
</ol>
<p>问题2可以这样解决，通道只由发送方关闭，接收方不可关闭，即某个写通道只由使用该select的协程关闭，select中就不存在继续在关闭的通道上写数据的问题。</p>
<p>问题1可以使用<code>,ok</code>来检测通道的关闭，使用情况有2种。</p>
<p>第一种：<strong>如果某个通道关闭后，需要退出协程，直接return即可</strong>。示例代码中，该协程需要从in通道读数据，还需要定时打印已经处理的数量，有2件事要做，所有不能使用for-range，需要使用for-select，当in关闭时，<code>ok=false</code>，我们直接返回。</p>
<pre><code>go func() {
	// in for-select using ok to exit goroutine
	for {
		select {
		case x, ok := &lt;-in:
			if !ok {
				return
			}
			fmt.Printf(&quot;Process %d\n&quot;, x)
			processedCnt++
		case &lt;-t.C:
			fmt.Printf(&quot;Working, processedCnt = %d\n&quot;, processedCnt)
		}
	}
}()
</code></pre>
<p>第二种：如果<strong>某个通道关闭了，不再处理该通道，而是继续处理其他case</strong>，退出是等待所有的可读通道关闭。我们需要<strong>使用select的一个特征：select不会在nil的通道上进行等待</strong>。这种情况，把只读通道设置为nil即可解决。</p>
<pre><code>go func() {
	// in for-select using ok to exit goroutine
	for {
		select {
		case x, ok := &lt;-in1:
			if !ok {
				in1 = nil
			}
			// Process
		case y, ok := &lt;-in2:
			if !ok {
				in2 = nil
			}
			// Process
		case &lt;-t.C:
			fmt.Printf(&quot;Working, processedCnt = %d\n&quot;, processedCnt)
		}

		// If both in channel are closed, goroutine exit
		if in1 == nil &amp;&amp; in2 == nil {
			return
		}
	}
}()
</code></pre>
<h3 id="3使用退出通道退出">3：使用退出通道退出</h3>
<p><strong>使用<code>,ok</code>来退出使用for-select协程，解决是当读入数据的通道关闭时，没数据读时程序的正常结束</strong>。想想下面这2种场景，<code>,ok</code>还能适用吗？</p>
<ol>
<li>接收的协程要退出了，如果它直接退出，不告知发送协程，发送协程将阻塞。</li>
<li>启动了一个工作协程处理数据，如何通知它退出？</li>
</ol>
<p><strong>使用一个专门的通道，发送退出的信号，可以解决这类问题</strong>。以第2个场景为例，协程入参包含一个停止通道<code>stopCh</code>，当<code>stopCh</code>被关闭，<code>case &lt;-stopCh</code>会执行，直接返回即可。</p>
<p>当我启动了100个worker时，只要<code>main()</code>执行关闭stopCh，每一个worker都会都到信号，进而关闭。如果<code>main()</code>向stopCh发送100个数据，这种就低效了。</p>
<pre><code>func worker(stopCh &lt;-chan struct{}) {
	go func() {
		defer fmt.Println(&quot;worker exit&quot;)
		// Using stop channel explicit exit
		for {
			select {
			case &lt;-stopCh:
				fmt.Println(&quot;Recv stop signal&quot;)
				return
			case &lt;-t.C:
				fmt.Println(&quot;Working .&quot;)
			}
		}
	}()
	return
}
</code></pre>
<h3 id="最佳实践回顾">最佳实践回顾</h3>
<ol>
<li>发送协程主动关闭通道，接收协程不关闭通道。技巧：把接收方的通道入参声明为只读，如果接收协程关闭只读协程，编译时就会报错。</li>
<li>协程处理1个通道，并且是读时，协程优先使用<code>for-range</code>，因为<code>range</code>可以关闭通道的关闭自动退出协程。</li>
<li><code>,ok</code>可以处理多个读通道关闭，需要关闭当前使用<code>for-select</code>的协程。</li>
<li>显式关闭通道<code>stopCh</code>可以处理主动通知协程退出的场景。</li>
</ol>
<h3 id="完整示例代码">完整示例代码</h3>
<p>本文所有代码都在仓库，可查看完整示例代码：https://github.com/Shitaibin/golang_goroutine_exit</p>
<h3 id="并发系列文章推荐">并发系列文章推荐</h3>
<ul>
<li><a href="http://lessisbetter.site/2018/11/16/golang-introduction-to-pipeline/">Golang并发模型：轻松入门流水线模型</a></li>
<li><a href="http://lessisbetter.site/2018/11/28/golang-pipeline-fan-model/">Golang并发模型：轻松入门流水线FAN模式</a></li>
<li><a href="http://lessisbetter.site/2018/12/02/golang-exit-goroutine-in-3-ways/">Golang并发模型：并发协程的优雅退出</a></li>
</ul>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：http://lessisbetter.site/2018/12/02/golang-exit-goroutine-in-3-ways/</li>
</ol>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用Golang写爬虫(一)]]></title>
        <id>https://ChicRingo.github.io/post/yong-golang-xie-pa-chong-yi/</id>
        <link href="https://ChicRingo.github.io/post/yong-golang-xie-pa-chong-yi/">
        </link>
        <updated>2020-08-20T08:06:25.000Z</updated>
        <summary type="html"><![CDATA[<p>使用 Golang 对豆瓣爬虫</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用 Golang 对豆瓣爬虫</p>
<!-- more -->
<p>原文地址: <a href="https://link.zhihu.com/?target=https%3A//strconv.com/posts/web-crawler-exercise-1/">https://strconv.com/posts/web-crawler-exercise-1/</a></p>
<p>之前一直都是再用Python写爬虫，最近想体验下Golang写爬虫的感觉，所以就有了这个系列。我想要抓取的页面是<a href="https://link.zhihu.com/?target=https%3A//movie.douban.com/top250">豆瓣Top250页面</a>，选择它的理由有3个:</p>
<ol>
<li>豆瓣页面代码相对规范</li>
<li>豆瓣对爬虫爱好者相对更宽容</li>
<li>Top250页面简洁，很适合拿来练手</li>
</ol>
<p>我们先看第一版的代码。</p>
<p>按逻辑我把抓取代码分成2个部分：</p>
<ol>
<li>HTTP请求</li>
<li>解析页面中的内容</li>
</ol>
<p>我们先看HTTP请求，Golang语言的HTTP请求库不需要使用第三方的库，标准库就内置了足够好的支持：</p>
<pre><code class="language-go">import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;io/ioutil&quot;
)

func fetch (url string) string {
    fmt.Println(&quot;Fetch Url&quot;, url)
    client := &amp;http.Client{}
    req, _ := http.NewRequest(&quot;GET&quot;, url, nil)
    req.Header.Set(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)&quot;)
    resp, err := client.Do(req)
    if err != nil {
        fmt.Println(&quot;Http get err:&quot;, err)
        return &quot;&quot;
    }
    if resp.StatusCode != 200 {
        fmt.Println(&quot;Http status code:&quot;, resp.StatusCode)
        return &quot;&quot;
    }
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println(&quot;Read error&quot;, err)
        return &quot;&quot;
    }
    return string(body)
}
</code></pre>
<p>我把URL请求的逻辑都放在了fetch函数中，里面做了一些异常处理。值得说的有2点：</p>
<ol>
<li>在Header中设置了User-Agent，让访问看起来更像搜索引擎Bot。如果一个网站希望自己的内容被Google收录那么他就不会拒绝这样的UA的访问。</li>
<li>需要通过ioutil.ReadAll 读取resp的body内容，最后用string(body)把它转化成字符串</li>
</ol>
<p>接着就是解析页面的部分：</p>
<pre><code class="language-go">import (
    &quot;regexp&quot;
    &quot;strings&quot;
)

func parseUrls(url string) {
    body := fetch(url)
    body = strings.Replace(body, &quot;\n&quot;, &quot;&quot;, -1)
    rp := regexp.MustCompile(`&lt;div class=&quot;hd&quot;&gt;(.*?)&lt;/div&gt;`)
    titleRe := regexp.MustCompile(`&lt;span class=&quot;title&quot;&gt;(.*?)&lt;/span&gt;`)
    idRe := regexp.MustCompile(`&lt;a href=&quot;https://movie.douban.com/subject/(\d+)/&quot;`)
    items := rp.FindAllStringSubmatch(body, -1)
    for _, item := range items {
        fmt.Println(idRe.FindStringSubmatch(item[1])[1],
            titleRe.FindStringSubmatch(item[1])[1])
    }
}
</code></pre>
<p>这篇文章我们主要体验用标准库完成页面的解析，也就是用正则表达式包regexp来完成。不过要注意需要用<code>strings.Replace(body, &quot;\n&quot;, &quot;&quot;, -1)</code>这步把body内容中的回车符去掉，要不然下面的正则表达式<code>.*</code>就不符合了。<code>FindAllStringSubmatch</code>方法会把符合正则表达式的结果都解析出来（一个列表），而<code>FindStringSubmatch</code>是找第一个符合的结果。</p>
<p>Top250页面是要翻页的，最后在main函数里面实现抓取全部Top250页面。另外为了和之后的改进做对比，我们加上代码运行耗时的逻辑：</p>
<pre><code class="language-go">import (
       &quot;time&quot;
       &quot;strconv&quot;
)
func main() {
        start := time.Now()
        for i := 0; i &lt; 10; i++ {
                parseUrls(&quot;https://movie.douban.com/top250?start=&quot; + strconv.Itoa(25 * i))
        }
        elapsed := time.Since(start)
        fmt.Printf(&quot;Took %s&quot;, elapsed)
}
</code></pre>
<p>在Golang中把数字转成字符串需要使用<code>strconv.Itoa</code>（嘿嘿，本博客域名就是这个模块），这样就可以根据start的参数的不通拼出正确的页面路径。用一个for循环完成翻页。</p>
<p>运行起来非常快：</p>
<pre><code class="language-bash">❯ go run crawler/doubanCrawler1.go
... # 省略输出
Took 1.454627547s
</code></pre>
<p>通过终端输出可以看到我们拿到了对应电影条目的ID和电影标题！</p>
<h3 id="代码地址">代码地址</h3>
<p>完整代码可以在<a href="https://link.zhihu.com/?target=https%3A//github.com/golang-dev/strconv.code/blob/master/crawler/doubanCrawler1.go">这个地址</a>找到。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 Go 中恰到好处的内存对齐]]></title>
        <id>https://ChicRingo.github.io/post/zai-go-zhong-qia-dao-hao-chu-de-nei-cun-dui-qi/</id>
        <link href="https://ChicRingo.github.io/post/zai-go-zhong-qia-dao-hao-chu-de-nei-cun-dui-qi/">
        </link>
        <updated>2020-08-20T02:41:41.000Z</updated>
        <summary type="html"><![CDATA[<p>在Golang中对结构体成员进行内存对齐，以此保证内存的访问边界，并可以优化内存占用</p>
]]></summary>
        <content type="html"><![CDATA[<p>在Golang中对结构体成员进行内存对齐，以此保证内存的访问边界，并可以优化内存占用</p>
<!-- more -->
<p>原文地址：<a href="https://eddycjy.com/posts/go/talk/2018-12-26-go-memory-align/">在 Go 中恰到好处的内存对齐</a></p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2020/02/27/3wuT0A.png" alt="image" loading="lazy"></figure>
<h2 id="问题">问题</h2>
<pre><code class="language-go">type Part1 struct {
	a bool
	b int32
	c int8
	d int64
	e byte
}
</code></pre>
<p>在开始之前，希望你计算一下 <code>Part1</code> 共占用的大小是多少呢？</p>
<pre><code class="language-go">func main() {
	fmt.Printf(&quot;bool size: %d\n&quot;, unsafe.Sizeof(bool(true)))
	fmt.Printf(&quot;int32 size: %d\n&quot;, unsafe.Sizeof(int32(0)))
	fmt.Printf(&quot;int8 size: %d\n&quot;, unsafe.Sizeof(int8(0)))
	fmt.Printf(&quot;int64 size: %d\n&quot;, unsafe.Sizeof(int64(0)))
	fmt.Printf(&quot;byte size: %d\n&quot;, unsafe.Sizeof(byte(0)))
	fmt.Printf(&quot;string size: %d\n&quot;, unsafe.Sizeof(&quot;EDDYCJY&quot;))
}
</code></pre>
<p>输出结果：</p>
<pre><code>bool size: 1
int32 size: 4
int8 size: 1
int64 size: 8
byte size: 1
string size: 16
</code></pre>
<p>这么一算，<code>Part1</code> 这一个结构体的占用内存大小为 1+4+1+8+1 = 15 个字节。相信有的小伙伴是这么算的，看上去也没什么毛病</p>
<p>真实情况是怎么样的呢？我们实际调用看看，如下：</p>
<pre><code class="language-go">type Part1 struct {
	a bool
	b int32
	c int8
	d int64
	e byte
}

func main() {
	part1 := Part1{}

	fmt.Printf(&quot;part1 size: %d, align: %d\n&quot;, unsafe.Sizeof(part1), unsafe.Alignof(part1))
}
</code></pre>
<p>输出结果：</p>
<pre><code>part1 size: 32, align: 8
</code></pre>
<p>最终输出为占用 32 个字节。这与前面所预期的结果完全不一样。这充分地说明了先前的计算方式是错误的。为什么呢？</p>
<p>在这里要提到 “内存对齐” 这一概念，才能够用正确的姿势去计算，接下来我们详细的讲讲它是什么</p>
<h2 id="内存对齐">内存对齐</h2>
<p>有的小伙伴可能会认为内存读取，就是一个简单的字节数组摆放</p>
<figure data-type="image" tabindex="2"><img src="https://s2.ax1x.com/2020/02/27/3wuLff.png" alt="image" loading="lazy"></figure>
<p>上图表示一个坑一个萝卜的内存读取方式。但实际上 CPU 并不会以一个一个字节去读取和写入内存。相反 CPU 读取内存是<strong>一块一块读取</strong>的，块的大小可以为 2、4、6、8、16 字节等大小。块大小我们称其为<strong>内存访问粒度</strong>。如下图：</p>
<figure data-type="image" tabindex="3"><img src="https://s2.ax1x.com/2020/02/27/3wKSmj.png" alt="image" loading="lazy"></figure>
<p>在样例中，假设访问粒度为 4。 CPU 是以每 4 个字节大小的访问粒度去读取和写入内存的。这才是正确的姿势</p>
<h3 id="为什么要关心对齐">为什么要关心对齐</h3>
<ul>
<li>你正在编写的代码在性能（CPU、Memory）方面有一定的要求</li>
<li>你正在处理向量方面的指令</li>
<li>某些硬件平台（ARM）体系不支持未对齐的内存访问</li>
</ul>
<p>另外作为一个工程师，你也很有必要学习这块知识点哦 😃</p>
<h3 id="为什么要做对齐">为什么要做对齐</h3>
<ul>
<li>平台（移植性）原因：不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况</li>
<li>性能原因：若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://s2.ax1x.com/2020/02/27/3wKApT.png" alt="image" loading="lazy"></figure>
<p>在上图中，假设从 Index 1 开始读取，将会出现很崩溃的问题。因为它的内存访问边界是不对齐的。因此 CPU 会做一些额外的处理工作。如下：</p>
<ol>
<li>CPU <strong>首次</strong>读取未对齐地址的第一个内存块，读取 0-3 字节。并移除不需要的字节 0</li>
<li>CPU <strong>再次</strong>读取未对齐地址的第二个内存块，读取 4-7 字节。并移除不需要的字节 5、6、7 字节</li>
<li>合并 1-4 字节的数据</li>
<li>合并后放入寄存器</li>
</ol>
<p>从上述流程可得出，不做 “内存对齐” 是一件有点 “麻烦” 的事。因为它会增加许多耗费时间的动作</p>
<p>而假设做了内存对齐，从 Index 0 开始读取 4 个字节，只需要读取一次，也不需要额外的运算。这显然高效很多，是标准的<strong>空间换时间</strong>做法</p>
<h3 id="默认系数">默认系数</h3>
<p>在不同平台上的编译器都有自己默认的 “对齐系数”，可通过预编译命令 <code>#pragma pack(n)</code> 进行变更，n 就是代指 “对齐系数”。一般来讲，我们常用的平台的系数如下：</p>
<ul>
<li>32 位：4</li>
<li>64 位：8</li>
</ul>
<p>另外要注意，不同硬件平台占用的大小和对齐值都可能是不一样的。因此本文的值不是唯一的，调试的时候需按本机的实际情况考虑</p>
<h3 id="成员对齐">成员对齐</h3>
<pre><code class="language-go">func main() {
	fmt.Printf(&quot;bool align: %d\n&quot;, unsafe.Alignof(bool(true)))
	fmt.Printf(&quot;int32 align: %d\n&quot;, unsafe.Alignof(int32(0)))
	fmt.Printf(&quot;int8 align: %d\n&quot;, unsafe.Alignof(int8(0)))
	fmt.Printf(&quot;int64 align: %d\n&quot;, unsafe.Alignof(int64(0)))
	fmt.Printf(&quot;byte align: %d\n&quot;, unsafe.Alignof(byte(0)))
	fmt.Printf(&quot;string align: %d\n&quot;, unsafe.Alignof(&quot;EDDYCJY&quot;))
	fmt.Printf(&quot;map align: %d\n&quot;, unsafe.Alignof(map[string]string{}))
}
</code></pre>
<p>输出结果：</p>
<pre><code>bool align: 1
int32 align: 4
int8 align: 1
int64 align: 8
byte align: 1
string align: 8
map align: 8
</code></pre>
<p>在 Go 中可以调用 <code>unsafe.Alignof</code> 来返回相应类型的对齐系数。通过观察输出结果，可得知基本都是 <code>2^n</code>，最大也不会超过 8。这是因为我手提（64 位）编译器默认对齐系数是 8，因此最大值不会超过这个数</p>
<h3 id="整体对齐">整体对齐</h3>
<p>在上小节中，提到了结构体中的成员变量要做字节对齐。那么想当然身为最终结果的结构体，也是需要做字节对齐的</p>
<h3 id="对齐规则">对齐规则</h3>
<ul>
<li>结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>当前成员变量类型的长度</strong>（<code>unsafe.Sizeof</code>），取<strong>最小值作为当前类型的对齐值</strong>。其偏移量必须为对齐值的整数倍</li>
<li>结构体本身，对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>结构体的所有成员变量类型中的最大长度</strong>，取<strong>最大数的最小整数倍</strong>作为对齐值</li>
<li>结合以上两点，可得知若<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的</li>
</ul>
<h2 id="分析流程">分析流程</h2>
<p>接下来我们一起分析一下，“它” 到底经历了些什么，影响了 “预期” 结果</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>类型</th>
<th>偏移量</th>
<th>自身占用</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>bool</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>b</td>
<td>int32</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>c</td>
<td>int8</td>
<td>8</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>9</td>
<td>7</td>
</tr>
<tr>
<td>d</td>
<td>int64</td>
<td>16</td>
<td>8</td>
</tr>
<tr>
<td>e</td>
<td>byte</td>
<td>24</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>25</td>
<td>7</td>
</tr>
<tr>
<td>总占用大小</td>
<td>-</td>
<td>-</td>
<td>32</td>
</tr>
</tbody>
</table>
<h3 id="成员对齐-2">成员对齐</h3>
<ul>
<li>第一个成员 a
<ul>
<li>类型为 bool</li>
<li>大小/对齐值为 1 字节</li>
<li>初始地址，偏移量为 0。占用了第 1 位</li>
</ul>
</li>
<li>第二个成员 b
<ul>
<li>类型为 int32</li>
<li>大小/对齐值为 4 字节</li>
<li>根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此 2-4 位为 Padding。而当前数值从第 5 位开始填充，到第 8 位。如下：axxx|bbbb</li>
</ul>
</li>
<li>第三个成员 c
<ul>
<li>类型为 int8</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 8。不需要额外对齐，填充 1 个字节到第 9 位。如下：axxx|bbbb|c…</li>
</ul>
</li>
<li>第四个成员 d
<ul>
<li>类型为 int64</li>
<li>大小/对齐值为 8 字节</li>
<li>根据规则 1，其偏移量必须为 8 的整数倍。确定偏移量为 16，因此 9-16 位为 Padding。而当前数值从第 17 位开始写入，到第 24 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd</li>
</ul>
</li>
<li>第五个成员 e
<ul>
<li>类型为 byte</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 24。不需要额外对齐，填充 1 个字节到第 25 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd|e…</li>
</ul>
</li>
</ul>
<h3 id="整体对齐-2">整体对齐</h3>
<p>在每个成员变量进行对齐后，根据规则 2，整个结构体本身也要进行字节对齐，因为可发现它可能并不是 <code>2^n</code>，不是偶数倍。显然不符合对齐的规则</p>
<p>根据规则 2，可得出对齐值为 8。现在的偏移量为 25，不是 8 的整倍数。因此确定偏移量为 32。对结构体进行对齐</p>
<h3 id="结果">结果</h3>
<p>Part1 内存布局：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</p>
<h3 id="小结">小结</h3>
<p>通过本节的分析，可得知先前的 “推算” 为什么错误？</p>
<p>是因为实际内存管理并非 “一个萝卜一个坑” 的思想。而是一块一块。通过空间换时间（效率）的思想来完成这块读取、写入。另外也需要兼顾不同平台的内存操作情况</p>
<h2 id="巧妙的结构体">巧妙的结构体</h2>
<p>在上一小节，可得知根据成员变量的类型不同，其结构体的内存会产生对齐等动作。那假设字段顺序不同，会不会有什么变化呢？我们一起来试试吧 😃</p>
<pre><code class="language-go">type Part1 struct {
	a bool
	b int32
	c int8
	d int64
	e byte
}

type Part2 struct {
	e byte
	c int8
	a bool
	b int32
	d int64
}

func main() {
	part1 := Part1{}
	part2 := Part2{}

	fmt.Printf(&quot;part1 size: %d, align: %d\n&quot;, unsafe.Sizeof(part1), unsafe.Alignof(part1))
	fmt.Printf(&quot;part2 size: %d, align: %d\n&quot;, unsafe.Sizeof(part2), unsafe.Alignof(part2))
}
</code></pre>
<p>输出结果：</p>
<pre><code>part1 size: 32, align: 8
part2 size: 16, align: 8
</code></pre>
<p>通过结果可以惊喜的发现，只是 “简单” 对成员变量的字段顺序进行改变，就改变了结构体占用大小</p>
<p>接下来我们一起剖析一下 <code>Part2</code>，看看它的内部到底和上一位之间有什么区别，才导致了这样的结果？</p>
<h3 id="分析流程-2">分析流程</h3>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>类型</th>
<th>偏移量</th>
<th>自身占用</th>
</tr>
</thead>
<tbody>
<tr>
<td>e</td>
<td>byte</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>c</td>
<td>int8</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>a</td>
<td>bool</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>b</td>
<td>int32</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>d</td>
<td>int64</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>总占用大小</td>
<td>-</td>
<td>-</td>
<td>16</td>
</tr>
</tbody>
</table>
<h4 id="成员对齐-3">成员对齐</h4>
<ul>
<li>第一个成员 e
<ul>
<li>类型为 byte</li>
<li>大小/对齐值为 1 字节</li>
<li>初始地址，偏移量为 0。占用了第 1 位</li>
</ul>
</li>
<li>第二个成员 c
<ul>
<li>类型为 int8</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 2。不需要额外对齐</li>
</ul>
</li>
<li>第三个成员 a
<ul>
<li>类型为 bool</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 3。不需要额外对齐</li>
</ul>
</li>
<li>第四个成员 b
<ul>
<li>类型为 int32</li>
<li>大小/对齐值为 4 字节</li>
<li>根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此第 3 位为 Padding。而当前数值从第 4 位开始填充，到第 8 位。如下：ecax|bbbb</li>
</ul>
</li>
<li>第五个成员 d
<ul>
<li>类型为 int64</li>
<li>大小/对齐值为 8 字节</li>
<li>根据规则 1，其偏移量必须为 8 的整数倍。当前偏移量为 8。不需要额外对齐，从 9-16 位填充 8 个字节。如下：ecax|bbbb|dddd|dddd</li>
</ul>
</li>
</ul>
<h4 id="整体对齐-3">整体对齐</h4>
<p>符合规则 2，不需要额外对齐</p>
<h4 id="结果-2">结果</h4>
<p>Part2 内存布局：ecax|bbbb|dddd|dddd</p>
<h2 id="总结">总结</h2>
<p>通过对比 <code>Part1</code> 和 <code>Part2</code> 的内存布局，你会发现两者有很大的不同。如下：</p>
<ul>
<li>Part1：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</li>
<li>Part2：ecax|bbbb|dddd|dddd</li>
</ul>
<p>仔细一看，<code>Part1</code> 存在许多 Padding。显然它占据了不少空间，那么 Padding 是怎么出现的呢？</p>
<p>通过本文的介绍，可得知是由于不同类型导致需要进行字节对齐，以此保证内存的访问边界</p>
<p>那么也不难理解，为什么<strong>调整结构体内成员变量的字段顺序</strong>就能达到缩小结构体占用大小的疑问了，是因为巧妙地减少了 Padding 的存在。让它们更 “紧凑” 了。这一点对于加深 Go 的内存布局印象和大对象的优化非常有帮</p>
<p>当然了，没什么特殊问题，你可以不关注这一块。但你要知道这块知识点 😄</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Data structure alignment</a></li>
<li><a href="https://www.ibm.com/developerworks/library/pa-dalign/">Data alignment</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang 中零值的坑]]></title>
        <id>https://ChicRingo.github.io/post/golang-zhong-ling-zhi-de-keng/</id>
        <link href="https://ChicRingo.github.io/post/golang-zhong-ling-zhi-de-keng/">
        </link>
        <updated>2020-08-19T11:13:43.000Z</updated>
        <summary type="html"><![CDATA[<p>对于int, string, bool来说，声明这三种基本类型的变量，Go会默认分配一个零值，零值分别为 0 , '' ,false，所以在GORM中通过tag定义字段的默认值后，这些有默认值的字段在使用这些零值作为参数时，GORM不会把这些字段的值插入数据库中，这个坑一定要切记。</p>
]]></summary>
        <content type="html"><![CDATA[<p>对于int, string, bool来说，声明这三种基本类型的变量，Go会默认分配一个零值，零值分别为 0 , '' ,false，所以在GORM中通过tag定义字段的默认值后，这些有默认值的字段在使用这些零值作为参数时，GORM不会把这些字段的值插入数据库中，这个坑一定要切记。</p>
<!-- more -->
<h2 id="默认值">默认值</h2>
<p>可以通过 tag 定义字段的默认值，比如：</p>
<pre><code class="language-go">type User struct {
  ID   int64
  Name string `gorm:&quot;default:'小王子'&quot;`
  Age  int64
}
</code></pre>
<p><strong>注意：</strong> 通过tag定义字段的默认值，在创建记录时候生成的 SQL 语句会排除没有值或值为 零值 的字段。 在将记录插入到数据库后，Gorm会从数据库加载那些字段的默认值。</p>
<p>举个例子：</p>
<pre><code class="language-go">var user = User{Name: &quot;&quot;, Age: 99}
db.Create(&amp;user)
</code></pre>
<p>上面代码实际执行的SQL语句是<code>INSERT INTO users(&quot;age&quot;) values('99');</code>，排除了零值字段<code>Name</code>，而在数据库中这一条数据会使用设置的默认值<code>小王子</code>作为Name字段的值。</p>
<p>**注意：**所有字段的零值, 比如<code>0</code>, <code>&quot;&quot;</code>,<code>false</code>或者其它<code>零值</code>，都不会保存到数据库内，但会使用他们的默认值。 如果你想避免这种情况，可以考虑使用指针或实现 <code>Scanner/Valuer</code>接口，比如：</p>
<h3 id="使用指针方式实现零值存入数据库">使用指针方式实现零值存入数据库</h3>
<pre><code class="language-go">// 使用指针
type User struct {
  ID   int64
  Name *string `gorm:&quot;default:'小王子'&quot;`
  Age  int64
}
user := User{Name: new(string), Age: 18))}
db.Create(&amp;user)  // 此时数据库中该条记录name字段的值就是''
</code></pre>
<h3 id="使用scannervaluer接口方式实现零值存入数据库">使用Scanner/Valuer接口方式实现零值存入数据库</h3>
<pre><code class="language-go">// 使用 Scanner/Valuer
type User struct {
	ID int64
	Name sql.NullString `gorm:&quot;default:'小王子'&quot;` // sql.NullString 实现了Scanner/Valuer接口
	Age  int64
}
user := User{Name: sql.NullString{&quot;&quot;, true}, Age:18}
db.Create(&amp;user)  // 此时数据库中该条记录name字段的值就是''
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang 中 range 的坑]]></title>
        <id>https://ChicRingo.github.io/post/golang-zhong-range-de-keng/</id>
        <link href="https://ChicRingo.github.io/post/golang-zhong-range-de-keng/">
        </link>
        <updated>2020-08-19T04:25:55.000Z</updated>
        <summary type="html"><![CDATA[<p>避免踩坑指北，Golang 中容易在 for range 中踩到的坑</p>
]]></summary>
        <content type="html"><![CDATA[<p>避免踩坑指北，Golang 中容易在 for range 中踩到的坑</p>
<!-- more -->
<h2 id="使用-range-迭代遍历数组">使用 range 迭代遍历数组</h2>
<p>range 会复制对象，而不是不是直接在原对象上操作。</p>
<p>示例一：</p>
<pre><code class="language-go">func main() {
    a := [3]int{1, 2, 3}
    for _, v := range a { // 复制一份a遍历[1, 2, 3]
        v += 100 // v是复制对象中的值，不会改变a数组元素的值
    }
    fmt.Println(a) // 1 2 3
}
</code></pre>
<p>示例二：</p>
<pre><code class="language-go">func main() {
    a := [3]int{1, 2, 3}
    for i, v := range a { // i,v从a复制的对象里提取出
        if i == 0 {
            a[1], a[2] = 200, 300
            fmt.Println(a) // 输出[1 200 300]
        }
        a[i] = v + 100 // v是复制对象里的元素[1, 2, 3]
    }
    fmt.Println(a) // 输出[101, 102, 103]
}
</code></pre>
<p>结果：</p>
<pre><code class="language-powershell">[1 200 300]
[101 102 103]
</code></pre>
<h2 id="使用-range-迭代遍历切片">使用 range 迭代遍历切片</h2>
<p>range迭代遍历引用类型时，底层的数据不会被复制：</p>
<pre><code class="language-go">func main() {
    a := []int{1, 2, 3} // 改成slice
    for i, v := range a {
        if i == 0 {
            a[1], a[2] = 200, 300
            fmt.Println(a) // [1 200 300]
        }
        a[i] = v + 100
    }
    fmt.Println(a) // 输出[101 300 400]
}

</code></pre>
<p>结果：</p>
<pre><code class="language-powershell">[1 200 300]
[101 300 400]
</code></pre>
<p>因为切片的内部结构为struct slice{*point, len, cap}。</p>
<p>数据部分是一个指针，指向地址，复制对象的时候只是把指针的值复制了，而不是重新拷贝一块新的内存再把值放进去，所以修改的时候还是修改的原来的值。</p>
]]></content>
    </entry>
</feed>