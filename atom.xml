<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ChicRingo.github.io</id>
    <title>ChicRingo个人博客</title>
    <updated>2020-08-28T15:24:11.978Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ChicRingo.github.io"/>
    <link rel="self" href="https://ChicRingo.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ChicRingo.github.io/images/avatar.png</logo>
    <icon>https://ChicRingo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ChicRingo个人博客</rights>
    <entry>
        <title type="html"><![CDATA[使用Go实现GoF的23种设计模式（二）]]></title>
        <id>https://ChicRingo.github.io/post/shi-yong-go-shi-xian-gof-de-23-chong-she-ji-mo-shi-er/</id>
        <link href="https://ChicRingo.github.io/post/shi-yong-go-shi-xian-gof-de-23-chong-she-ji-mo-shi-er/">
        </link>
        <updated>2020-08-28T15:15:08.000Z</updated>
        <summary type="html"><![CDATA[<p>作者：元闰子<br>
链接：https://juejin.im/post/6864011017384132621<br>
来源：掘金<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></summary>
        <content type="html"><![CDATA[<p>作者：元闰子<br>
链接：https://juejin.im/post/6864011017384132621<br>
来源：掘金<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>上一篇文章<a href="https://juejin.im/post/6859015515344633863">《使用Go实现GoF的23种设计模式（一）》</a>介绍了23种设计模式中的<strong>创建型模式</strong>（Creational Pattern），创建型模式是处理对象创建的一类设计模式，主要思想是<strong>向对象的使用者隐藏对象创建的具体细节</strong>，从而达到解耦的目的。本文主要聚焦在<strong>结构型模式</strong>（Structural Pattern）上，其主要思想是<strong>将多个对象组装成较大的结构，并同时保持结构的灵活和高效</strong>，从程序的结构上解决模块之间的耦合问题。</p>
<h2 id="组合模式composite-pattern">组合模式（Composite Pattern）</h2>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghvdqutjd5j312k0iue81.jpg" alt="组合模式结构" loading="lazy"></figure>
<h3 id="简述">简述</h3>
<p>在面向对象编程中，有两个常见的对象设计方法，<strong>组合</strong>和<strong>继承</strong>，两者都可以解决代码复用的问题，但是使用后者时容易出现继承层次过深，对象关系过于复杂的副作用，从而导致代码的可维护性变差。因此，一个经典的面向对象设计原则是：<strong>组合优于继承</strong>。</p>
<p>我们都知道，组合所表示的语义为“has-a”，也就是部分和整体的关系，最经典的组合模式描述如下：</p>
<blockquote>
<p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<p>Go语言天然就支持了组合模式，而且从它不支持继承关系的特点来看，Go也奉行了<strong>组合优于继承</strong>的原则，鼓励大家在进行程序设计时多采用组合的方法。Go实现组合模式的方式有两种，分别是<strong>直接组合</strong>（Direct Composition）和<strong>嵌入组合</strong>（Embedding Composition），下面我们一起探讨这两种不同的实现方法。</p>
<h3 id="go实现">Go实现</h3>
<p><em>直接组合（Direct Composition）的实现方式类似于Java/C++，就是将一个对象作为另一个对象的成员属性。</em></p>
<p>一个典型的实现如<a href="https://juejin.im/post/6859015515344633863">《使用Go实现GoF的23种设计模式（一）》</a>中所举的例子，一个<code>Message</code>结构体，由<code>Header</code>和<code>Body</code>所组成。那么<code>Message</code>就是一个整体，而<code>Header</code>和<code>Body</code>则为消息的组成部分。</p>
<pre><code class="language-go">type Message struct {
    Header *Header
    Body   *Body
}
复制代码
</code></pre>
<p>现在，我们来看一个稍微复杂一点的例子，同样考虑上一篇文章中所描述的插件架构风格的消息处理系统。前面我们用<strong>抽象工厂模式</strong>解决了插件加载的问题，通常，每个插件都会有一个生命周期，常见的就是启动状态和停止状态，现在我们使用<strong>组合模式</strong>来解决插件的启动和停止问题。</p>
<p>首先给<code>Plugin</code>接口添加几个生命周期相关的方法：</p>
<pre><code class="language-go">package plugin
...
// 插件运行状态
type Status uint8

const (
    Stopped Status = iota
    Started
)

type Plugin interface {
  // 启动插件
    Start()
  // 停止插件
    Stop()
  // 返回插件当前的运行状态
    Status() Status
}
// Input、Filter、Output三类插件接口的定义跟上一篇文章类似
// 这里使用Message结构体替代了原来的string，使得语义更清晰
type Input interface {
    Plugin
    Receive() *msg.Message
}

type Filter interface {
    Plugin
    Process(msg *msg.Message) *msg.Message
}

type Output interface {
    Plugin
    Send(msg *msg.Message)
}

复制代码
</code></pre>
<p>对于插件化的消息处理系统而言，一切皆是插件，因此我们将<code>Pipeine</code>也设计成一个插件，实现<code>Plugin</code>接口：</p>
<pre><code class="language-go">package pipeline
...
// 一个Pipeline由input、filter、output三个Plugin组成
type Pipeline struct {
    status plugin.Status
    input  plugin.Input
    filter plugin.Filter
    output plugin.Output
}

func (p *Pipeline) Exec() {
    msg := p.input.Receive()
    msg = p.filter.Process(msg)
    p.output.Send(msg)
}
// 启动的顺序 output -&gt; filter -&gt; input
func (p *Pipeline) Start() {
    p.output.Start()
    p.filter.Start()
    p.input.Start()
    p.status = plugin.Started
    fmt.Println(&quot;Hello input plugin started.&quot;)
}
// 停止的顺序 input -&gt; filter -&gt; output
func (p *Pipeline) Stop() {
    p.input.Stop()
    p.filter.Stop()
    p.output.Stop()
    p.status = plugin.Stopped
    fmt.Println(&quot;Hello input plugin stopped.&quot;)
}

func (p *Pipeline) Status() plugin.Status {
    return p.status
}

复制代码
</code></pre>
<p>一个<code>Pipeline</code>由<code>Input</code>、<code>Filter</code>、<code>Output</code>三类插件组成，形成了“部分-整体”的关系，而且它们都实现了<code>Plugin</code>接口，这就是一个典型的组合模式的实现。Client无需显式地启动和停止<code>Input</code>、<code>Filter</code>和<code>Output</code>插件，在调用<code>Pipeline</code>对象的<code>Start</code>和<code>Stop</code>方法时，<code>Pipeline</code>就已经帮你按顺序完成对应插件的启动和停止。</p>
<p>相比于上一篇文章，在本文中实现<code>Input</code>、<code>Filter</code>、<code>Output</code>三类插件时，需要多实现3个生命周期的方法。还是以上一篇文章中的<code>HelloInput</code>、<code>UpperFilter</code>和<code>ConsoleOutput</code>作为例子，具体实现如下：</p>
<pre><code class="language-go">package plugin
...
type HelloInput struct {
    status Status
}

func (h *HelloInput) Receive() *msg.Message {
  // 如果插件未启动，则返回nil
    if h.status != Started {
        fmt.Println(&quot;Hello input plugin is not running, input nothing.&quot;)
        return nil
    }
    return msg.Builder().
        WithHeaderItem(&quot;content&quot;, &quot;text&quot;).
        WithBodyItem(&quot;Hello World&quot;).
        Build()
}

func (h *HelloInput) Start() {
    h.status = Started
    fmt.Println(&quot;Hello input plugin started.&quot;)
}

func (h *HelloInput) Stop() {
    h.status = Stopped
    fmt.Println(&quot;Hello input plugin stopped.&quot;)
}

func (h *HelloInput) Status() Status {
    return h.status
}
复制代码
package plugin
...
type UpperFilter struct {
    status Status
}

func (u *UpperFilter) Process(msg *msg.Message) *msg.Message {
    if u.status != Started {
        fmt.Println(&quot;Upper filter plugin is not running, filter nothing.&quot;)
        return msg
    }
    for i, val := range msg.Body.Items {
        msg.Body.Items[i] = strings.ToUpper(val)
    }
    return msg
}

func (u *UpperFilter) Start() {
    u.status = Started
    fmt.Println(&quot;Upper filter plugin started.&quot;)
}

func (u *UpperFilter) Stop() {
    u.status = Stopped
    fmt.Println(&quot;Upper filter plugin stopped.&quot;)
}

func (u *UpperFilter) Status() Status {
    return u.status
}

复制代码
package plugin
...
type ConsoleOutput struct {
    status Status
}

func (c *ConsoleOutput) Send(msg *msg.Message) {
    if c.status != Started {
        fmt.Println(&quot;Console output is not running, output nothing.&quot;)
        return
    }
    fmt.Printf(&quot;Output:\n\tHeader:%+v, Body:%+v\n&quot;, msg.Header.Items, msg.Body.Items)
}

func (c *ConsoleOutput) Start() {
    c.status = Started
    fmt.Println(&quot;Console output plugin started.&quot;)
}

func (c *ConsoleOutput) Stop() {
    c.status = Stopped
    fmt.Println(&quot;Console output plugin stopped.&quot;)
}

func (c *ConsoleOutput) Status() Status {
    return c.status
}

复制代码
</code></pre>
<p>测试代码如下：</p>
<pre><code class="language-go">package test
...
func TestPipeline(t *testing.T) {
    p := pipeline.Of(pipeline.DefaultConfig())
    p.Start()
    p.Exec()
    p.Stop()
}
// 运行结果
=== RUN   TestPipeline
Console output plugin started.
Upper filter plugin started.
Hello input plugin started.
Pipeline started.
Output:
    Header:map[content:text], Body:[HELLO WORLD]
Hello input plugin stopped.
Upper filter plugin stopped.
Console output plugin stopped.
Hello input plugin stopped.
--- PASS: TestPipeline (0.00s)
PASS
复制代码
</code></pre>
<p><em>组合模式的另一种实现，嵌入组合（Embedding Composition），其实就是利用了Go语言的匿名成员特性，本质上跟直接组合是一致的。</em></p>
<p>还是以Message结构体为例，如果采用嵌入组合，则看起来像是这样：</p>
<pre><code class="language-go">type Message struct {
    Header
    Body
}
// 使用时，Message可以引用Header和Body的成员属性，例如：
msg := &amp;Message{}
msg.SrcAddr = &quot;192.168.0.1&quot;
复制代码
</code></pre>
<h2 id="适配器模式adapter-pattern">适配器模式（Adapter Pattern）</h2>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghzyia5t19j315w0k0kjl.jpg" alt="适配器模式结构" loading="lazy"></figure>
<h3 id="简述-2">简述</h3>
<p>适配器模式是最常用的结构型模式之一，它让原本因为接口不匹配而无法一起工作的两个对象能够一起工作。在现实生活中，适配器模式也是处处可见，比如电源插头转换器，可以让英式的插头工作在中式的插座上。适配器模式所做的就是<strong>将一个接口<code>Adaptee</code>，通过适配器<code>Adapter</code>转换成Client所期望的另一个接口<code>Target</code>来使用</strong>，实现原理也很简单，就是<code>Adapter</code>通过实现<code>Target</code>接口，并在对应的方法中调用<code>Adaptee</code>的接口实现。</p>
<p>一个典型的应用场景是，<em>系统中一个老的接口已经过时即将废弃，但因为历史包袱没法立即将老接口全部替换为新接口，这时可以新增一个适配器，将老的接口适配成新的接口来使用</em>。适配器模式很好的践行了面向对象设计原则里的<strong>开闭原则</strong>（open/closed principle），新增一个接口时也无需修改老接口，只需多加一个适配层即可。</p>
<h3 id="go实现-2">Go实现</h3>
<p>继续考虑上一节的消息处理系统例子，目前为止，系统的输入都源自于<code>HelloInput</code>，现在假设需要给系统新增从Kafka消息队列中接收数据的功能，其中Kafka消费者的接口如下：</p>
<pre><code class="language-go">package kafka
...
type Records struct {
    Items []string
}

type Consumer interface {
    Poll() Records
}
复制代码
</code></pre>
<p>由于当前<code>Pipeline</code>的设计是通过<code>plugin.Input</code>接口来进行数据接收，因此<code>kafka.Consumer</code>并不能直接集成到系统中。</p>
<p><em>怎么办？使用适配器模式！</em></p>
<p>为了能让<code>Pipeline</code>能够使用<code>kafka.Consumer</code>接口，我们需要定义一个适配器如下：</p>
<pre><code class="language-go">package plugin
...
type KafkaInput struct {
    status Status
    consumer kafka.Consumer
}

func (k *KafkaInput) Receive() *msg.Message {
    records := k.consumer.Poll()
    if k.status != Started {
        fmt.Println(&quot;Kafka input plugin is not running, input nothing.&quot;)
        return nil
    }
    return msg.Builder().
        WithHeaderItem(&quot;content&quot;, &quot;kafka&quot;).
        WithBodyItems(records.Items).
        Build()
}

// 在输入插件映射关系中加入kafka，用于通过反射创建input对象
func init() {
    inputNames[&quot;hello&quot;] = reflect.TypeOf(HelloInput{})
    inputNames[&quot;kafka&quot;] = reflect.TypeOf(KafkaInput{})
}
...
复制代码
</code></pre>
<p>因为Go语言并没有构造函数，如果按照上一篇文章中的<strong>抽象工厂模式</strong>来创建<code>KafkaInput</code>，那么得到的实例中的<code>consumer</code>成员因为没有被初始化而会是<code>nil</code>。因此，需要给<code>Plugin</code>接口新增一个<code>Init</code>方法，用于定义插件的一些初始化操作，并在工厂返回实例前调用。</p>
<pre><code class="language-go">package plugin
...
type Plugin interface {
    Start()
    Stop()
    Status() Status
    // 新增初始化方法，在插件工厂返回实例前调用
    Init()
}

// 修改后的插件工厂实现如下
func (i *InputFactory) Create(conf Config) Plugin {
    t, _ := inputNames[conf.Name]
    p := reflect.New(t).Interface().(Plugin)
  // 返回插件实例前调用Init函数，完成相关初始化方法
    p.Init()
    return p
}

// KakkaInput的Init函数实现
func (k *KafkaInput) Init() {
    k.consumer = &amp;kafka.MockConsumer{}
}
复制代码
</code></pre>
<p>上述代码中的<code>kafka.MockConsumer</code>为我们模式Kafka消费者的一个实现，代码如下：</p>
<pre><code class="language-go">package kafka
...
type MockConsumer struct {}

func (m *MockConsumer) Poll() *Records {
    records := &amp;Records{}
    records.Items = append(records.Items, &quot;i am mock consumer.&quot;)
    return records
}
复制代码
</code></pre>
<p>测试代码如下：</p>
<pre><code class="language-go">package test
...
func TestKafkaInputPipeline(t *testing.T) {
    config := pipeline.Config{
        Name: &quot;pipeline2&quot;,
        Input: plugin.Config{
            PluginType: plugin.InputType,
            Name:       &quot;kafka&quot;,
        },
        Filter: plugin.Config{
            PluginType: plugin.FilterType,
            Name:       &quot;upper&quot;,
        },
        Output: plugin.Config{
            PluginType: plugin.OutputType,
            Name:       &quot;console&quot;,
        },
    }
    p := pipeline.Of(config)
    p.Start()
    p.Exec()
    p.Stop()
}
// 运行结果
=== RUN   TestKafkaInputPipeline
Console output plugin started.
Upper filter plugin started.
Kafka input plugin started.
Pipeline started.
Output:
    Header:map[content:kafka], Body:[I AM MOCK CONSUMER.]
Kafka input plugin stopped.
Upper filter plugin stopped.
Console output plugin stopped.
Pipeline stopped.
--- PASS: TestKafkaInputPipeline (0.00s)
PASS
复制代码
</code></pre>
<h2 id="桥接模式bridge-pattern">桥接模式（Bridge Pattern）</h2>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi00awfcxcj31f20l01ky.jpg" alt="桥接模式结构" loading="lazy"></figure>
<h3 id="简述-3">简述</h3>
<p>桥接模式主要用于<strong>将抽象部分和实现部分进行解耦，使得它们能够各自往独立的方向变化</strong>。它解决了在模块有多种变化方向的情况下，用继承所导致的类爆炸问题。举一个例子，一个产品有形状和颜色两个特征（变化方向），其中形状分为方形和圆形，颜色分为红色和蓝色。如果采用继承的设计方案，那么就需要新增4个产品子类：方形红色、圆形红色、方形蓝色、圆形红色。如果形状总共有m种变化，颜色有n种变化，那么就需要新增m*n个产品子类！现在我们使用桥接模式进行优化，将形状和颜色分别设计为一个抽象接口独立出来，这样需要新增2个形状子类：方形和圆形，以及2个颜色子类：红色和蓝色。同样，如果形状总共有m种变化，颜色有n种变化，总共只需要新增m+n个子类！</p>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi01kwmua8j31hs0s47wj.jpg" alt="桥接模式示例" loading="lazy"></figure>
<p>上述例子中，我们通过将形状和颜色抽象为一个接口，使产品不再依赖于具体的形状和颜色细节，从而达到了解耦的目的。<strong>桥接模式本质上就是面向接口编程，可以给系统带来很好的灵活性和可扩展性</strong>。如果一个对象存在多个变化的方向，而且每个变化方向都需要扩展，那么使用桥接模式进行设计那是再合适不过了。</p>
<h3 id="go实现-3">Go实现</h3>
<p>回到消息处理系统的例子，一个<code>Pipeline</code>对象主要由<code>Input</code>、<code>Filter</code>、<code>Output</code>三类插件组成（<strong>3个特征</strong>），因为是插件化的系统，不可避免的就要求支持多种<code>Input</code>、<code>Filter</code>、<code>Output</code>的实现，并能够灵活组合（<strong>有多个变化的方向</strong>）。显然，<code>Pipeline</code>就非常适合使用桥接模式进行设计，实际上我们也这么做了。我们将<code>Input</code>、<code>Filter</code>、<code>Output</code>分别设计成一个抽象的接口，它们按照各自的方向去扩展。<code>Pipeline</code>只依赖的这3个抽象接口，并不感知具体实现的细节。</p>
<figure data-type="image" tabindex="5"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi0i6xpj9sj318a0nk4qq.jpg" alt="使用桥接模式设计的Pipeline" loading="lazy"></figure>
<pre><code class="language-go">package plugin
...
type Input interface {
    Plugin
    Receive() *msg.Message
}

type Filter interface {
    Plugin
    Process(msg *msg.Message) *msg.Message
}

type Output interface {
    Plugin
    Send(msg *msg.Message)
}
复制代码
package pipeline
...
// 一个Pipeline由input、filter、output三个Plugin组成
type Pipeline struct {
    status plugin.Status
    input  plugin.Input
    filter plugin.Filter
    output plugin.Output
}
// 通过抽象接口来使用，看不到底层的实现细节
func (p *Pipeline) Exec() {
    msg := p.input.Receive()
    msg = p.filter.Process(msg)
    p.output.Send(msg)
}
复制代码
</code></pre>
<p>测试代码如下：</p>
<pre><code class="language-go">package test
...
func TestPipeline(t *testing.T) {
    p := pipeline.Of(pipeline.DefaultConfig())
    p.Start()
    p.Exec()
    p.Stop()
}
// 运行结果
=== RUN   TestPipeline
Console output plugin started.
Upper filter plugin started.
Hello input plugin started.
Pipeline started.
Output:
    Header:map[content:text], Body:[HELLO WORLD]
Hello input plugin stopped.
Upper filter plugin stopped.
Console output plugin stopped.
Pipeline stopped.
--- PASS: TestPipeline (0.00s)
PASS
复制代码
</code></pre>
<h2 id="总结">总结</h2>
<p>本文主要介绍了结构型模式中的组合模式、适配器模式和桥接模式。<strong>组合模式</strong>主要解决代码复用的问题，相比于继承关系，组合模式可以避免继承层次过深导致的代码复杂问题，因此面向对象设计领域流传着<strong>组合优于继承</strong>的原则，而Go语言的设计也很好实践了该原则；<strong>适配器模式</strong>可以看作是两个不兼容接口之间的桥梁，可以将一个接口转换成Client所希望的另外一个接口，解决了模块之间因为接口不兼容而无法一起工作的问题；<strong>桥接模式</strong>将模块的抽象部分和实现部分进行分离，让它们能够往各自的方向扩展，从而达到解耦的目的。</p>
<p>下一篇文章，我们将继续聚焦于结构型模式，介绍完剩余的4种结模式：装饰模式、外观模式、享元模式和代理模式。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Go实现GoF的23种设计模式（一）]]></title>
        <id>https://ChicRingo.github.io/post/shi-yong-go-shi-xian-gof-de-23-chong-she-ji-mo-shi-yi/</id>
        <link href="https://ChicRingo.github.io/post/shi-yong-go-shi-xian-gof-de-23-chong-she-ji-mo-shi-yi/">
        </link>
        <updated>2020-08-28T15:14:07.000Z</updated>
        <summary type="html"><![CDATA[<p>作者：元闰子<br>
链接：https://juejin.im/post/6859015515344633863<br>
来源：掘金<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></summary>
        <content type="html"><![CDATA[<p>作者：元闰子<br>
链接：https://juejin.im/post/6859015515344633863<br>
来源：掘金<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>从1995年GoF提出23种<strong>设计模式</strong>到现在，25年过去了，设计模式依旧是软件领域的热门话题。在当下，如果你不会一点设计模式，都不好意思说自己是一个合格的程序员。设计模式通常被定义为：</p>
<blockquote>
<p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p>
</blockquote>
<p>从定义上看，<strong>设计模式其实是一种经验的总结，是针对特定问题的简洁而优雅的解决方案</strong>。既然是经验总结，那么学习设计模式最直接的好处就在于可以站在巨人的肩膀上解决软件开发过程中的一些特定问题。然而，学习设计模式的最高境界是习得其中解决问题所用到的思想，当你把它们的本质思想吃透了，也就能做到<strong>即使已经忘掉某个设计模式的名称和结构，也能在解决特定问题时信手拈来</strong>。</p>
<p>好的东西有人吹捧，当然也会招黑。设计模式被抨击主要因为以下两点：</p>
<p>1、<em>设计模式会增加代码量，把程序逻辑变得复杂</em>。这一点是不可避免的，但是我们并不能仅仅只考虑开发阶段的成本。最简单的程序当然是一个函数从头写到尾，但是这样后期的维护成本会变得非常大；而设计模式虽然增加了一点开发成本，但是能让人们写出可复用、可维护性高的程序。引用《软件设计的哲学》里的概念，前者就是<strong>战术编程</strong>，后者就是<strong>战略编程</strong>，我们应该<strong>对战术编程Say No</strong>！（请移步<a href="https://www.yrunz.com/archives/%E4%B8%80%E6%AD%A5%E6%AD%A5%E9%99%8D%E4%BD%8E%E8%BD%AF%E4%BB%B6%E5%A4%8D%E6%9D%82%E6%80%A7">《一步步降低软件复杂性》</a>）</p>
<p>2、<em>滥用设计模式</em>。这是初学者最容易犯的错误，当学到一个模式时，恨不得在所有的代码都用上，从而在不该使用模式的地方刻意地使用了模式，导致了程序变得异常复杂。其实每个设计模式都有几个关键要素：<strong>适用场景</strong>、<strong>解决方法</strong>、<strong>优缺点</strong>。模式并不是万能药，它只有在特定的问题上才能显现出效果。所以，在使用一个模式前，先问问自己，当前的这个场景适用这个模式吗？</p>
<p>《设计模式》一书的副标题是“可复用面向对象软件的基础”，但并不意味着只有面向对象语言才能使用设计模式。模式只是一种解决特定问题的思想，跟语言无关。就像Go语言一样，它并非是像C++和Java一样的面向对象语言，但是设计模式同样适用。本系列文章将使用Go语言来实现GoF提出的23种设计模式，按照<strong>创建型模式</strong>（Creational Pattern）、<strong>结构型模式</strong>（Structural Pattern）和<strong>行为型模式</strong>（Behavioral Pattern）三种类别进行组织，文本主要介绍其中的创建型模式。</p>
<h2 id="单例模式singleton-pattern">单例模式（Singleton Pattern）</h2>
<figure data-type="image" tabindex="1"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghky3yanabj318q0iwnpd.jpg" alt="单例模式结构" loading="lazy"></figure>
<h3 id="简述">简述</h3>
<p>单例模式算是23中设计模式里最简单的一个了，它主要用于<strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点</strong>。</p>
<p>在程序设计中，有一些对象通常我们只需要一个共享的实例，比如线程池、全局缓存、对象池等，这种场景下就适合使用单例模式。</p>
<p>但是，并非所有全局唯一的场景都适合使用单例模式。比如，考虑需要统计一个API调用的情况，有两个指标，成功调用次数和失败调用次数。这两个指标都是全局唯一的，所以有人可能会将其建模成两个单例<code>SuccessApiMetric</code>和<code>FailApiMetric</code>。按照这个思路，随着指标数量的增多，你会发现代码里类的定义会越来越多，也越来越臃肿。这也是单例模式最常见的误用场景，更好的方法是将两个指标设计成一个对象<code>ApiMetric</code>下的两个实例<code>ApiMetic success</code>和<code>ApiMetic fail</code>。</p>
<p><em>如何判断一个对象是否应该被建模成单例？</em></p>
<p>通常，被建模成单例的对象都有“<strong>中心点</strong>”的含义，比如线程池就是管理所有线程的中心。所以，在判断一个对象是否适合单例模式时，先思考下，这个对象是一个中心点吗？</p>
<h3 id="go实现">Go实现</h3>
<p>在对某个对象实现单例模式时，有两个点必须要注意：（1）<strong>限制调用者直接实例化该对象</strong>；（2）<strong>为该对象的单例提供一个全局唯一的访问方法</strong>。</p>
<p>对于C++/Java而言，只需把类的构造函数设计成私有的，并提供一个<code>static</code>方法去访问该类点唯一实例即可。但对于Go语言来说，即没有构造函数的概念，也没有<code>static</code>方法，所以需要另寻出路。</p>
<p>我们可以利用Go语言<code>package</code>的访问规则来实现，将单例结构体设计成首字母小写，就能限定其访问范围只在当前package下，模拟了C++/Java中的私有构造函数；再在当前<code>package</code>下实现一个首字母大写的访问函数，就相当于<code>static</code>方法的作用了。</p>
<p>在实际开发中，我们经常会遇到需要频繁创建和销毁的对象。频繁的创建和销毁一则消耗CPU，二则内存的利用率也不高，通常我们都会使用对象池技术来进行优化。考虑我们需要实现一个消息对象池，因为是全局的中心点，管理所有的Message实例，所以将其实现成单例，实现代码如下：</p>
<pre><code class="language-go">package msgpool
...
// 消息池
type messagePool struct {
    pool *sync.Pool
}
// 消息池单例
var msgPool = &amp;messagePool{
    // 如果消息池里没有消息，则新建一个Count值为0的Message实例
    pool: &amp;sync.Pool{New: func() interface{} { return &amp;Message{Count: 0} }},
}
// 访问消息池单例的唯一方法
func Instance() *messagePool {
    return msgPool
}
// 往消息池里添加消息
func (m *messagePool) AddMsg(msg *Message) {
    m.pool.Put(msg)
}
// 从消息池里获取消息
func (m *messagePool) GetMsg() *Message {
    return m.pool.Get().(*Message)
}
...
复制代码
</code></pre>
<p>测试代码如下：</p>
<pre><code class="language-go">package test
...
func TestMessagePool(t *testing.T) {
    msg0 := msgpool.Instance().GetMsg()
    if msg0.Count != 0 {
        t.Errorf(&quot;expect msg count %d, but actual %d.&quot;, 0, msg0.Count)
    }
    msg0.Count = 1
    msgpool.Instance().AddMsg(msg0)
    msg1 := msgpool.Instance().GetMsg()
    if msg1.Count != 1 {
        t.Errorf(&quot;expect msg count %d, but actual %d.&quot;, 1, msg1.Count)
    }
}
// 运行结果
=== RUN   TestMessagePool
--- PASS: TestMessagePool (0.00s)
PASS
复制代码
</code></pre>
<p>以上的单例模式就是典型的“<strong>饿汉模式</strong>”，实例在系统加载的时候就已经完成了初始化。对应地，还有一种“<strong>懒汉模式</strong>”，只有等到对象被使用的时候，才会去初始化它，从而一定程度上节省了内存。众所周知，“懒汉模式”会带来线程安全问题，可以通过<strong>普通加锁</strong>，或者更高效的<strong>双重检验锁</strong>来优化。对于“懒汉模式”，Go语言有一个更优雅的实现方式，那就是利用<code>sync.Once</code>，它有一个<code>Do</code>方法，其入参是一个方法，Go语言会保证仅仅只调用一次该方法。</p>
<pre><code class="language-go">// 单例模式的“懒汉模式”实现
package msgpool
...
var once = &amp;sync.Once{}
// 消息池单例，在首次调用时初始化
var msgPool *messagePool
// 全局唯一获取消息池pool到方法
func Instance() *messagePool {
    // 在匿名函数中实现初始化逻辑，Go语言保证只会调用一次
    once.Do(func() {
        msgPool = &amp;messagePool{
            // 如果消息池里没有消息，则新建一个Count值为0的Message实例
            pool: &amp;sync.Pool{New: func() interface{} { return &amp;Message{Count: 0} }},
        }
    })
    return msgPool
}
...
复制代码
</code></pre>
<h2 id="建造者模式builder-pattern">建造者模式（Builder Pattern）</h2>
<figure data-type="image" tabindex="2"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghky4kprezj319e0kuu0x.jpg" alt="建造者模式结构" loading="lazy"></figure>
<h3 id="简述-2">简述</h3>
<p>在程序设计中，我们会经常遇到一些复杂的对象，其中有很多成员属性，甚至嵌套着多个复杂的对象。这种情况下，创建这个复杂对象就会变得很繁琐。对于C++/Java而言，最常见的表现就是构造函数有着长长的参数列表：</p>
<pre><code class="language-java">MyObject obj = new MyObject(param1, param2, param3, param4, param5, param6, ...)
复制代码
</code></pre>
<p>而对于Go语言来说，最常见的表现就是多层的嵌套实例化：</p>
<pre><code class="language-go">obj := &amp;MyObject{
  Field1: &amp;Field1 {
    Param1: &amp;Param1 {
      Val: 0,
    },
    Param2: &amp;Param2 {
      Val: 1,
    },
    ...
  },
  Field2: &amp;Field2 {
    Param3: &amp;Param3 {
      Val: 2,
    },
    ...
  },
  ...
}
复制代码
</code></pre>
<p>上述的对象创建方法有两个明显的缺点：（1）<strong>对对象使用者不友好</strong>，使用者在创建对象时需要知道的细节太多；（2）<strong>代码可读性很差</strong>。</p>
<p><em>针对这种对象成员较多，创建对象逻辑较为繁琐的场景，就适合使用建造者模式来进行优化。</em></p>
<p>建造者模式的作用有如下几个：</p>
<p>1、封装复杂对象的创建过程，使对象使用者不感知复杂的创建逻辑。</p>
<p>2、可以一步步按照顺序对成员进行赋值，或者创建嵌套对象，并最终完成目标对象的创建。</p>
<p>3、对多个对象复用同样的对象创建逻辑。</p>
<p>其中，第1和第2点比较常用，下面对建造者模式的实现也主要是针对这两点进行示例。</p>
<h3 id="go实现-2">Go实现</h3>
<p>考虑如下的一个<code>Message</code>结构体，其主要有<code>Header</code>和<code>Body</code>组成：</p>
<pre><code class="language-go">package msg
...
type Message struct {
    Header *Header
    Body   *Body
}
type Header struct {
    SrcAddr  string
    SrcPort  uint64
    DestAddr string
    DestPort uint64
    Items    map[string]string
}
type Body struct {
    Items []string
}
...
复制代码
</code></pre>
<p>如果按照直接的对象创建方式，创建逻辑应该是这样的：</p>
<pre><code class="language-go">// 多层的嵌套实例化
message := msg.Message{
    Header: &amp;msg.Header{
        SrcAddr:  &quot;192.168.0.1&quot;,
        SrcPort:  1234,
        DestAddr: &quot;192.168.0.2&quot;,
        DestPort: 8080,
        Items:    make(map[string]string),
    },
    Body:   &amp;msg.Body{
        Items: make([]string, 0),
    },
}
// 需要知道对象的实现细节
message.Header.Items[&quot;contents&quot;] = &quot;application/json&quot;
message.Body.Items = append(message.Body.Items, &quot;record1&quot;)
message.Body.Items = append(message.Body.Items, &quot;record2&quot;)
复制代码
</code></pre>
<p>虽然<code>Message</code>结构体嵌套的层次不多，但是从其创建的代码来看，确实存在<strong>对对象使用者不友好</strong>和<strong>代码可读性差</strong>的缺点。下面我们引入建造者模式对代码进行重构：</p>
<pre><code class="language-go">package msg
...
// Message对象的Builder对象
type builder struct {
    once *sync.Once
    msg *Message
}
// 返回Builder对象
func Builder() *builder {
    return &amp;builder{
        once: &amp;sync.Once{},
        msg: &amp;Message{Header: &amp;Header{}, Body: &amp;Body{}},
    }
}
// 以下是对Message成员对构建方法
func (b *builder) WithSrcAddr(srcAddr string) *builder {
    b.msg.Header.SrcAddr = srcAddr
    return b
}
func (b *builder) WithSrcPort(srcPort uint64) *builder {
    b.msg.Header.SrcPort = srcPort
    return b
}
func (b *builder) WithDestAddr(destAddr string) *builder {
    b.msg.Header.DestAddr = destAddr
    return b
}
func (b *builder) WithDestPort(destPort uint64) *builder {
    b.msg.Header.DestPort = destPort
    return b
}
func (b *builder) WithHeaderItem(key, value string) *builder {
  // 保证map只初始化一次
    b.once.Do(func() {
        b.msg.Header.Items = make(map[string]string)
    })
    b.msg.Header.Items[key] = value
    return b
}
func (b *builder) WithBodyItem(record string) *builder {
    b.msg.Body.Items = append(b.msg.Body.Items, record)
    return b
}
// 创建Message对象，在最后一步调用
func (b *builder) Build() *Message {
    return b.msg
}
复制代码
</code></pre>
<p>测试代码如下：</p>
<pre><code class="language-go">package test
...
func TestMessageBuilder(t *testing.T) {
  // 使用消息建造者进行对象创建
    message := msg.Builder().
        WithSrcAddr(&quot;192.168.0.1&quot;).
        WithSrcPort(1234).
        WithDestAddr(&quot;192.168.0.2&quot;).
        WithDestPort(8080).
        WithHeaderItem(&quot;contents&quot;, &quot;application/json&quot;).
        WithBodyItem(&quot;record1&quot;).
        WithBodyItem(&quot;record2&quot;).
        Build()
    if message.Header.SrcAddr != &quot;192.168.0.1&quot; {
        t.Errorf(&quot;expect src address 192.168.0.1, but actual %s.&quot;, message.Header.SrcAddr)
    }
    if message.Body.Items[0] != &quot;record1&quot; {
        t.Errorf(&quot;expect body item0 record1, but actual %s.&quot;, message.Body.Items[0])
    }
}
// 运行结果
=== RUN   TestMessageBuilder
--- PASS: TestMessageBuilder (0.00s)
PASS
复制代码
</code></pre>
<p>从测试代码可知，使用建造者模式来进行对象创建，使用者不再需要知道对象具体的实现细节，代码可读性也更好。</p>
<h2 id="工厂方法模式factory-method-pattern">工厂方法模式（Factory Method Pattern）</h2>
<figure data-type="image" tabindex="3"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkpq8hayrj31cm0sskjm.jpg" alt="工厂方法模式结构" loading="lazy"></figure>
<h3 id="简述-3">简述</h3>
<p>工厂方法模式跟上一节讨论的建造者模式类似，都是<strong>将对象创建的逻辑封装起来，为使用者提供一个简单易用的对象创建接口</strong>。两者在应用场景上稍有区别，建造者模式更常用于需要传递多个参数来进行实例化的场景。</p>
<p>使用工厂方法来创建对象主要有两个好处：</p>
<p>1、<strong>代码可读性更好</strong>。相比于使用C++/Java中的构造函数，或者Go中的<code>{}</code>来创建对象，工厂方法因为可以通过函数名来表达代码含义，从而具备更好的可读性。比如，使用工厂方法<code>productA := CreateProductA()</code>创建一个<code>ProductA</code>对象，比直接使用<code>productA := ProductA{}</code>的可读性要好。</p>
<p>2、<strong>与使用者代码解耦</strong>。很多情况下，对象的创建往往是一个容易变化的点，通过工厂方法来封装对象的创建过程，可以在创建逻辑变更时，避免<strong>霰弹式修改</strong>。</p>
<p>工厂方法模式也有两种实现方式：（1）提供一个工厂对象，通过调用工厂对象的工厂方法来创建产品对象；（2）将工厂方法集成到产品对象中（C++/Java中对象的<code>static</code>方法，Go中同一<code>package</code>下的函数）</p>
<h3 id="go实现-3">Go实现</h3>
<p>考虑有一个事件对象<code>Event</code>，分别有两种有效的时间类型<code>Start</code>和<code>End</code>：</p>
<pre><code class="language-go">package event
...
type Type uint8
// 事件类型定义
const (
    Start Type = iota
    End
)
// 事件抽象接口
type Event interface {
    EventType() Type
    Content() string
}
// 开始事件，实现了Event接口
type StartEvent struct{
    content string
}
...
// 结束事件，实现了Event接口
type EndEvent struct{
    content string
}
...
复制代码
</code></pre>
<p>1、按照第一种实现方式，为<code>Event</code>提供一个工厂对象，具体代码如下：</p>
<pre><code class="language-go">package event
...
// 事件工厂对象
type Factory struct{}
// 更具事件类型创建具体事件
func (e *Factory) Create(etype Type) Event {
    switch etype {
    case Start:
        return &amp;StartEvent{
            content: &quot;this is start event&quot;,
        }
    case End:
        return &amp;EndEvent{
            content: &quot;this is end event&quot;,
        }
    default:
        return nil
    }
}
复制代码
</code></pre>
<p>测试代码如下：</p>
<pre><code class="language-go">package test
...
func TestEventFactory(t *testing.T) {
    factory := event.Factory{}
    e := factory.Create(event.Start)
    if e.EventType() != event.Start {
        t.Errorf(&quot;expect event.Start, but actual %v.&quot;, e.EventType())
    }
    e = factory.Create(event.End)
    if e.EventType() != event.End {
        t.Errorf(&quot;expect event.End, but actual %v.&quot;, e.EventType())
    }
}
// 运行结果
=== RUN   TestEventFactory
--- PASS: TestEventFactory (0.00s)
PASS
复制代码
</code></pre>
<p>2、按照第二种实现方式，分别给<code>Start</code>和<code>End</code>类型的<code>Event</code>单独提供一个工厂方法，代码如下：</p>
<pre><code class="language-go">package event
...
// Start类型Event的工厂方法
func OfStart() Event {
    return &amp;StartEvent{
        content: &quot;this is start event&quot;,
    }
}
// End类型Event的工厂方法
func OfEnd() Event {
    return &amp;EndEvent{
        content: &quot;this is end event&quot;,
    }
}
复制代码
</code></pre>
<p>测试代码如下：</p>
<pre><code class="language-go">package event
...
func TestEvent(t *testing.T) {
    e := event.OfStart()
    if e.EventType() != event.Start {
        t.Errorf(&quot;expect event.Start, but actual %v.&quot;, e.EventType())
    }
    e = event.OfEnd()
    if e.EventType() != event.End {
        t.Errorf(&quot;expect event.End, but actual %v.&quot;, e.EventType())
    }
}
// 运行结果
=== RUN   TestEvent
--- PASS: TestEvent (0.00s)
PASS
复制代码
</code></pre>
<h2 id="抽象工厂模式abstract-factory-pattern">抽象工厂模式（Abstract Factory Pattern）</h2>
<figure data-type="image" tabindex="4"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkxo5tf5ij31ak0om4qq.jpg" alt="抽象工厂模式结构" loading="lazy"></figure>
<h3 id="简述-4">简述</h3>
<p>在工厂方法模式中，我们通过一个工厂对象来创建一个产品族，具体创建哪个产品，则通过<code>swtich-case</code>的方式去判断。这也意味着该产品组上，每新增一类产品对象，都必须修改原来工厂对象的代码；而且随着产品的不断增多，工厂对象的职责也越来越重，违反了<strong>单一职责原则</strong>。</p>
<p>抽象工厂模式通过给工厂类新增一个抽象层解决了该问题，如上图所示，<code>FactoryA</code>和<code>FactoryB</code>都实现·抽象工厂接口，分别用于创建<code>ProductA</code>和<code>ProductB</code>。如果后续新增了<code>ProductC</code>，只需新增一个<code>FactoryC</code>即可，无需修改原有的代码；因为每个工厂只负责创建一个产品，因此也遵循了<strong>单一职责原则</strong>。</p>
<h3 id="go实现-4">Go实现</h3>
<p>考虑需要如下一个插件架构风格的消息处理系统，<code>pipeline</code>是消息处理的管道，其中包含了<code>input</code>、<code>filter</code>和<code>output</code>三个插件。我们需要实现根据配置来创建<code>pipeline</code> ，加载插件过程的实现非常适合使用工厂模式，其中<code>input</code>、<code>filter</code>和<code>output</code>三类插件的创建使用抽象工厂模式，而<code>pipeline</code>的创建则使用工厂方法模式。</p>
<figure data-type="image" tabindex="5"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghkw23e4r3j31bs0nge82.jpg" alt="抽象工厂模式示例" loading="lazy"></figure>
<p>各类插件和<code>pipeline</code>的接口定义如下：</p>
<pre><code class="language-go">package plugin
...
// 插件抽象接口定义
type Plugin interface {}
// 输入插件，用于接收消息
type Input interface {
    Plugin
    Receive() string
}
// 过滤插件，用于处理消息
type Filter interface {
    Plugin
    Process(msg string) string
}
// 输出插件，用于发送消息
type Output interface {
    Plugin
    Send(msg string)
}
复制代码
package pipeline
...
// 消息管道的定义
type Pipeline struct {
    input  plugin.Input
    filter plugin.Filter
    output plugin.Output
}
// 一个消息的处理流程为 input -&gt; filter -&gt; output
func (p *Pipeline) Exec() {
    msg := p.input.Receive()
    msg = p.filter.Process(msg)
    p.output.Send(msg)
}
复制代码
</code></pre>
<p>接着，我们定义<code>input</code>、<code>filter</code>、<code>output</code>三类插件接口的具体实现：</p>
<pre><code class="language-go">package plugin
...
// input插件名称与类型的映射关系，主要用于通过反射创建input对象
var inputNames = make(map[string]reflect.Type)
// Hello input插件，接收“Hello World”消息
type HelloInput struct {}

func (h *HelloInput) Receive() string {
    return &quot;Hello World&quot;
}
// 初始化input插件映射关系表
func init() {
    inputNames[&quot;hello&quot;] = reflect.TypeOf(HelloInput{})
}
复制代码
package plugin
...
// filter插件名称与类型的映射关系，主要用于通过反射创建filter对象
var filterNames = make(map[string]reflect.Type)
// Upper filter插件，将消息全部字母转成大写
type UpperFilter struct {}

func (u *UpperFilter) Process(msg string) string {
    return strings.ToUpper(msg)
}
// 初始化filter插件映射关系表
func init() {
    filterNames[&quot;upper&quot;] = reflect.TypeOf(UpperFilter{})
}
复制代码
package plugin
...
// output插件名称与类型的映射关系，主要用于通过反射创建output对象
var outputNames = make(map[string]reflect.Type)
// Console output插件，将消息输出到控制台上
type ConsoleOutput struct {}

func (c *ConsoleOutput) Send(msg string) {
    fmt.Println(msg)
}
// 初始化output插件映射关系表
func init() {
    outputNames[&quot;console&quot;] = reflect.TypeOf(ConsoleOutput{})
}
复制代码
</code></pre>
<p>然后，我们定义插件抽象工厂接口，以及对应插件的工厂实现：</p>
<pre><code class="language-go">package plugin
...
// 插件抽象工厂接口
type Factory interface {
    Create(conf Config) Plugin
}
// input插件工厂对象，实现Factory接口
type InputFactory struct{}
// 读取配置，通过反射机制进行对象实例化
func (i *InputFactory) Create(conf Config) Plugin {
    t, _ := inputNames[conf.Name]
    return reflect.New(t).Interface().(Plugin)
}
// filter和output插件工厂实现类似
type FilterFactory struct{}
func (f *FilterFactory) Create(conf Config) Plugin {
    t, _ := filterNames[conf.Name]
    return reflect.New(t).Interface().(Plugin)
}
type OutputFactory struct{}
func (o *OutputFactory) Create(conf Config) Plugin {
    t, _ := outputNames[conf.Name]
    return reflect.New(t).Interface().(Plugin)
}
复制代码
</code></pre>
<p>最后定义<code>pipeline</code>的工厂方法，调用<code>plugin.Factory</code>抽象工厂完成pipelien对象的实例化：</p>
<pre><code class="language-go">package pipeline
...
// 保存用于创建Plugin的工厂实例，其中map的key为插件类型，value为抽象工厂接口
var pluginFactories = make(map[plugin.Type]plugin.Factory)
// 根据plugin.Type返回对应Plugin类型的工厂实例
func factoryOf(t plugin.Type) plugin.Factory {
    factory, _ := pluginFactories[t]
    return factory
}
// pipeline工厂方法，根据配置创建一个Pipeline实例
func Of(conf Config) *Pipeline {
    p := &amp;Pipeline{}
    p.input = factoryOf(plugin.InputType).Create(conf.Input).(plugin.Input)
    p.filter = factoryOf(plugin.FilterType).Create(conf.Filter).(plugin.Filter)
    p.output = factoryOf(plugin.OutputType).Create(conf.Output).(plugin.Output)
    return p
}
// 初始化插件工厂对象
func init() {
    pluginFactories[plugin.InputType] = &amp;plugin.InputFactory{}
    pluginFactories[plugin.FilterType] = &amp;plugin.FilterFactory{}
    pluginFactories[plugin.OutputType] = &amp;plugin.OutputFactory{}
}
复制代码
</code></pre>
<p>测试代码如下：</p>
<pre><code class="language-go">package test
...
func TestPipeline(t *testing.T) {
  // 其中pipeline.DefaultConfig()的配置内容见【抽象工厂模式示例图】
  // 消息处理流程为 HelloInput -&gt; UpperFilter -&gt; ConsoleOutput
    p := pipeline.Of(pipeline.DefaultConfig())
    p.Exec()
}
// 运行结果
=== RUN   TestPipeline
HELLO WORLD
--- PASS: TestPipeline (0.00s)
PASS
复制代码
</code></pre>
<h2 id="原型模式prototype-pattern">原型模式（Prototype Pattern）</h2>
<figure data-type="image" tabindex="6"><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghky39ichjj319u0gqhdt.jpg" alt="原型模式结构" loading="lazy"></figure>
<h3 id="简述-5">简述</h3>
<p>原型模式主要解决对象复制的问题，它的核心就是<code>clone()</code>方法，返回<code>Prototype</code>对象的复制品。在程序设计过程中，往往会遇到有一些场景需要大量相同的对象，如果不使用原型模式，那么我们可能会这样进行对象的创建：<em>新创建一个相同对象的实例，然后遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中</em>。这种方法的缺点很明显，那就是使用者必须知道对象的实现细节，导致代码之间的耦合。另外，对象很有可能存在除了对象本身以外不可见的变量，这种情况下该方法就行不通了。</p>
<p>对于这种情况，更好的方法就是使用原型模式，将复制逻辑委托给对象本身，这样，上述两个问题也都迎刃而解了。</p>
<h3 id="go实现-5">Go实现</h3>
<p>还是以建造者模式一节中的<code>Message</code>作为例子，现在设计一个<code>Prototype</code>抽象接口：</p>
<pre><code class="language-go">package prototype
...
// 原型复制抽象接口
type Prototype interface {
    clone() Prototype
}

type Message struct {
    Header *Header
    Body   *Body
}

func (m *Message) clone() Prototype {
    msg := *m
    return &amp;msg
}
复制代码
</code></pre>
<p>测试代码如下：</p>
<pre><code class="language-go">package test
...
func TestPrototype(t *testing.T) {
    message := msg.Builder().
        WithSrcAddr(&quot;192.168.0.1&quot;).
        WithSrcPort(1234).
        WithDestAddr(&quot;192.168.0.2&quot;).
        WithDestPort(8080).
        WithHeaderItem(&quot;contents&quot;, &quot;application/json&quot;).
        WithBodyItem(&quot;record1&quot;).
        WithBodyItem(&quot;record2&quot;).
        Build()
  // 复制一份消息
    newMessage := message.Clone().(*msg.Message)
    if newMessage.Header.SrcAddr != message.Header.SrcAddr {
        t.Errorf(&quot;Clone Message failed.&quot;)
    }
    if newMessage.Body.Items[0] != message.Body.Items[0] {
        t.Errorf(&quot;Clone Message failed.&quot;)
    }
}
// 运行结果
=== RUN   TestPrototype
--- PASS: TestPrototype (0.00s)
PASS
复制代码
</code></pre>
<h2 id="总结">总结</h2>
<p>本文主要介绍了GoF的23种设计模式中的5种创建型模式，创建型模式的目的都是<strong>提供一个简单的接口，让对象的创建过程与使用者解耦</strong>。其中，<strong>单例模式</strong>主要用于保证一个类仅有一个实例，并提供一个访问它的全局访问点；<strong>建造者模式</strong>主要解决需要创建对象时需要传入多个参数，或者对初始化顺序有要求的场景；<strong>工厂方法模式</strong>通过提供一个工厂对象或者工厂方法，为使用者隐藏了对象创建的细节；<strong>抽象工厂模式</strong>是对工厂方法模式的优化，通过为工厂对象新增一个抽象层，让工厂对象遵循单一职责原则，也避免了霰弹式修改；<strong>原型模式</strong>则让对象复制更加简单。</p>
<p>下一篇文章，将介绍23种设计模式中的7种<strong>结构型模式</strong>（Structural Pattern），及其Go语言的实现。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用 golang 实现的十大经典排序]]></title>
        <id>https://ChicRingo.github.io/post/yong-golang-shi-xian-de-shi-da-jing-dian-pai-xu/</id>
        <link href="https://ChicRingo.github.io/post/yong-golang-shi-xian-de-shi-da-jing-dian-pai-xu/">
        </link>
        <updated>2020-08-28T05:06:03.000Z</updated>
        <summary type="html"><![CDATA[<p>用go语言实现的十大经典排序</p>
]]></summary>
        <content type="html"><![CDATA[<p>用go语言实现的十大经典排序</p>
<!-- more -->
<h3 id="冒泡排序">冒泡排序</h3>
<pre><code class="language-go">// 冒泡排序
func bubble(nums []int) []int {
   numLen := len(nums)

   for i := 0; i &lt; numLen; i++ {
      // 按相邻两个一起比较，所以最后一个不用遍历 -1,已经排序的也不用重新排序，所以-i，不写也可
      for j := 0; j &lt; numLen-1-i; j++ {
         // 当前值大于后一个值，则对换位置
         if nums[j] &gt; nums[j+1] {
            nums[j], nums[j+1] = nums[j+1], nums[j]
         }
      }
   }

   return nums
}
</code></pre>
<h3 id="选择排序">选择排序</h3>
<pre><code class="language-go">func selection(nums []int) []int {
   numLen := len(nums)
   //最后一个不用排序了
   for i := 0; i &lt; numLen-1; i++ {
      //每次最小值的位置index
      var minIndex = i
      // 从第二个开始排序，也就是i+1
      for j := i + 1; j &lt; numLen; j++ {
         if nums[j] &lt; nums[minIndex] {
            minIndex = j
         }
      }
      nums[i], nums[minIndex] = nums[minIndex], nums[i]
   }

   return nums
}
</code></pre>
<h3 id="插入排序">插入排序</h3>
<pre><code class="language-go">func insertion(nums []int) []int {
   // 网上写法
   for i, tmp := range nums {
      // 前一个索引值
      preIndex := i - 1
      // 定义一个临时变量取当前的值（挖出来腾地方，给前面的往后挪位置的空间
      //tmp := nums[i]
      // 如果当前值 tmp 小于前面的值，就把前面的值往后挪，因为tmp已经保存过相当于空的
      for preIndex &gt;= 0 &amp;&amp; tmp &lt; nums[preIndex] {
         nums[preIndex+1] = nums[preIndex]
         preIndex--
      }
      // 不满足以上条件时，说明没有比tmp更小的，就保存tmp当前值到新的位置
      nums[preIndex+1] = tmp
   }

   // 自己写法
   //numLen := len(nums)
   //for i := 1; i &lt; numLen; i++ { //从第2个开始，i=1开始
   //
   // temp := nums[i] // 定义一个临时变量取当前的值
   // // 把该值tmp与之前的数 从后往前进行比较
   // for j := i - 1; j &gt;= 0; j-- {
   //    // 当 当前值tmp 比之前的某个值大,那么插入,否则把每个值往后移一位
   //    if temp &gt; nums[j] {
   //       nums[j+1] = temp
   //       break
   //    } else {
   //       nums[j+1] = nums[j]
   //    }
   //    // 如果都移动了,然后遍历到0了,说明当前值是最小的,把当前值放到最小的位置
   //    if j == 0 {
   //       nums[0] = temp
   //    }
   // }
   //}
   return nums
}
</code></pre>
<h3 id="希尔排序">希尔排序</h3>
<h3 id="归并排序">归并排序</h3>
<h3 id="快速排序">快速排序</h3>
<pre><code class="language-go">func partition(nums []int, left, right int) int {
   // 设基准值 privot 为left
   privot := left
   index := privot + 1
   for i := index; i &lt;= right; i++ {
      if nums[i] &lt; nums[privot] {
         nums[i], nums[index] = nums[index], nums[i]
         index++
      }
   }
   nums[privot], nums[index-1] = nums[index-1], nums[privot]
   return index - 1
}

func quickSort(nums []int, left, right int) {
   // 如果数组长度小于等于1，说明这个数组分区不需要再排序了，直接return
   if len(nums) &lt;= 1 {
      return
   }
   // 如果左小于右，
   if left &lt; right {
      partIndex := partition(nums, left, right)
      quickSort(nums, left, partIndex-1)
      quickSort(nums, partIndex+1, right)
   }
   return
}
</code></pre>
<h3 id="堆排序">堆排序</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我擦~字符串转字节切片后，切片的容量竟然千奇百怪]]></title>
        <id>https://ChicRingo.github.io/post/wo-ca-~zi-fu-chuan-zhuan-zi-jie-qie-pian-hou-qie-pian-de-rong-liang-jing-ran-qian-qi-bai-guai/</id>
        <link href="https://ChicRingo.github.io/post/wo-ca-~zi-fu-chuan-zhuan-zi-jie-qie-pian-hou-qie-pian-de-rong-liang-jing-ran-qian-qi-bai-guai/">
        </link>
        <updated>2020-08-25T00:56:36.000Z</updated>
        <summary type="html"><![CDATA[<p>字符串转字节切片步骤如下</p>
<ol>
<li>
<p>判断是否是常量， 如果是常量则转换为等容量等长的字节切片</p>
</li>
<li>
<p>如果是变量， 先判断生成的切片是否发生变量逃逸</p>
</li>
<li>
<ul>
<li>如果逃逸或者字符串长度&gt;32， 则根据字符串长度可以计算出不同的容量</li>
<li>如果未逃逸且字符串长度&lt;=32, 则字符切片容量为32</li>
</ul>
</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<p>字符串转字节切片步骤如下</p>
<ol>
<li>
<p>判断是否是常量， 如果是常量则转换为等容量等长的字节切片</p>
</li>
<li>
<p>如果是变量， 先判断生成的切片是否发生变量逃逸</p>
</li>
<li>
<ul>
<li>如果逃逸或者字符串长度&gt;32， 则根据字符串长度可以计算出不同的容量</li>
<li>如果未逃逸且字符串长度&lt;=32, 则字符切片容量为32</li>
</ul>
</li>
</ol>
<!-- more -->
<p>以下文章来源于新世界杂货铺 ，作者许文</p>
<p><a href="https://baijiahao.baidu.com/s?id=1671902920320901161"><strong>新世界杂货铺</strong>作为一名Gopher， 我愿称之为Go的干(杂)货铺子！</a></p>
<p>神奇的现象</p>
<p>切片， 切片， 又是切片!</p>
<p>今天遇到的神奇问题和切片有关， 具体怎么个神奇法， 我们来看看下面几个现象</p>
<h3 id="现象一">现象一</h3>
<pre><code>a := &quot;abc&quot;
bs := []byte(a)
fmt.Println(bs, len(bs), cap(bs))
// 输出： [97 98 99] 3 8
</code></pre>
<h3 id="现象二">现象二</h3>
<pre><code>a := &quot;abc&quot;
bs := []byte(a)
fmt.Println(len(bs), cap(bs))
// 输出: 3 32
</code></pre>
<h3 id="现象三">现象三</h3>
<pre><code>bs := []byte(&quot;abc&quot;)
fmt.Println(len(bs), cap(bs))
// 输出: 3 3
</code></pre>
<h3 id="现象四">现象四</h3>
<pre><code>a := &quot;&quot;
bs := []byte(a)
fmt.Println(bs, len(bs), cap(bs))
// 输出: [] 0 0
</code></pre>
<h3 id="现象五">现象五</h3>
<pre><code>a := &quot;&quot;
bs := []byte(a)
fmt.Println(len(bs), cap(bs))
// 输出: 0 32
</code></pre>
<h2 id="分析">分析</h2>
<p>到这儿我已经满脑子问号了</p>
<figure data-type="image" tabindex="1"><img src="https://pics4.baidu.com/feed/b7003af33a87e95024fc161f982aa645faf2b4f7.jpeg?token=851a11b97e2f5c17586d5100942c414e" alt="img" loading="lazy"></figure>
<h3 id="字符串变量转切片">字符串变量转切片</h3>
<p>一个小小的字符串转切片， 内部究竟发生了什么， 竟然如此的神奇。这种时候只好祭出汇编大法， 看看汇编代码(<code>希望之后有机会能够对go的汇编语法进行简单的介绍</code>)有没有什么关键词能够帮助我们</p>
<p>以下为现象一转换的汇编代码关键部分</p>
<pre><code>&quot;&quot;.main STEXT size=495 args=0x0 locals=0xd8
	0x0000 00000 (test.go:5)	TEXT	&quot;&quot;.main(SB), ABIInternal, $216-0
	0x0000 00000 (test.go:5)	MOVQ	(TLS), CX
	0x0009 00009 (test.go:5)	LEAQ	-88(SP), AX
	0x000e 00014 (test.go:5)	CMPQ	AX, 16(CX)
	0x0012 00018 (test.go:5)	JLS	485
	0x0018 00024 (test.go:5)	SUBQ	$216, SP
	0x001f 00031 (test.go:5)	MOVQ	BP, 208(SP)
	0x0027 00039 (test.go:5)	LEAQ	208(SP), BP
	0x002f 00047 (test.go:5)	FUNCDATA	$0, gclocals·7be4bbacbfdb05fb3044e36c22b41e8b(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$1, gclocals·648d0b72bb9d7f59fbfdbee57a078eee(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$2, gclocals·2dfddcc7190380b1ae77e69d81f0a101(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$3, &quot;&quot;.main.stkobj(SB)
	0x002f 00047 (test.go:6)	PCDATA	$0, $1
	0x002f 00047 (test.go:6)	PCDATA	$1, $0
	0x002f 00047 (test.go:6)	LEAQ	go.string.&quot;abc&quot;(SB), AX
	0x0036 00054 (test.go:6)	MOVQ	AX, &quot;&quot;.a+96(SP)
	0x003b 00059 (test.go:6)	MOVQ	$3, &quot;&quot;.a+104(SP)
	0x0044 00068 (test.go:7)	MOVQ	$0, (SP)
	0x004c 00076 (test.go:7)	PCDATA	$0, $0
	0x004c 00076 (test.go:7)	MOVQ	AX, 8(SP)
	0x0051 00081 (test.go:7)	MOVQ	$3, 16(SP)
	0x005a 00090 (test.go:7)	CALL	runtime.stringtoslicebyte(SB)
	0x005f 00095 (test.go:7)	MOVQ	40(SP), AX
	0x0064 00100 (test.go:7)	MOVQ	32(SP), CX
	0x0069 00105 (test.go:7)	PCDATA	$0, $2
	0x0069 00105 (test.go:7)	MOVQ	24(SP), DX
	0x006e 00110 (test.go:7)	PCDATA	$0, $0
	0x006e 00110 (test.go:7)	PCDATA	$1, $1
	0x006e 00110 (test.go:7)	MOVQ	DX, &quot;&quot;.bs+112(SP)
	0x0073 00115 (test.go:7)	MOVQ	CX, &quot;&quot;.bs+120(SP)
	0x0078 00120 (test.go:7)	MOVQ	AX, &quot;&quot;.bs+128(SP)
</code></pre>
<p>以下为现象二转换的汇编代码关键部分</p>
<pre><code>&quot;&quot;.main STEXT size=393 args=0x0 locals=0xe0
	0x0000 00000 (test.go:5)	TEXT	&quot;&quot;.main(SB), ABIInternal, $224-0
	0x0000 00000 (test.go:5)	MOVQ	(TLS), CX
	0x0009 00009 (test.go:5)	LEAQ	-96(SP), AX
	0x000e 00014 (test.go:5)	CMPQ	AX, 16(CX)
	0x0012 00018 (test.go:5)	JLS	383
	0x0018 00024 (test.go:5)	SUBQ	$224, SP
	0x001f 00031 (test.go:5)	MOVQ	BP, 216(SP)
	0x0027 00039 (test.go:5)	LEAQ	216(SP), BP
	0x002f 00047 (test.go:5)	FUNCDATA	$0, gclocals·0ce64bbc7cfa5ef04d41c861de81a3d7(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$1, gclocals·00590b99cfcd6d71bbbc6e05cb4f8bf8(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$2, gclocals·8dcadbff7c52509cfe2d26e4d7d24689(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$3, &quot;&quot;.main.stkobj(SB)
	0x002f 00047 (test.go:6)	PCDATA	$0, $1
	0x002f 00047 (test.go:6)	PCDATA	$1, $0
	0x002f 00047 (test.go:6)	LEAQ	go.string.&quot;abc&quot;(SB), AX
	0x0036 00054 (test.go:6)	MOVQ	AX, &quot;&quot;.a+120(SP)
	0x003b 00059 (test.go:6)	MOVQ	$3, &quot;&quot;.a+128(SP)
	0x0047 00071 (test.go:7)	PCDATA	$0, $2
	0x0047 00071 (test.go:7)	LEAQ	&quot;&quot;..autotmp_5+64(SP), CX
	0x004c 00076 (test.go:7)	PCDATA	$0, $1
	0x004c 00076 (test.go:7)	MOVQ	CX, (SP)
	0x0050 00080 (test.go:7)	PCDATA	$0, $0
	0x0050 00080 (test.go:7)	MOVQ	AX, 8(SP)
	0x0055 00085 (test.go:7)	MOVQ	$3, 16(SP)
	0x005e 00094 (test.go:7)	CALL	runtime.stringtoslicebyte(SB)
	0x0063 00099 (test.go:7)	MOVQ	40(SP), AX
	0x0068 00104 (test.go:7)	MOVQ	32(SP), CX
	0x006d 00109 (test.go:7)	PCDATA	$0, $3
	0x006d 00109 (test.go:7)	MOVQ	24(SP), DX
	0x0072 00114 (test.go:7)	PCDATA	$0, $0
	0x0072 00114 (test.go:7)	PCDATA	$1, $1
	0x0072 00114 (test.go:7)	MOVQ	DX, &quot;&quot;.bs+136(SP)
	0x007a 00122 (test.go:7)	MOVQ	CX, &quot;&quot;.bs+144(SP)
	0x0082 00130 (test.go:7)	MOVQ	AX, &quot;&quot;.bs+152(SP)
</code></pre>
<p>在看汇编代码之前， 我们首先来看一看<code>runtime.stringtoslicebyte</code>的函数签名</p>
<pre><code>func stringtoslicebyte(buf *tmpBuf, s string) []byte
</code></pre>
<p>到这里只靠关键词已经无法看出更多的信息了,还是需要稍微了解一下汇编的语法,笔者在这里列出一点简单的分析， 之后我们还是可以通过取巧的方法发现更多的东西</p>
<pre><code>// 现象一给runtime.stringtoslicebyte的传参
0x002f 00047 (test.go:6)	LEAQ	go.string.&quot;abc&quot;(SB), AX // 将字符串&quot;abc&quot;放入寄存器AX
0x0036 00054 (test.go:6)	MOVQ	AX, &quot;&quot;.a+96(SP) // 将AX中的内容存入变量a中
0x003b 00059 (test.go:6)	MOVQ	$3, &quot;&quot;.a+104(SP) // 将字符串长度3存入变量a中
0x0044 00068 (test.go:7)	MOVQ	$0, (SP) // 将0 传递个runtime.stringtoslicebyte(SB)的第一个参数(笔者猜测对应go中的nil)
0x004c 00076 (test.go:7)	PCDATA	$0, $0 // 据说和gc有关， 具体还不清楚， 一般情况可以忽略
0x004c 00076 (test.go:7)	MOVQ	AX, 8(SP) // 将AX中的内容传递给runtime.stringtoslicebyte(SB)的第二个参数
0x0051 00081 (test.go:7)	MOVQ	$3, 16(SP) // 将字符串长度传递给runtime.stringtoslicebyte(SB)的第二个参数
0x005a 00090 (test.go:7)	CALL	runtime.stringtoslicebyte(SB) // 调用函数， 此行后面的几行代码是将返回值赋值给变量bs

// 现象二给runtime.stringtoslicebyte的传参
0x002f 00047 (test.go:6)	LEAQ	go.string.&quot;abc&quot;(SB), AX // 将字符串&quot;abc&quot;放入寄存器AX
0x0036 00054 (test.go:6)	MOVQ	AX, &quot;&quot;.a+120(SP) // 将AX中的内容存入变量a中
0x003b 00059 (test.go:6)	MOVQ	$3, &quot;&quot;.a+128(SP) // 将字符串长度3存入变量a中
0x0047 00071 (test.go:7)	PCDATA	$0, $2
0x0047 00071 (test.go:7)	LEAQ	&quot;&quot;..autotmp_5+64(SP), CX // 将内部变量autotmp_5放入寄存器CX
0x004c 00076 (test.go:7)	PCDATA	$0, $1
0x004c 00076 (test.go:7)	MOVQ	CX, (SP) // 将CX中的内容传递给runtime.stringtoslicebyte(SB)的第一个参数
0x0050 00080 (test.go:7)	PCDATA	$0, $0
0x0050 00080 (test.go:7)	MOVQ	AX, 8(SP) // 将AX中的内容传递给runtime.stringtoslicebyte(SB)的第二个参数
0x0055 00085 (test.go:7)	MOVQ	$3, 16(SP) // 将字符串长度传递给runtime.stringtoslicebyte(SB)的第二个参数
0x005e 00094 (test.go:7)	CALL	runtime.stringtoslicebyte(SB)
</code></pre>
<p>通过上面汇编代码的分析可以知道，现象一和现象二的区别就是传递给<code>runtime.stringtoslicebyte</code>的第一个参数不同。通过对runtime包中<code>stringtoslicebyte</code>函数分析，第一个参数是否有值和字符串长度会影响代码执行的分支，从而生成不同的切片， 因此容量不一样也是常理之中， 下面我们看源码</p>
<pre><code>func stringtoslicebyte(buf *tmpBuf, s string) []byte {
	var b []byte
	if buf != nil &amp;&amp; len(s) &lt;= len(buf) {
		*buf = tmpBuf{}
		b = buf[:len(s)]
	} else {
		b = rawbyteslice(len(s))
	}
	copy(b, s)
	return b
}
</code></pre>
<p>然而， stringtoslicebyte的第一个参数什么情况下才会有值，什么情况下为nil, 我们仍然不清楚。那怎么办呢， 只好祭出全局搜索大法：</p>
<pre><code># 在go源码根目录执行下面的命令
grep stringtoslicebyte -r . | grep -v &quot;//&quot;
</code></pre>
<p>最终在go的编译器源码cmd/compile/internal/gc/walk.go发现了如下代码块</p>
<figure data-type="image" tabindex="2"><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" loading="lazy"></figure>
<p>我们查看<code>mkcall</code> 函数签名可以知道, 从第四个参数开始的所有变量都会作为参数传递给第一个参数对应的函数， 最后生成一个<code>*Node</code>的变量。其中Node结构体解释如下:</p>
<pre><code>// A Node is a single node in the syntax tree.
// Actually the syntax tree is a syntax DAG, because there is only one
// node with Op=ONAME for a given instance of a variable x.
// The same is true for Op=OTYPE and Op=OLITERAL. See Node.mayBeShared.
</code></pre>
<p>综合上述信息我们得出的结论是，编译器会对stringtoslicebyte的函数调用生成一个AST(抽象语法树)对应的节点。因此我们也知道传递给stringtoslicebyte函数的第一个变量也就对应于上图中的变量a.</p>
<p>其中a的初始值为<code>nodnil()</code>的返回值，即默认为<code>nil</code>. 但是<code>n.Esc == EscNone</code>时，a会变成一个数组。我们看一下EscNone的解释.</p>
<pre><code>// 此代码位于cmd/compile/internal/gc/esc.go中
const (
	// ...
	EscNone           // Does not escape to heap, result, or parameters.
    ...
)
</code></pre>
<p>由上可知, <code>EscNone</code>用来判断变量是否逃逸,到这儿了我们就很好办了，接下来我们对现象一和现象二的代码进行逃逸分析.</p>
<pre><code># 执行变量逃逸分析命令: go run -gcflags '-m -l' test.go
# 现象一逃逸分析如下：
./test.go:7:14: ([]byte)(a) escapes to heap
./test.go:8:13: main ... argument does not escape
./test.go:8:13: bs escapes to heap
./test.go:8:21: len(bs) escapes to heap
./test.go:8:30: cap(bs) escapes to heap
[97 98 99] 3 8
# 现象二逃逸分析如下：
./test.go:7:14: main ([]byte)(a) does not escape
./test.go:8:13: main ... argument does not escape
./test.go:8:17: len(bs) escapes to heap
./test.go:8:26: cap(bs) escapes to heap
3 32
</code></pre>
<p>根据上面的信息我们知道在现象一中，bs变量发生了逃逸，现象二中变量未发生逃逸，也就是说stringtoslicebyte函数的第一个参数在变量未发生逃逸时其值不为nil,变量发生逃逸时其值为nil。到这里我们已经搞明白stringtoslicebyte的第一个参数了， 那我们继续分析stringtoslicebyte的内部逻辑</p>
<p>我们在runtime/string.go中看到stringtoslicebyte第一个参数的类型定义如下：</p>
<pre><code>const tmpStringBufSize = 32

type tmpBuf [tmpStringBufSize]byte
</code></pre>
<p>综上: 现象二中bs变量未发生变量逃逸, stringtoslicebyte第一个参数不为空且是一个长度为32的byte数组, 因此在现象二中生成了一个容量为32的切片</p>
<p>根据对stringtoslicebyte的源码分析， 我们知道现象一调用了<code>rawbyteslice</code>函数</p>
<pre><code>func rawbyteslice(size int) (b []byte) {
	cap := roundupsize(uintptr(size))
	p := mallocgc(cap, nil, false)
	if cap != uintptr(size) {
		memclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size))
	}

	*(*slice)(unsafe.Pointer(&amp;b)) = slice{p, size, int(cap)}
	return
}
</code></pre>
<p>由上面的代码知道， 切片的容量通过runtime/msize.go中的<code>roundupsize</code>函数计算得出, 其中_MaxSmallSize和class_to_size均定义在runtime/sizeclasses.go</p>
<pre><code>func roundupsize(size uintptr) uintptr {
	if size &lt; _MaxSmallSize {
		if size &lt;= smallSizeMax-8 {
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
		} else {
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
		}
	}
	if size+_PageSize &lt; size {
		return size
	}
	return round(size, _PageSize)
}
</code></pre>
<p>由于字符串abc的长度小于_MaxSmallSize(32768)，故切片的长度只能取数组class_to_size中的值， 即<code>0, 8, 16, 32, 48, 64, 80, 96, 112, 128....</code>s</p>
<p>至此, 现象一中切片容量为什么为8也真相大白了。相信到这里很多人已经明白现象四和现象五是怎么回事儿了, 其逻辑分别与现象一和现象二是一致的， 有兴趣的， 可以在自己的电脑上面试一试。</p>
<h3 id="字符串直接转切片">字符串直接转切片</h3>
<p>那你说了这么多， 现象三还是不能解释啊。请各位看官莫急， 接下来我们继续分析。</p>
<p>相信各位细心的小伙伴应该早就发现了我们在上面的<code>cmd/compile/internal/gc/walk.go</code>源码图中折叠了部分代码， 现在我们就将这块神秘的代码赤裸裸的展示出来</p>
<p>我们分析这块代码发现,go编译器在将<code>字符串转字节切片</code>生成AST时，总共分为三步。</p>
<ol>
<li>先判断该变量是否是常量字符串,如果是常量字符串,则直接通过<code>types.NewArray</code>创建一个和字符串等长的数组</li>
<li>常量字符串生成的切片变量也要进行逃逸分析，并判断其大小是否大于函数栈允许分配给变量的最大长度， 从而判断节点是分配在栈上还是在堆上</li>
<li>最后，如果字符串长度是大于0， 将字符串内容复制到字节切片中， 然后返回。因此现象三中的切片容量是3也就完全清楚了</li>
</ol>
<h2 id="结论">结论</h2>
<p>字符串转字节切片步骤如下</p>
<ol>
<li>
<p>判断是否是常量， 如果是常量则转换为等容量等长的字节切片</p>
</li>
<li>
<p>如果是变量， 先判断生成的切片是否发生变量逃逸</p>
</li>
<li>
<ul>
<li>如果逃逸或者字符串长度&gt;32， 则根据字符串长度可以计算出不同的容量</li>
<li>如果未逃逸且字符串长度&lt;=32, 则字符切片容量为32</li>
</ul>
</li>
</ol>
<h2 id="扩展">扩展</h2>
<p>常见逃逸情况</p>
<ol>
<li>函数返回局部指针</li>
<li>栈空间不足逃逸</li>
<li>动态类型逃逸, 很多函数参数为interface类型，比如fmt.Println(a ...interface{})，编译期间很难确定其参数的具体类型, 也会发生逃逸</li>
<li>闭包引用对象逃逸</li>
</ol>
<blockquote>
<p>注: 写本文时， 笔者所用go版本为: go1.13.4</p>
</blockquote>
<blockquote>
<p>生命不息， 探索不止， 后续将持续更新有关于go的技术探索</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Hugo 搭建博客]]></title>
        <id>https://ChicRingo.github.io/post/shi-yong-hugo-da-jian-bo-ke/</id>
        <link href="https://ChicRingo.github.io/post/shi-yong-hugo-da-jian-bo-ke/">
        </link>
        <updated>2020-08-21T15:40:21.000Z</updated>
        <content type="html"><![CDATA[<p>https://www.diguage.com/post/building-blog-with-hugo/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用2个goroutine轮流打印一个数组]]></title>
        <id>https://ChicRingo.github.io/post/shi-yong-2-ge-goroutine-lun-liu-da-yin-yi-ge-shu-zu/</id>
        <link href="https://ChicRingo.github.io/post/shi-yong-2-ge-goroutine-lun-liu-da-yin-yi-ge-shu-zu/">
        </link>
        <updated>2020-08-21T11:11:56.000Z</updated>
        <summary type="html"><![CDATA[<p>今天遇到群友的一到面试题，感觉在各种地方看到很多次这种类似的题目，比如两个goroutine轮流打印奇偶数，所以记录整理下来。</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天遇到群友的一到面试题，感觉在各种地方看到很多次这种类似的题目，比如两个goroutine轮流打印奇偶数，所以记录整理下来。</p>
<!-- more -->
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

// 使用2个goroutine轮流打印一个数组
var wg sync.WaitGroup
var ch = make(chan bool)
var send = make(chan int)

func main() {
    wg.Add(3)
    nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
    l := len(nums)
    go Send(nums, l)      // 发送
    go printOdd(l)  // 打印奇数
    go printEven(l) // 打印偶数
    wg.Wait()
}

// 发送数组元素
func Send(nums []int, l int) {
    defer wg.Done()
    for i := 0; i &lt; l; i++ {
        a := nums[i]
        send &lt;- a
    }
}

// 打印奇数
func printEven(l int) {
    defer wg.Done()
    for i := 0; i &lt; l; i++ {
        ch &lt;- true
        if i&amp;1 == 0 {
            a := &lt;-send
            fmt.Println(&quot;printEven:&quot;, a)
        }
    }
}

// 打印偶数
func printOdd(l int) {
    defer wg.Done()
    for i := 0; i &lt; l; i++ {
        &lt;-ch
        if i&amp;1 == 1 {
            a := &lt;-send
            fmt.Println(&quot;printOdd: &quot;, a)
        }
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang 并发控制的两种模式]]></title>
        <id>https://ChicRingo.github.io/post/golang-bing-fa-kong-zhi-de-liang-chong-mo-shi/</id>
        <link href="https://ChicRingo.github.io/post/golang-bing-fa-kong-zhi-de-liang-chong-mo-shi/">
        </link>
        <updated>2020-08-20T14:38:27.000Z</updated>
        <summary type="html"><![CDATA[<p>Golang 两种常用的并发控制，使用 channel 和 WaitGroup 两种模式</p>
]]></summary>
        <content type="html"><![CDATA[<p>Golang 两种常用的并发控制，使用 channel 和 WaitGroup 两种模式</p>
<!-- more -->
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

func main() {
	fmt.Println(&quot;Hello, 世界&quot;)
	handle1()
	handle2()
}

func handle1() {
	// 通过无缓冲通道来实现多 goroutine 并发控制

	// create channel to synchronize
	done := make(chan bool) // 无缓冲通道
	defer close(done)

	go func() {
		time.Sleep(1 * time.Second)
		fmt.Println(&quot;one done&quot;)
		done &lt;- true
	}()

	go func() {
		time.Sleep(1 * time.Second)
		fmt.Println(&quot;two done&quot;)
		done &lt;- true
	}()

	// wait until both are done
	for c := 0; c &lt; 2; c++ {
		&lt;-done
	}
	fmt.Println(&quot;handle1 done&quot;)
	// 当主 goroutine 运行到 &lt;-done 接受 channel 的值的时候，如果该  channel 中没有数据，就会一直阻塞等待，直到有值。
}

func handle2() {
	// 通过sync包中的WaitGroup 实现并发控制

	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		time.Sleep(1 * time.Second)
		fmt.Println(&quot;1 done&quot;)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		time.Sleep(1 * time.Second)
		fmt.Println(&quot;2 done&quot;)
		wg.Done()
	}()
	wg.Wait()
	fmt.Println(&quot;handle2 done&quot;)

	// 在 sync 包中，提供了 WaitGroup ，它会等待它收集的所有 goroutine 任务全部完成，在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回。
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang并发模型：并发协程的优雅退出]]></title>
        <id>https://ChicRingo.github.io/post/golang-bing-fa-mo-xing-bing-fa-xie-cheng-de-you-ya-tui-chu/</id>
        <link href="https://ChicRingo.github.io/post/golang-bing-fa-mo-xing-bing-fa-xie-cheng-de-you-ya-tui-chu/">
        </link>
        <updated>2020-08-20T11:35:30.000Z</updated>
        <summary type="html"><![CDATA[<p>文章来源：<a href="https://lessisbetter.site/2018/12/02/golang-exit-goroutine-in-3-ways/">Golang并发模型：并发协程的优雅退出</a><br>
goroutine作为Golang并发的核心，我们不仅要关注它们的创建和管理，当然还要关注如何合理的退出这些协程，不（合理）退出不然可能会造成阻塞、panic、程序行为异常、数据结果不正确等问题。这篇文章介绍，如何合理的退出goroutine，减少软件bug。</p>
]]></summary>
        <content type="html"><![CDATA[<p>文章来源：<a href="https://lessisbetter.site/2018/12/02/golang-exit-goroutine-in-3-ways/">Golang并发模型：并发协程的优雅退出</a><br>
goroutine作为Golang并发的核心，我们不仅要关注它们的创建和管理，当然还要关注如何合理的退出这些协程，不（合理）退出不然可能会造成阻塞、panic、程序行为异常、数据结果不正确等问题。这篇文章介绍，如何合理的退出goroutine，减少软件bug。</p>
<!-- more -->
<p>goroutine在退出方面，不像线程和进程，不能通过某种手段<strong>强制</strong>关闭它们，只能等待goroutine主动退出。但也无需为退出、关闭goroutine而烦恼，下面就介绍3种优雅退出goroutine的方法，只要采用这种最佳实践去设计，基本上就可以确保goroutine退出上不会有问题，尽情享用。</p>
<h3 id="1使用for-range退出">1：使用for-range退出</h3>
<p><code>for-range</code>是使用频率很高的结构，常用它来遍历数据，<strong><code>range</code>能够感知channel的关闭，当channel被发送数据的协程关闭时，range就会结束</strong>，接着退出for循环。</p>
<p>它在并发中的使用场景是：当协程只从1个channel读取数据，然后进行处理，处理后协程退出。下面这个示例程序，当in通道被关闭时，协程可自动退出。</p>
<pre><code>go func(in &lt;-chan int) {
    // Using for-range to exit goroutine
    // range has the ability to detect the close/end of a channel
    for x := range in {
        fmt.Printf(&quot;Process %d\n&quot;, x)
    }
}(inCh)
</code></pre>
<h3 id="2使用ok退出">2：使用,ok退出</h3>
<p><code>for-select</code>也是使用频率很高的结构，select提供了多路复用的能力，所以for-select可以让函数具有持续多路处理多个channel的能力。<strong>但select没有感知channel的关闭，这引出了2个问题</strong>：</p>
<ol>
<li>继续在关闭的通道上读，会读到通道传输数据类型的零值，如果是指针类型，读到nil，继续处理还会产生nil。</li>
<li>继续在关闭的通道上写，将会panic。</li>
</ol>
<p>问题2可以这样解决，通道只由发送方关闭，接收方不可关闭，即某个写通道只由使用该select的协程关闭，select中就不存在继续在关闭的通道上写数据的问题。</p>
<p>问题1可以使用<code>,ok</code>来检测通道的关闭，使用情况有2种。</p>
<p>第一种：<strong>如果某个通道关闭后，需要退出协程，直接return即可</strong>。示例代码中，该协程需要从in通道读数据，还需要定时打印已经处理的数量，有2件事要做，所有不能使用for-range，需要使用for-select，当in关闭时，<code>ok=false</code>，我们直接返回。</p>
<pre><code>go func() {
	// in for-select using ok to exit goroutine
	for {
		select {
		case x, ok := &lt;-in:
			if !ok {
				return
			}
			fmt.Printf(&quot;Process %d\n&quot;, x)
			processedCnt++
		case &lt;-t.C:
			fmt.Printf(&quot;Working, processedCnt = %d\n&quot;, processedCnt)
		}
	}
}()
</code></pre>
<p>第二种：如果<strong>某个通道关闭了，不再处理该通道，而是继续处理其他case</strong>，退出是等待所有的可读通道关闭。我们需要<strong>使用select的一个特征：select不会在nil的通道上进行等待</strong>。这种情况，把只读通道设置为nil即可解决。</p>
<pre><code>go func() {
	// in for-select using ok to exit goroutine
	for {
		select {
		case x, ok := &lt;-in1:
			if !ok {
				in1 = nil
			}
			// Process
		case y, ok := &lt;-in2:
			if !ok {
				in2 = nil
			}
			// Process
		case &lt;-t.C:
			fmt.Printf(&quot;Working, processedCnt = %d\n&quot;, processedCnt)
		}

		// If both in channel are closed, goroutine exit
		if in1 == nil &amp;&amp; in2 == nil {
			return
		}
	}
}()
</code></pre>
<h3 id="3使用退出通道退出">3：使用退出通道退出</h3>
<p><strong>使用<code>,ok</code>来退出使用for-select协程，解决是当读入数据的通道关闭时，没数据读时程序的正常结束</strong>。想想下面这2种场景，<code>,ok</code>还能适用吗？</p>
<ol>
<li>接收的协程要退出了，如果它直接退出，不告知发送协程，发送协程将阻塞。</li>
<li>启动了一个工作协程处理数据，如何通知它退出？</li>
</ol>
<p><strong>使用一个专门的通道，发送退出的信号，可以解决这类问题</strong>。以第2个场景为例，协程入参包含一个停止通道<code>stopCh</code>，当<code>stopCh</code>被关闭，<code>case &lt;-stopCh</code>会执行，直接返回即可。</p>
<p>当我启动了100个worker时，只要<code>main()</code>执行关闭stopCh，每一个worker都会都到信号，进而关闭。如果<code>main()</code>向stopCh发送100个数据，这种就低效了。</p>
<pre><code>func worker(stopCh &lt;-chan struct{}) {
	go func() {
		defer fmt.Println(&quot;worker exit&quot;)
		// Using stop channel explicit exit
		for {
			select {
			case &lt;-stopCh:
				fmt.Println(&quot;Recv stop signal&quot;)
				return
			case &lt;-t.C:
				fmt.Println(&quot;Working .&quot;)
			}
		}
	}()
	return
}
</code></pre>
<h3 id="最佳实践回顾">最佳实践回顾</h3>
<ol>
<li>发送协程主动关闭通道，接收协程不关闭通道。技巧：把接收方的通道入参声明为只读，如果接收协程关闭只读协程，编译时就会报错。</li>
<li>协程处理1个通道，并且是读时，协程优先使用<code>for-range</code>，因为<code>range</code>可以关闭通道的关闭自动退出协程。</li>
<li><code>,ok</code>可以处理多个读通道关闭，需要关闭当前使用<code>for-select</code>的协程。</li>
<li>显式关闭通道<code>stopCh</code>可以处理主动通知协程退出的场景。</li>
</ol>
<h3 id="完整示例代码">完整示例代码</h3>
<p>本文所有代码都在仓库，可查看完整示例代码：https://github.com/Shitaibin/golang_goroutine_exit</p>
<h3 id="并发系列文章推荐">并发系列文章推荐</h3>
<ul>
<li><a href="http://lessisbetter.site/2018/11/16/golang-introduction-to-pipeline/">Golang并发模型：轻松入门流水线模型</a></li>
<li><a href="http://lessisbetter.site/2018/11/28/golang-pipeline-fan-model/">Golang并发模型：轻松入门流水线FAN模式</a></li>
<li><a href="http://lessisbetter.site/2018/12/02/golang-exit-goroutine-in-3-ways/">Golang并发模型：并发协程的优雅退出</a></li>
</ul>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：http://lessisbetter.site/2018/12/02/golang-exit-goroutine-in-3-ways/</li>
</ol>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用Golang写爬虫(一)]]></title>
        <id>https://ChicRingo.github.io/post/yong-golang-xie-pa-chong-yi/</id>
        <link href="https://ChicRingo.github.io/post/yong-golang-xie-pa-chong-yi/">
        </link>
        <updated>2020-08-20T08:06:25.000Z</updated>
        <summary type="html"><![CDATA[<p>使用 Golang 对豆瓣爬虫</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用 Golang 对豆瓣爬虫</p>
<!-- more -->
<p>原文地址: <a href="https://link.zhihu.com/?target=https%3A//strconv.com/posts/web-crawler-exercise-1/">https://strconv.com/posts/web-crawler-exercise-1/</a></p>
<p>之前一直都是再用Python写爬虫，最近想体验下Golang写爬虫的感觉，所以就有了这个系列。我想要抓取的页面是<a href="https://link.zhihu.com/?target=https%3A//movie.douban.com/top250">豆瓣Top250页面</a>，选择它的理由有3个:</p>
<ol>
<li>豆瓣页面代码相对规范</li>
<li>豆瓣对爬虫爱好者相对更宽容</li>
<li>Top250页面简洁，很适合拿来练手</li>
</ol>
<p>我们先看第一版的代码。</p>
<p>按逻辑我把抓取代码分成2个部分：</p>
<ol>
<li>HTTP请求</li>
<li>解析页面中的内容</li>
</ol>
<p>我们先看HTTP请求，Golang语言的HTTP请求库不需要使用第三方的库，标准库就内置了足够好的支持：</p>
<pre><code class="language-go">import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;io/ioutil&quot;
)

func fetch (url string) string {
    fmt.Println(&quot;Fetch Url&quot;, url)
    client := &amp;http.Client{}
    req, _ := http.NewRequest(&quot;GET&quot;, url, nil)
    req.Header.Set(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)&quot;)
    resp, err := client.Do(req)
    if err != nil {
        fmt.Println(&quot;Http get err:&quot;, err)
        return &quot;&quot;
    }
    if resp.StatusCode != 200 {
        fmt.Println(&quot;Http status code:&quot;, resp.StatusCode)
        return &quot;&quot;
    }
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println(&quot;Read error&quot;, err)
        return &quot;&quot;
    }
    return string(body)
}
</code></pre>
<p>我把URL请求的逻辑都放在了fetch函数中，里面做了一些异常处理。值得说的有2点：</p>
<ol>
<li>在Header中设置了User-Agent，让访问看起来更像搜索引擎Bot。如果一个网站希望自己的内容被Google收录那么他就不会拒绝这样的UA的访问。</li>
<li>需要通过ioutil.ReadAll 读取resp的body内容，最后用string(body)把它转化成字符串</li>
</ol>
<p>接着就是解析页面的部分：</p>
<pre><code class="language-go">import (
    &quot;regexp&quot;
    &quot;strings&quot;
)

func parseUrls(url string) {
    body := fetch(url)
    body = strings.Replace(body, &quot;\n&quot;, &quot;&quot;, -1)
    rp := regexp.MustCompile(`&lt;div class=&quot;hd&quot;&gt;(.*?)&lt;/div&gt;`)
    titleRe := regexp.MustCompile(`&lt;span class=&quot;title&quot;&gt;(.*?)&lt;/span&gt;`)
    idRe := regexp.MustCompile(`&lt;a href=&quot;https://movie.douban.com/subject/(\d+)/&quot;`)
    items := rp.FindAllStringSubmatch(body, -1)
    for _, item := range items {
        fmt.Println(idRe.FindStringSubmatch(item[1])[1],
            titleRe.FindStringSubmatch(item[1])[1])
    }
}
</code></pre>
<p>这篇文章我们主要体验用标准库完成页面的解析，也就是用正则表达式包regexp来完成。不过要注意需要用<code>strings.Replace(body, &quot;\n&quot;, &quot;&quot;, -1)</code>这步把body内容中的回车符去掉，要不然下面的正则表达式<code>.*</code>就不符合了。<code>FindAllStringSubmatch</code>方法会把符合正则表达式的结果都解析出来（一个列表），而<code>FindStringSubmatch</code>是找第一个符合的结果。</p>
<p>Top250页面是要翻页的，最后在main函数里面实现抓取全部Top250页面。另外为了和之后的改进做对比，我们加上代码运行耗时的逻辑：</p>
<pre><code class="language-go">import (
       &quot;time&quot;
       &quot;strconv&quot;
)
func main() {
        start := time.Now()
        for i := 0; i &lt; 10; i++ {
                parseUrls(&quot;https://movie.douban.com/top250?start=&quot; + strconv.Itoa(25 * i))
        }
        elapsed := time.Since(start)
        fmt.Printf(&quot;Took %s&quot;, elapsed)
}
</code></pre>
<p>在Golang中把数字转成字符串需要使用<code>strconv.Itoa</code>（嘿嘿，本博客域名就是这个模块），这样就可以根据start的参数的不通拼出正确的页面路径。用一个for循环完成翻页。</p>
<p>运行起来非常快：</p>
<pre><code class="language-bash">❯ go run crawler/doubanCrawler1.go
... # 省略输出
Took 1.454627547s
</code></pre>
<p>通过终端输出可以看到我们拿到了对应电影条目的ID和电影标题！</p>
<h3 id="代码地址">代码地址</h3>
<p>完整代码可以在<a href="https://link.zhihu.com/?target=https%3A//github.com/golang-dev/strconv.code/blob/master/crawler/doubanCrawler1.go">这个地址</a>找到。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 Go 中恰到好处的内存对齐]]></title>
        <id>https://ChicRingo.github.io/post/zai-go-zhong-qia-dao-hao-chu-de-nei-cun-dui-qi/</id>
        <link href="https://ChicRingo.github.io/post/zai-go-zhong-qia-dao-hao-chu-de-nei-cun-dui-qi/">
        </link>
        <updated>2020-08-20T02:41:41.000Z</updated>
        <summary type="html"><![CDATA[<p>在Golang中对结构体成员进行内存对齐，以此保证内存的访问边界，并可以优化内存占用</p>
]]></summary>
        <content type="html"><![CDATA[<p>在Golang中对结构体成员进行内存对齐，以此保证内存的访问边界，并可以优化内存占用</p>
<!-- more -->
<p>原文地址：<a href="https://eddycjy.com/posts/go/talk/2018-12-26-go-memory-align/">在 Go 中恰到好处的内存对齐</a></p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2020/02/27/3wuT0A.png" alt="image" loading="lazy"></figure>
<h2 id="问题">问题</h2>
<pre><code class="language-go">type Part1 struct {
	a bool
	b int32
	c int8
	d int64
	e byte
}
</code></pre>
<p>在开始之前，希望你计算一下 <code>Part1</code> 共占用的大小是多少呢？</p>
<pre><code class="language-go">func main() {
	fmt.Printf(&quot;bool size: %d\n&quot;, unsafe.Sizeof(bool(true)))
	fmt.Printf(&quot;int32 size: %d\n&quot;, unsafe.Sizeof(int32(0)))
	fmt.Printf(&quot;int8 size: %d\n&quot;, unsafe.Sizeof(int8(0)))
	fmt.Printf(&quot;int64 size: %d\n&quot;, unsafe.Sizeof(int64(0)))
	fmt.Printf(&quot;byte size: %d\n&quot;, unsafe.Sizeof(byte(0)))
	fmt.Printf(&quot;string size: %d\n&quot;, unsafe.Sizeof(&quot;EDDYCJY&quot;))
}
</code></pre>
<p>输出结果：</p>
<pre><code>bool size: 1
int32 size: 4
int8 size: 1
int64 size: 8
byte size: 1
string size: 16
</code></pre>
<p>这么一算，<code>Part1</code> 这一个结构体的占用内存大小为 1+4+1+8+1 = 15 个字节。相信有的小伙伴是这么算的，看上去也没什么毛病</p>
<p>真实情况是怎么样的呢？我们实际调用看看，如下：</p>
<pre><code class="language-go">type Part1 struct {
	a bool
	b int32
	c int8
	d int64
	e byte
}

func main() {
	part1 := Part1{}

	fmt.Printf(&quot;part1 size: %d, align: %d\n&quot;, unsafe.Sizeof(part1), unsafe.Alignof(part1))
}
</code></pre>
<p>输出结果：</p>
<pre><code>part1 size: 32, align: 8
</code></pre>
<p>最终输出为占用 32 个字节。这与前面所预期的结果完全不一样。这充分地说明了先前的计算方式是错误的。为什么呢？</p>
<p>在这里要提到 “内存对齐” 这一概念，才能够用正确的姿势去计算，接下来我们详细的讲讲它是什么</p>
<h2 id="内存对齐">内存对齐</h2>
<p>有的小伙伴可能会认为内存读取，就是一个简单的字节数组摆放</p>
<figure data-type="image" tabindex="2"><img src="https://s2.ax1x.com/2020/02/27/3wuLff.png" alt="image" loading="lazy"></figure>
<p>上图表示一个坑一个萝卜的内存读取方式。但实际上 CPU 并不会以一个一个字节去读取和写入内存。相反 CPU 读取内存是<strong>一块一块读取</strong>的，块的大小可以为 2、4、6、8、16 字节等大小。块大小我们称其为<strong>内存访问粒度</strong>。如下图：</p>
<figure data-type="image" tabindex="3"><img src="https://s2.ax1x.com/2020/02/27/3wKSmj.png" alt="image" loading="lazy"></figure>
<p>在样例中，假设访问粒度为 4。 CPU 是以每 4 个字节大小的访问粒度去读取和写入内存的。这才是正确的姿势</p>
<h3 id="为什么要关心对齐">为什么要关心对齐</h3>
<ul>
<li>你正在编写的代码在性能（CPU、Memory）方面有一定的要求</li>
<li>你正在处理向量方面的指令</li>
<li>某些硬件平台（ARM）体系不支持未对齐的内存访问</li>
</ul>
<p>另外作为一个工程师，你也很有必要学习这块知识点哦 😃</p>
<h3 id="为什么要做对齐">为什么要做对齐</h3>
<ul>
<li>平台（移植性）原因：不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况</li>
<li>性能原因：若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://s2.ax1x.com/2020/02/27/3wKApT.png" alt="image" loading="lazy"></figure>
<p>在上图中，假设从 Index 1 开始读取，将会出现很崩溃的问题。因为它的内存访问边界是不对齐的。因此 CPU 会做一些额外的处理工作。如下：</p>
<ol>
<li>CPU <strong>首次</strong>读取未对齐地址的第一个内存块，读取 0-3 字节。并移除不需要的字节 0</li>
<li>CPU <strong>再次</strong>读取未对齐地址的第二个内存块，读取 4-7 字节。并移除不需要的字节 5、6、7 字节</li>
<li>合并 1-4 字节的数据</li>
<li>合并后放入寄存器</li>
</ol>
<p>从上述流程可得出，不做 “内存对齐” 是一件有点 “麻烦” 的事。因为它会增加许多耗费时间的动作</p>
<p>而假设做了内存对齐，从 Index 0 开始读取 4 个字节，只需要读取一次，也不需要额外的运算。这显然高效很多，是标准的<strong>空间换时间</strong>做法</p>
<h3 id="默认系数">默认系数</h3>
<p>在不同平台上的编译器都有自己默认的 “对齐系数”，可通过预编译命令 <code>#pragma pack(n)</code> 进行变更，n 就是代指 “对齐系数”。一般来讲，我们常用的平台的系数如下：</p>
<ul>
<li>32 位：4</li>
<li>64 位：8</li>
</ul>
<p>另外要注意，不同硬件平台占用的大小和对齐值都可能是不一样的。因此本文的值不是唯一的，调试的时候需按本机的实际情况考虑</p>
<h3 id="成员对齐">成员对齐</h3>
<pre><code class="language-go">func main() {
	fmt.Printf(&quot;bool align: %d\n&quot;, unsafe.Alignof(bool(true)))
	fmt.Printf(&quot;int32 align: %d\n&quot;, unsafe.Alignof(int32(0)))
	fmt.Printf(&quot;int8 align: %d\n&quot;, unsafe.Alignof(int8(0)))
	fmt.Printf(&quot;int64 align: %d\n&quot;, unsafe.Alignof(int64(0)))
	fmt.Printf(&quot;byte align: %d\n&quot;, unsafe.Alignof(byte(0)))
	fmt.Printf(&quot;string align: %d\n&quot;, unsafe.Alignof(&quot;EDDYCJY&quot;))
	fmt.Printf(&quot;map align: %d\n&quot;, unsafe.Alignof(map[string]string{}))
}
</code></pre>
<p>输出结果：</p>
<pre><code>bool align: 1
int32 align: 4
int8 align: 1
int64 align: 8
byte align: 1
string align: 8
map align: 8
</code></pre>
<p>在 Go 中可以调用 <code>unsafe.Alignof</code> 来返回相应类型的对齐系数。通过观察输出结果，可得知基本都是 <code>2^n</code>，最大也不会超过 8。这是因为我手提（64 位）编译器默认对齐系数是 8，因此最大值不会超过这个数</p>
<h3 id="整体对齐">整体对齐</h3>
<p>在上小节中，提到了结构体中的成员变量要做字节对齐。那么想当然身为最终结果的结构体，也是需要做字节对齐的</p>
<h3 id="对齐规则">对齐规则</h3>
<ul>
<li>结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>当前成员变量类型的长度</strong>（<code>unsafe.Sizeof</code>），取<strong>最小值作为当前类型的对齐值</strong>。其偏移量必须为对齐值的整数倍</li>
<li>结构体本身，对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>结构体的所有成员变量类型中的最大长度</strong>，取<strong>最大数的最小整数倍</strong>作为对齐值</li>
<li>结合以上两点，可得知若<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的</li>
</ul>
<h2 id="分析流程">分析流程</h2>
<p>接下来我们一起分析一下，“它” 到底经历了些什么，影响了 “预期” 结果</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>类型</th>
<th>偏移量</th>
<th>自身占用</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>bool</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>b</td>
<td>int32</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>c</td>
<td>int8</td>
<td>8</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>9</td>
<td>7</td>
</tr>
<tr>
<td>d</td>
<td>int64</td>
<td>16</td>
<td>8</td>
</tr>
<tr>
<td>e</td>
<td>byte</td>
<td>24</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>25</td>
<td>7</td>
</tr>
<tr>
<td>总占用大小</td>
<td>-</td>
<td>-</td>
<td>32</td>
</tr>
</tbody>
</table>
<h3 id="成员对齐-2">成员对齐</h3>
<ul>
<li>第一个成员 a
<ul>
<li>类型为 bool</li>
<li>大小/对齐值为 1 字节</li>
<li>初始地址，偏移量为 0。占用了第 1 位</li>
</ul>
</li>
<li>第二个成员 b
<ul>
<li>类型为 int32</li>
<li>大小/对齐值为 4 字节</li>
<li>根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此 2-4 位为 Padding。而当前数值从第 5 位开始填充，到第 8 位。如下：axxx|bbbb</li>
</ul>
</li>
<li>第三个成员 c
<ul>
<li>类型为 int8</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 8。不需要额外对齐，填充 1 个字节到第 9 位。如下：axxx|bbbb|c…</li>
</ul>
</li>
<li>第四个成员 d
<ul>
<li>类型为 int64</li>
<li>大小/对齐值为 8 字节</li>
<li>根据规则 1，其偏移量必须为 8 的整数倍。确定偏移量为 16，因此 9-16 位为 Padding。而当前数值从第 17 位开始写入，到第 24 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd</li>
</ul>
</li>
<li>第五个成员 e
<ul>
<li>类型为 byte</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 24。不需要额外对齐，填充 1 个字节到第 25 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd|e…</li>
</ul>
</li>
</ul>
<h3 id="整体对齐-2">整体对齐</h3>
<p>在每个成员变量进行对齐后，根据规则 2，整个结构体本身也要进行字节对齐，因为可发现它可能并不是 <code>2^n</code>，不是偶数倍。显然不符合对齐的规则</p>
<p>根据规则 2，可得出对齐值为 8。现在的偏移量为 25，不是 8 的整倍数。因此确定偏移量为 32。对结构体进行对齐</p>
<h3 id="结果">结果</h3>
<p>Part1 内存布局：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</p>
<h3 id="小结">小结</h3>
<p>通过本节的分析，可得知先前的 “推算” 为什么错误？</p>
<p>是因为实际内存管理并非 “一个萝卜一个坑” 的思想。而是一块一块。通过空间换时间（效率）的思想来完成这块读取、写入。另外也需要兼顾不同平台的内存操作情况</p>
<h2 id="巧妙的结构体">巧妙的结构体</h2>
<p>在上一小节，可得知根据成员变量的类型不同，其结构体的内存会产生对齐等动作。那假设字段顺序不同，会不会有什么变化呢？我们一起来试试吧 😃</p>
<pre><code class="language-go">type Part1 struct {
	a bool
	b int32
	c int8
	d int64
	e byte
}

type Part2 struct {
	e byte
	c int8
	a bool
	b int32
	d int64
}

func main() {
	part1 := Part1{}
	part2 := Part2{}

	fmt.Printf(&quot;part1 size: %d, align: %d\n&quot;, unsafe.Sizeof(part1), unsafe.Alignof(part1))
	fmt.Printf(&quot;part2 size: %d, align: %d\n&quot;, unsafe.Sizeof(part2), unsafe.Alignof(part2))
}
</code></pre>
<p>输出结果：</p>
<pre><code>part1 size: 32, align: 8
part2 size: 16, align: 8
</code></pre>
<p>通过结果可以惊喜的发现，只是 “简单” 对成员变量的字段顺序进行改变，就改变了结构体占用大小</p>
<p>接下来我们一起剖析一下 <code>Part2</code>，看看它的内部到底和上一位之间有什么区别，才导致了这样的结果？</p>
<h3 id="分析流程-2">分析流程</h3>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>类型</th>
<th>偏移量</th>
<th>自身占用</th>
</tr>
</thead>
<tbody>
<tr>
<td>e</td>
<td>byte</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>c</td>
<td>int8</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>a</td>
<td>bool</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>b</td>
<td>int32</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>d</td>
<td>int64</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>总占用大小</td>
<td>-</td>
<td>-</td>
<td>16</td>
</tr>
</tbody>
</table>
<h4 id="成员对齐-3">成员对齐</h4>
<ul>
<li>第一个成员 e
<ul>
<li>类型为 byte</li>
<li>大小/对齐值为 1 字节</li>
<li>初始地址，偏移量为 0。占用了第 1 位</li>
</ul>
</li>
<li>第二个成员 c
<ul>
<li>类型为 int8</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 2。不需要额外对齐</li>
</ul>
</li>
<li>第三个成员 a
<ul>
<li>类型为 bool</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 3。不需要额外对齐</li>
</ul>
</li>
<li>第四个成员 b
<ul>
<li>类型为 int32</li>
<li>大小/对齐值为 4 字节</li>
<li>根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此第 3 位为 Padding。而当前数值从第 4 位开始填充，到第 8 位。如下：ecax|bbbb</li>
</ul>
</li>
<li>第五个成员 d
<ul>
<li>类型为 int64</li>
<li>大小/对齐值为 8 字节</li>
<li>根据规则 1，其偏移量必须为 8 的整数倍。当前偏移量为 8。不需要额外对齐，从 9-16 位填充 8 个字节。如下：ecax|bbbb|dddd|dddd</li>
</ul>
</li>
</ul>
<h4 id="整体对齐-3">整体对齐</h4>
<p>符合规则 2，不需要额外对齐</p>
<h4 id="结果-2">结果</h4>
<p>Part2 内存布局：ecax|bbbb|dddd|dddd</p>
<h2 id="总结">总结</h2>
<p>通过对比 <code>Part1</code> 和 <code>Part2</code> 的内存布局，你会发现两者有很大的不同。如下：</p>
<ul>
<li>Part1：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</li>
<li>Part2：ecax|bbbb|dddd|dddd</li>
</ul>
<p>仔细一看，<code>Part1</code> 存在许多 Padding。显然它占据了不少空间，那么 Padding 是怎么出现的呢？</p>
<p>通过本文的介绍，可得知是由于不同类型导致需要进行字节对齐，以此保证内存的访问边界</p>
<p>那么也不难理解，为什么<strong>调整结构体内成员变量的字段顺序</strong>就能达到缩小结构体占用大小的疑问了，是因为巧妙地减少了 Padding 的存在。让它们更 “紧凑” 了。这一点对于加深 Go 的内存布局印象和大对象的优化非常有帮</p>
<p>当然了，没什么特殊问题，你可以不关注这一块。但你要知道这块知识点 😄</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Data structure alignment</a></li>
<li><a href="https://www.ibm.com/developerworks/library/pa-dalign/">Data alignment</a></li>
</ul>
]]></content>
    </entry>
</feed>