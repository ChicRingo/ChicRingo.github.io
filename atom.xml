<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ChicRingo.github.io</id>
    <title>ChicRingo个人博客</title>
    <updated>2020-08-25T01:03:06.673Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ChicRingo.github.io"/>
    <link rel="self" href="https://ChicRingo.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ChicRingo.github.io/images/avatar.png</logo>
    <icon>https://ChicRingo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ChicRingo个人博客</rights>
    <entry>
        <title type="html"><![CDATA[我擦~字符串转字节切片后，切片的容量竟然千奇百怪]]></title>
        <id>https://ChicRingo.github.io/post/wo-ca-~zi-fu-chuan-zhuan-zi-jie-qie-pian-hou-qie-pian-de-rong-liang-jing-ran-qian-qi-bai-guai/</id>
        <link href="https://ChicRingo.github.io/post/wo-ca-~zi-fu-chuan-zhuan-zi-jie-qie-pian-hou-qie-pian-de-rong-liang-jing-ran-qian-qi-bai-guai/">
        </link>
        <updated>2020-08-25T00:56:36.000Z</updated>
        <summary type="html"><![CDATA[<p>字符串转字节切片步骤如下</p>
<ol>
<li>
<p>判断是否是常量， 如果是常量则转换为等容量等长的字节切片</p>
</li>
<li>
<p>如果是变量， 先判断生成的切片是否发生变量逃逸</p>
</li>
<li>
<ul>
<li>如果逃逸或者字符串长度&gt;32， 则根据字符串长度可以计算出不同的容量</li>
<li>如果未逃逸且字符串长度&lt;=32, 则字符切片容量为32</li>
</ul>
</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<p>字符串转字节切片步骤如下</p>
<ol>
<li>
<p>判断是否是常量， 如果是常量则转换为等容量等长的字节切片</p>
</li>
<li>
<p>如果是变量， 先判断生成的切片是否发生变量逃逸</p>
</li>
<li>
<ul>
<li>如果逃逸或者字符串长度&gt;32， 则根据字符串长度可以计算出不同的容量</li>
<li>如果未逃逸且字符串长度&lt;=32, 则字符切片容量为32</li>
</ul>
</li>
</ol>
<!-- more -->
<p>以下文章来源于新世界杂货铺 ，作者许文</p>
<p><a href="https://baijiahao.baidu.com/s?id=1671902920320901161"><strong>新世界杂货铺</strong>作为一名Gopher， 我愿称之为Go的干(杂)货铺子！</a></p>
<p>神奇的现象</p>
<p>切片， 切片， 又是切片!</p>
<p>今天遇到的神奇问题和切片有关， 具体怎么个神奇法， 我们来看看下面几个现象</p>
<h3 id="现象一">现象一</h3>
<pre><code>a := &quot;abc&quot;
bs := []byte(a)
fmt.Println(bs, len(bs), cap(bs))
// 输出： [97 98 99] 3 8
</code></pre>
<h3 id="现象二">现象二</h3>
<pre><code>a := &quot;abc&quot;
bs := []byte(a)
fmt.Println(len(bs), cap(bs))
// 输出: 3 32
</code></pre>
<h3 id="现象三">现象三</h3>
<pre><code>bs := []byte(&quot;abc&quot;)
fmt.Println(len(bs), cap(bs))
// 输出: 3 3
</code></pre>
<h3 id="现象四">现象四</h3>
<pre><code>a := &quot;&quot;
bs := []byte(a)
fmt.Println(bs, len(bs), cap(bs))
// 输出: [] 0 0
</code></pre>
<h3 id="现象五">现象五</h3>
<pre><code>a := &quot;&quot;
bs := []byte(a)
fmt.Println(len(bs), cap(bs))
// 输出: 0 32
</code></pre>
<h2 id="分析">分析</h2>
<p>到这儿我已经满脑子问号了</p>
<figure data-type="image" tabindex="1"><img src="https://mmbiz.qpic.cn/mmbiz_jpg/JTbQwON6HwLCaWz0ZWL9fG6r4Tb8bRCNIgpKYm1jhPB3fbuxia13qrFQvHdsT9fa6voJicXvD5SHe6c1jDXKngNw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" loading="lazy"></figure>
<h3 id="字符串变量转切片">字符串变量转切片</h3>
<p>一个小小的字符串转切片， 内部究竟发生了什么， 竟然如此的神奇。这种时候只好祭出汇编大法， 看看汇编代码(<code>希望之后有机会能够对go的汇编语法进行简单的介绍</code>)有没有什么关键词能够帮助我们</p>
<p>以下为现象一转换的汇编代码关键部分</p>
<pre><code>&quot;&quot;.main STEXT size=495 args=0x0 locals=0xd8
	0x0000 00000 (test.go:5)	TEXT	&quot;&quot;.main(SB), ABIInternal, $216-0
	0x0000 00000 (test.go:5)	MOVQ	(TLS), CX
	0x0009 00009 (test.go:5)	LEAQ	-88(SP), AX
	0x000e 00014 (test.go:5)	CMPQ	AX, 16(CX)
	0x0012 00018 (test.go:5)	JLS	485
	0x0018 00024 (test.go:5)	SUBQ	$216, SP
	0x001f 00031 (test.go:5)	MOVQ	BP, 208(SP)
	0x0027 00039 (test.go:5)	LEAQ	208(SP), BP
	0x002f 00047 (test.go:5)	FUNCDATA	$0, gclocals·7be4bbacbfdb05fb3044e36c22b41e8b(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$1, gclocals·648d0b72bb9d7f59fbfdbee57a078eee(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$2, gclocals·2dfddcc7190380b1ae77e69d81f0a101(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$3, &quot;&quot;.main.stkobj(SB)
	0x002f 00047 (test.go:6)	PCDATA	$0, $1
	0x002f 00047 (test.go:6)	PCDATA	$1, $0
	0x002f 00047 (test.go:6)	LEAQ	go.string.&quot;abc&quot;(SB), AX
	0x0036 00054 (test.go:6)	MOVQ	AX, &quot;&quot;.a+96(SP)
	0x003b 00059 (test.go:6)	MOVQ	$3, &quot;&quot;.a+104(SP)
	0x0044 00068 (test.go:7)	MOVQ	$0, (SP)
	0x004c 00076 (test.go:7)	PCDATA	$0, $0
	0x004c 00076 (test.go:7)	MOVQ	AX, 8(SP)
	0x0051 00081 (test.go:7)	MOVQ	$3, 16(SP)
	0x005a 00090 (test.go:7)	CALL	runtime.stringtoslicebyte(SB)
	0x005f 00095 (test.go:7)	MOVQ	40(SP), AX
	0x0064 00100 (test.go:7)	MOVQ	32(SP), CX
	0x0069 00105 (test.go:7)	PCDATA	$0, $2
	0x0069 00105 (test.go:7)	MOVQ	24(SP), DX
	0x006e 00110 (test.go:7)	PCDATA	$0, $0
	0x006e 00110 (test.go:7)	PCDATA	$1, $1
	0x006e 00110 (test.go:7)	MOVQ	DX, &quot;&quot;.bs+112(SP)
	0x0073 00115 (test.go:7)	MOVQ	CX, &quot;&quot;.bs+120(SP)
	0x0078 00120 (test.go:7)	MOVQ	AX, &quot;&quot;.bs+128(SP)
</code></pre>
<p>以下为现象二转换的汇编代码关键部分</p>
<pre><code>&quot;&quot;.main STEXT size=393 args=0x0 locals=0xe0
	0x0000 00000 (test.go:5)	TEXT	&quot;&quot;.main(SB), ABIInternal, $224-0
	0x0000 00000 (test.go:5)	MOVQ	(TLS), CX
	0x0009 00009 (test.go:5)	LEAQ	-96(SP), AX
	0x000e 00014 (test.go:5)	CMPQ	AX, 16(CX)
	0x0012 00018 (test.go:5)	JLS	383
	0x0018 00024 (test.go:5)	SUBQ	$224, SP
	0x001f 00031 (test.go:5)	MOVQ	BP, 216(SP)
	0x0027 00039 (test.go:5)	LEAQ	216(SP), BP
	0x002f 00047 (test.go:5)	FUNCDATA	$0, gclocals·0ce64bbc7cfa5ef04d41c861de81a3d7(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$1, gclocals·00590b99cfcd6d71bbbc6e05cb4f8bf8(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$2, gclocals·8dcadbff7c52509cfe2d26e4d7d24689(SB)
	0x002f 00047 (test.go:5)	FUNCDATA	$3, &quot;&quot;.main.stkobj(SB)
	0x002f 00047 (test.go:6)	PCDATA	$0, $1
	0x002f 00047 (test.go:6)	PCDATA	$1, $0
	0x002f 00047 (test.go:6)	LEAQ	go.string.&quot;abc&quot;(SB), AX
	0x0036 00054 (test.go:6)	MOVQ	AX, &quot;&quot;.a+120(SP)
	0x003b 00059 (test.go:6)	MOVQ	$3, &quot;&quot;.a+128(SP)
	0x0047 00071 (test.go:7)	PCDATA	$0, $2
	0x0047 00071 (test.go:7)	LEAQ	&quot;&quot;..autotmp_5+64(SP), CX
	0x004c 00076 (test.go:7)	PCDATA	$0, $1
	0x004c 00076 (test.go:7)	MOVQ	CX, (SP)
	0x0050 00080 (test.go:7)	PCDATA	$0, $0
	0x0050 00080 (test.go:7)	MOVQ	AX, 8(SP)
	0x0055 00085 (test.go:7)	MOVQ	$3, 16(SP)
	0x005e 00094 (test.go:7)	CALL	runtime.stringtoslicebyte(SB)
	0x0063 00099 (test.go:7)	MOVQ	40(SP), AX
	0x0068 00104 (test.go:7)	MOVQ	32(SP), CX
	0x006d 00109 (test.go:7)	PCDATA	$0, $3
	0x006d 00109 (test.go:7)	MOVQ	24(SP), DX
	0x0072 00114 (test.go:7)	PCDATA	$0, $0
	0x0072 00114 (test.go:7)	PCDATA	$1, $1
	0x0072 00114 (test.go:7)	MOVQ	DX, &quot;&quot;.bs+136(SP)
	0x007a 00122 (test.go:7)	MOVQ	CX, &quot;&quot;.bs+144(SP)
	0x0082 00130 (test.go:7)	MOVQ	AX, &quot;&quot;.bs+152(SP)
</code></pre>
<p>在看汇编代码之前， 我们首先来看一看<code>runtime.stringtoslicebyte</code>的函数签名</p>
<pre><code>func stringtoslicebyte(buf *tmpBuf, s string) []byte
</code></pre>
<p>到这里只靠关键词已经无法看出更多的信息了,还是需要稍微了解一下汇编的语法,笔者在这里列出一点简单的分析， 之后我们还是可以通过取巧的方法发现更多的东西</p>
<pre><code>// 现象一给runtime.stringtoslicebyte的传参
0x002f 00047 (test.go:6)	LEAQ	go.string.&quot;abc&quot;(SB), AX // 将字符串&quot;abc&quot;放入寄存器AX
0x0036 00054 (test.go:6)	MOVQ	AX, &quot;&quot;.a+96(SP) // 将AX中的内容存入变量a中
0x003b 00059 (test.go:6)	MOVQ	$3, &quot;&quot;.a+104(SP) // 将字符串长度3存入变量a中
0x0044 00068 (test.go:7)	MOVQ	$0, (SP) // 将0 传递个runtime.stringtoslicebyte(SB)的第一个参数(笔者猜测对应go中的nil)
0x004c 00076 (test.go:7)	PCDATA	$0, $0 // 据说和gc有关， 具体还不清楚， 一般情况可以忽略
0x004c 00076 (test.go:7)	MOVQ	AX, 8(SP) // 将AX中的内容传递给runtime.stringtoslicebyte(SB)的第二个参数
0x0051 00081 (test.go:7)	MOVQ	$3, 16(SP) // 将字符串长度传递给runtime.stringtoslicebyte(SB)的第二个参数
0x005a 00090 (test.go:7)	CALL	runtime.stringtoslicebyte(SB) // 调用函数， 此行后面的几行代码是将返回值赋值给变量bs

// 现象二给runtime.stringtoslicebyte的传参
0x002f 00047 (test.go:6)	LEAQ	go.string.&quot;abc&quot;(SB), AX // 将字符串&quot;abc&quot;放入寄存器AX
0x0036 00054 (test.go:6)	MOVQ	AX, &quot;&quot;.a+120(SP) // 将AX中的内容存入变量a中
0x003b 00059 (test.go:6)	MOVQ	$3, &quot;&quot;.a+128(SP) // 将字符串长度3存入变量a中
0x0047 00071 (test.go:7)	PCDATA	$0, $2
0x0047 00071 (test.go:7)	LEAQ	&quot;&quot;..autotmp_5+64(SP), CX // 将内部变量autotmp_5放入寄存器CX
0x004c 00076 (test.go:7)	PCDATA	$0, $1
0x004c 00076 (test.go:7)	MOVQ	CX, (SP) // 将CX中的内容传递给runtime.stringtoslicebyte(SB)的第一个参数
0x0050 00080 (test.go:7)	PCDATA	$0, $0
0x0050 00080 (test.go:7)	MOVQ	AX, 8(SP) // 将AX中的内容传递给runtime.stringtoslicebyte(SB)的第二个参数
0x0055 00085 (test.go:7)	MOVQ	$3, 16(SP) // 将字符串长度传递给runtime.stringtoslicebyte(SB)的第二个参数
0x005e 00094 (test.go:7)	CALL	runtime.stringtoslicebyte(SB)
</code></pre>
<p>通过上面汇编代码的分析可以知道，现象一和现象二的区别就是传递给<code>runtime.stringtoslicebyte</code>的第一个参数不同。通过对runtime包中<code>stringtoslicebyte</code>函数分析，第一个参数是否有值和字符串长度会影响代码执行的分支，从而生成不同的切片， 因此容量不一样也是常理之中， 下面我们看源码</p>
<pre><code>func stringtoslicebyte(buf *tmpBuf, s string) []byte {
	var b []byte
	if buf != nil &amp;&amp; len(s) &lt;= len(buf) {
		*buf = tmpBuf{}
		b = buf[:len(s)]
	} else {
		b = rawbyteslice(len(s))
	}
	copy(b, s)
	return b
}
</code></pre>
<p>然而， stringtoslicebyte的第一个参数什么情况下才会有值，什么情况下为nil, 我们仍然不清楚。那怎么办呢， 只好祭出全局搜索大法：</p>
<pre><code># 在go源码根目录执行下面的命令
grep stringtoslicebyte -r . | grep -v &quot;//&quot;
</code></pre>
<p>最终在go的编译器源码cmd/compile/internal/gc/walk.go发现了如下代码块</p>
<figure data-type="image" tabindex="2"><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" loading="lazy"></figure>
<p>我们查看<code>mkcall</code> 函数签名可以知道, 从第四个参数开始的所有变量都会作为参数传递给第一个参数对应的函数， 最后生成一个<code>*Node</code>的变量。其中Node结构体解释如下:</p>
<pre><code>// A Node is a single node in the syntax tree.
// Actually the syntax tree is a syntax DAG, because there is only one
// node with Op=ONAME for a given instance of a variable x.
// The same is true for Op=OTYPE and Op=OLITERAL. See Node.mayBeShared.
</code></pre>
<p>综合上述信息我们得出的结论是，编译器会对stringtoslicebyte的函数调用生成一个AST(抽象语法树)对应的节点。因此我们也知道传递给stringtoslicebyte函数的第一个变量也就对应于上图中的变量a.</p>
<p>其中a的初始值为<code>nodnil()</code>的返回值，即默认为<code>nil</code>. 但是<code>n.Esc == EscNone</code>时，a会变成一个数组。我们看一下EscNone的解释.</p>
<pre><code>// 此代码位于cmd/compile/internal/gc/esc.go中
const (
	// ...
	EscNone           // Does not escape to heap, result, or parameters.
    ...
)
</code></pre>
<p>由上可知, <code>EscNone</code>用来判断变量是否逃逸,到这儿了我们就很好办了，接下来我们对现象一和现象二的代码进行逃逸分析.</p>
<pre><code># 执行变量逃逸分析命令: go run -gcflags '-m -l' test.go
# 现象一逃逸分析如下：
./test.go:7:14: ([]byte)(a) escapes to heap
./test.go:8:13: main ... argument does not escape
./test.go:8:13: bs escapes to heap
./test.go:8:21: len(bs) escapes to heap
./test.go:8:30: cap(bs) escapes to heap
[97 98 99] 3 8
# 现象二逃逸分析如下：
./test.go:7:14: main ([]byte)(a) does not escape
./test.go:8:13: main ... argument does not escape
./test.go:8:17: len(bs) escapes to heap
./test.go:8:26: cap(bs) escapes to heap
3 32
</code></pre>
<p>根据上面的信息我们知道在现象一中，bs变量发生了逃逸，现象二中变量未发生逃逸，也就是说stringtoslicebyte函数的第一个参数在变量未发生逃逸时其值不为nil,变量发生逃逸时其值为nil。到这里我们已经搞明白stringtoslicebyte的第一个参数了， 那我们继续分析stringtoslicebyte的内部逻辑</p>
<p>我们在runtime/string.go中看到stringtoslicebyte第一个参数的类型定义如下：</p>
<pre><code>const tmpStringBufSize = 32

type tmpBuf [tmpStringBufSize]byte
</code></pre>
<p>综上: 现象二中bs变量未发生变量逃逸, stringtoslicebyte第一个参数不为空且是一个长度为32的byte数组, 因此在现象二中生成了一个容量为32的切片</p>
<p>根据对stringtoslicebyte的源码分析， 我们知道现象一调用了<code>rawbyteslice</code>函数</p>
<pre><code>func rawbyteslice(size int) (b []byte) {
	cap := roundupsize(uintptr(size))
	p := mallocgc(cap, nil, false)
	if cap != uintptr(size) {
		memclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size))
	}

	*(*slice)(unsafe.Pointer(&amp;b)) = slice{p, size, int(cap)}
	return
}
</code></pre>
<p>由上面的代码知道， 切片的容量通过runtime/msize.go中的<code>roundupsize</code>函数计算得出, 其中_MaxSmallSize和class_to_size均定义在runtime/sizeclasses.go</p>
<pre><code>func roundupsize(size uintptr) uintptr {
	if size &lt; _MaxSmallSize {
		if size &lt;= smallSizeMax-8 {
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
		} else {
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
		}
	}
	if size+_PageSize &lt; size {
		return size
	}
	return round(size, _PageSize)
}
</code></pre>
<p>由于字符串abc的长度小于_MaxSmallSize(32768)，故切片的长度只能取数组class_to_size中的值， 即<code>0, 8, 16, 32, 48, 64, 80, 96, 112, 128....</code>s</p>
<p>至此, 现象一中切片容量为什么为8也真相大白了。相信到这里很多人已经明白现象四和现象五是怎么回事儿了, 其逻辑分别与现象一和现象二是一致的， 有兴趣的， 可以在自己的电脑上面试一试。</p>
<h3 id="字符串直接转切片">字符串直接转切片</h3>
<p>那你说了这么多， 现象三还是不能解释啊。请各位看官莫急， 接下来我们继续分析。</p>
<p>相信各位细心的小伙伴应该早就发现了我们在上面的<code>cmd/compile/internal/gc/walk.go</code>源码图中折叠了部分代码， 现在我们就将这块神秘的代码赤裸裸的展示出来</p>
<p>我们分析这块代码发现,go编译器在将<code>字符串转字节切片</code>生成AST时，总共分为三步。</p>
<ol>
<li>先判断该变量是否是常量字符串,如果是常量字符串,则直接通过<code>types.NewArray</code>创建一个和字符串等长的数组</li>
<li>常量字符串生成的切片变量也要进行逃逸分析，并判断其大小是否大于函数栈允许分配给变量的最大长度， 从而判断节点是分配在栈上还是在堆上</li>
<li>最后，如果字符串长度是大于0， 将字符串内容复制到字节切片中， 然后返回。因此现象三中的切片容量是3也就完全清楚了</li>
</ol>
<h2 id="结论">结论</h2>
<p>字符串转字节切片步骤如下</p>
<ol>
<li>
<p>判断是否是常量， 如果是常量则转换为等容量等长的字节切片</p>
</li>
<li>
<p>如果是变量， 先判断生成的切片是否发生变量逃逸</p>
</li>
<li>
<ul>
<li>如果逃逸或者字符串长度&gt;32， 则根据字符串长度可以计算出不同的容量</li>
<li>如果未逃逸且字符串长度&lt;=32, 则字符切片容量为32</li>
</ul>
</li>
</ol>
<h2 id="扩展">扩展</h2>
<p>常见逃逸情况</p>
<ol>
<li>函数返回局部指针</li>
<li>栈空间不足逃逸</li>
<li>动态类型逃逸, 很多函数参数为interface类型，比如fmt.Println(a ...interface{})，编译期间很难确定其参数的具体类型, 也会发生逃逸</li>
<li>闭包引用对象逃逸</li>
</ol>
<blockquote>
<p>注: 写本文时， 笔者所用go版本为: go1.13.4</p>
</blockquote>
<blockquote>
<p>生命不息， 探索不止， 后续将持续更新有关于go的技术探索</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Hugo 搭建博客]]></title>
        <id>https://ChicRingo.github.io/post/shi-yong-hugo-da-jian-bo-ke/</id>
        <link href="https://ChicRingo.github.io/post/shi-yong-hugo-da-jian-bo-ke/">
        </link>
        <updated>2020-08-21T15:40:21.000Z</updated>
        <content type="html"><![CDATA[<p>https://www.diguage.com/post/building-blog-with-hugo/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用2个goroutine轮流打印一个数组]]></title>
        <id>https://ChicRingo.github.io/post/shi-yong-2-ge-goroutine-lun-liu-da-yin-yi-ge-shu-zu/</id>
        <link href="https://ChicRingo.github.io/post/shi-yong-2-ge-goroutine-lun-liu-da-yin-yi-ge-shu-zu/">
        </link>
        <updated>2020-08-21T11:11:56.000Z</updated>
        <summary type="html"><![CDATA[<p>今天遇到群友的一到面试题，感觉在各种地方看到很多次这种类似的题目，比如两个goroutine轮流打印奇偶数，所以记录整理下来。</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天遇到群友的一到面试题，感觉在各种地方看到很多次这种类似的题目，比如两个goroutine轮流打印奇偶数，所以记录整理下来。</p>
<!-- more -->
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

// 使用2个goroutine轮流打印一个数组
var wg sync.WaitGroup
var ch = make(chan bool)
var send = make(chan int)

func main() {
    wg.Add(3)
    nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
    l := len(nums)
    go Send(nums, l)      // 发送
    go printOdd(l)  // 打印奇数
    go printEven(l) // 打印偶数
    wg.Wait()
}

// 发送数组元素
func Send(nums []int, l int) {
    defer wg.Done()
    for i := 0; i &lt; l; i++ {
        a := nums[i]
        send &lt;- a
    }
}

// 打印奇数
func printEven(l int) {
    defer wg.Done()
    for i := 0; i &lt; l; i++ {
        ch &lt;- true
        if i&amp;1 == 0 {
            a := &lt;-send
            fmt.Println(&quot;printEven:&quot;, a)
        }
    }
}

// 打印偶数
func printOdd(l int) {
    defer wg.Done()
    for i := 0; i &lt; l; i++ {
        &lt;-ch
        if i&amp;1 == 1 {
            a := &lt;-send
            fmt.Println(&quot;printOdd: &quot;, a)
        }
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang 并发控制的两种模式]]></title>
        <id>https://ChicRingo.github.io/post/golang-bing-fa-kong-zhi-de-liang-chong-mo-shi/</id>
        <link href="https://ChicRingo.github.io/post/golang-bing-fa-kong-zhi-de-liang-chong-mo-shi/">
        </link>
        <updated>2020-08-20T14:38:27.000Z</updated>
        <summary type="html"><![CDATA[<p>Golang 两种常用的并发控制，使用 channel 和 WaitGroup 两种模式</p>
]]></summary>
        <content type="html"><![CDATA[<p>Golang 两种常用的并发控制，使用 channel 和 WaitGroup 两种模式</p>
<!-- more -->
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

func main() {
	fmt.Println(&quot;Hello, 世界&quot;)
	handle1()
	handle2()
}

func handle1() {
	// 通过无缓冲通道来实现多 goroutine 并发控制

	// create channel to synchronize
	done := make(chan bool) // 无缓冲通道
	defer close(done)

	go func() {
		time.Sleep(1 * time.Second)
		fmt.Println(&quot;one done&quot;)
		done &lt;- true
	}()

	go func() {
		time.Sleep(1 * time.Second)
		fmt.Println(&quot;two done&quot;)
		done &lt;- true
	}()

	// wait until both are done
	for c := 0; c &lt; 2; c++ {
		&lt;-done
	}
	fmt.Println(&quot;handle1 done&quot;)
	// 当主 goroutine 运行到 &lt;-done 接受 channel 的值的时候，如果该  channel 中没有数据，就会一直阻塞等待，直到有值。
}

func handle2() {
	// 通过sync包中的WaitGroup 实现并发控制

	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		time.Sleep(1 * time.Second)
		fmt.Println(&quot;1 done&quot;)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		time.Sleep(1 * time.Second)
		fmt.Println(&quot;2 done&quot;)
		wg.Done()
	}()
	wg.Wait()
	fmt.Println(&quot;handle2 done&quot;)

	// 在 sync 包中，提供了 WaitGroup ，它会等待它收集的所有 goroutine 任务全部完成，在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回。
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang并发模型：并发协程的优雅退出]]></title>
        <id>https://ChicRingo.github.io/post/golang-bing-fa-mo-xing-bing-fa-xie-cheng-de-you-ya-tui-chu/</id>
        <link href="https://ChicRingo.github.io/post/golang-bing-fa-mo-xing-bing-fa-xie-cheng-de-you-ya-tui-chu/">
        </link>
        <updated>2020-08-20T11:35:30.000Z</updated>
        <summary type="html"><![CDATA[<p>文章来源：<a href="https://lessisbetter.site/2018/12/02/golang-exit-goroutine-in-3-ways/">Golang并发模型：并发协程的优雅退出</a><br>
goroutine作为Golang并发的核心，我们不仅要关注它们的创建和管理，当然还要关注如何合理的退出这些协程，不（合理）退出不然可能会造成阻塞、panic、程序行为异常、数据结果不正确等问题。这篇文章介绍，如何合理的退出goroutine，减少软件bug。</p>
]]></summary>
        <content type="html"><![CDATA[<p>文章来源：<a href="https://lessisbetter.site/2018/12/02/golang-exit-goroutine-in-3-ways/">Golang并发模型：并发协程的优雅退出</a><br>
goroutine作为Golang并发的核心，我们不仅要关注它们的创建和管理，当然还要关注如何合理的退出这些协程，不（合理）退出不然可能会造成阻塞、panic、程序行为异常、数据结果不正确等问题。这篇文章介绍，如何合理的退出goroutine，减少软件bug。</p>
<!-- more -->
<p>goroutine在退出方面，不像线程和进程，不能通过某种手段<strong>强制</strong>关闭它们，只能等待goroutine主动退出。但也无需为退出、关闭goroutine而烦恼，下面就介绍3种优雅退出goroutine的方法，只要采用这种最佳实践去设计，基本上就可以确保goroutine退出上不会有问题，尽情享用。</p>
<h3 id="1使用for-range退出">1：使用for-range退出</h3>
<p><code>for-range</code>是使用频率很高的结构，常用它来遍历数据，<strong><code>range</code>能够感知channel的关闭，当channel被发送数据的协程关闭时，range就会结束</strong>，接着退出for循环。</p>
<p>它在并发中的使用场景是：当协程只从1个channel读取数据，然后进行处理，处理后协程退出。下面这个示例程序，当in通道被关闭时，协程可自动退出。</p>
<pre><code>go func(in &lt;-chan int) {
    // Using for-range to exit goroutine
    // range has the ability to detect the close/end of a channel
    for x := range in {
        fmt.Printf(&quot;Process %d\n&quot;, x)
    }
}(inCh)
</code></pre>
<h3 id="2使用ok退出">2：使用,ok退出</h3>
<p><code>for-select</code>也是使用频率很高的结构，select提供了多路复用的能力，所以for-select可以让函数具有持续多路处理多个channel的能力。<strong>但select没有感知channel的关闭，这引出了2个问题</strong>：</p>
<ol>
<li>继续在关闭的通道上读，会读到通道传输数据类型的零值，如果是指针类型，读到nil，继续处理还会产生nil。</li>
<li>继续在关闭的通道上写，将会panic。</li>
</ol>
<p>问题2可以这样解决，通道只由发送方关闭，接收方不可关闭，即某个写通道只由使用该select的协程关闭，select中就不存在继续在关闭的通道上写数据的问题。</p>
<p>问题1可以使用<code>,ok</code>来检测通道的关闭，使用情况有2种。</p>
<p>第一种：<strong>如果某个通道关闭后，需要退出协程，直接return即可</strong>。示例代码中，该协程需要从in通道读数据，还需要定时打印已经处理的数量，有2件事要做，所有不能使用for-range，需要使用for-select，当in关闭时，<code>ok=false</code>，我们直接返回。</p>
<pre><code>go func() {
	// in for-select using ok to exit goroutine
	for {
		select {
		case x, ok := &lt;-in:
			if !ok {
				return
			}
			fmt.Printf(&quot;Process %d\n&quot;, x)
			processedCnt++
		case &lt;-t.C:
			fmt.Printf(&quot;Working, processedCnt = %d\n&quot;, processedCnt)
		}
	}
}()
</code></pre>
<p>第二种：如果<strong>某个通道关闭了，不再处理该通道，而是继续处理其他case</strong>，退出是等待所有的可读通道关闭。我们需要<strong>使用select的一个特征：select不会在nil的通道上进行等待</strong>。这种情况，把只读通道设置为nil即可解决。</p>
<pre><code>go func() {
	// in for-select using ok to exit goroutine
	for {
		select {
		case x, ok := &lt;-in1:
			if !ok {
				in1 = nil
			}
			// Process
		case y, ok := &lt;-in2:
			if !ok {
				in2 = nil
			}
			// Process
		case &lt;-t.C:
			fmt.Printf(&quot;Working, processedCnt = %d\n&quot;, processedCnt)
		}

		// If both in channel are closed, goroutine exit
		if in1 == nil &amp;&amp; in2 == nil {
			return
		}
	}
}()
</code></pre>
<h3 id="3使用退出通道退出">3：使用退出通道退出</h3>
<p><strong>使用<code>,ok</code>来退出使用for-select协程，解决是当读入数据的通道关闭时，没数据读时程序的正常结束</strong>。想想下面这2种场景，<code>,ok</code>还能适用吗？</p>
<ol>
<li>接收的协程要退出了，如果它直接退出，不告知发送协程，发送协程将阻塞。</li>
<li>启动了一个工作协程处理数据，如何通知它退出？</li>
</ol>
<p><strong>使用一个专门的通道，发送退出的信号，可以解决这类问题</strong>。以第2个场景为例，协程入参包含一个停止通道<code>stopCh</code>，当<code>stopCh</code>被关闭，<code>case &lt;-stopCh</code>会执行，直接返回即可。</p>
<p>当我启动了100个worker时，只要<code>main()</code>执行关闭stopCh，每一个worker都会都到信号，进而关闭。如果<code>main()</code>向stopCh发送100个数据，这种就低效了。</p>
<pre><code>func worker(stopCh &lt;-chan struct{}) {
	go func() {
		defer fmt.Println(&quot;worker exit&quot;)
		// Using stop channel explicit exit
		for {
			select {
			case &lt;-stopCh:
				fmt.Println(&quot;Recv stop signal&quot;)
				return
			case &lt;-t.C:
				fmt.Println(&quot;Working .&quot;)
			}
		}
	}()
	return
}
</code></pre>
<h3 id="最佳实践回顾">最佳实践回顾</h3>
<ol>
<li>发送协程主动关闭通道，接收协程不关闭通道。技巧：把接收方的通道入参声明为只读，如果接收协程关闭只读协程，编译时就会报错。</li>
<li>协程处理1个通道，并且是读时，协程优先使用<code>for-range</code>，因为<code>range</code>可以关闭通道的关闭自动退出协程。</li>
<li><code>,ok</code>可以处理多个读通道关闭，需要关闭当前使用<code>for-select</code>的协程。</li>
<li>显式关闭通道<code>stopCh</code>可以处理主动通知协程退出的场景。</li>
</ol>
<h3 id="完整示例代码">完整示例代码</h3>
<p>本文所有代码都在仓库，可查看完整示例代码：https://github.com/Shitaibin/golang_goroutine_exit</p>
<h3 id="并发系列文章推荐">并发系列文章推荐</h3>
<ul>
<li><a href="http://lessisbetter.site/2018/11/16/golang-introduction-to-pipeline/">Golang并发模型：轻松入门流水线模型</a></li>
<li><a href="http://lessisbetter.site/2018/11/28/golang-pipeline-fan-model/">Golang并发模型：轻松入门流水线FAN模式</a></li>
<li><a href="http://lessisbetter.site/2018/12/02/golang-exit-goroutine-in-3-ways/">Golang并发模型：并发协程的优雅退出</a></li>
</ul>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：http://lessisbetter.site/2018/12/02/golang-exit-goroutine-in-3-ways/</li>
</ol>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用Golang写爬虫(一)]]></title>
        <id>https://ChicRingo.github.io/post/yong-golang-xie-pa-chong-yi/</id>
        <link href="https://ChicRingo.github.io/post/yong-golang-xie-pa-chong-yi/">
        </link>
        <updated>2020-08-20T08:06:25.000Z</updated>
        <summary type="html"><![CDATA[<p>使用 Golang 对豆瓣爬虫</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用 Golang 对豆瓣爬虫</p>
<!-- more -->
<p>原文地址: <a href="https://link.zhihu.com/?target=https%3A//strconv.com/posts/web-crawler-exercise-1/">https://strconv.com/posts/web-crawler-exercise-1/</a></p>
<p>之前一直都是再用Python写爬虫，最近想体验下Golang写爬虫的感觉，所以就有了这个系列。我想要抓取的页面是<a href="https://link.zhihu.com/?target=https%3A//movie.douban.com/top250">豆瓣Top250页面</a>，选择它的理由有3个:</p>
<ol>
<li>豆瓣页面代码相对规范</li>
<li>豆瓣对爬虫爱好者相对更宽容</li>
<li>Top250页面简洁，很适合拿来练手</li>
</ol>
<p>我们先看第一版的代码。</p>
<p>按逻辑我把抓取代码分成2个部分：</p>
<ol>
<li>HTTP请求</li>
<li>解析页面中的内容</li>
</ol>
<p>我们先看HTTP请求，Golang语言的HTTP请求库不需要使用第三方的库，标准库就内置了足够好的支持：</p>
<pre><code class="language-go">import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;io/ioutil&quot;
)

func fetch (url string) string {
    fmt.Println(&quot;Fetch Url&quot;, url)
    client := &amp;http.Client{}
    req, _ := http.NewRequest(&quot;GET&quot;, url, nil)
    req.Header.Set(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)&quot;)
    resp, err := client.Do(req)
    if err != nil {
        fmt.Println(&quot;Http get err:&quot;, err)
        return &quot;&quot;
    }
    if resp.StatusCode != 200 {
        fmt.Println(&quot;Http status code:&quot;, resp.StatusCode)
        return &quot;&quot;
    }
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println(&quot;Read error&quot;, err)
        return &quot;&quot;
    }
    return string(body)
}
</code></pre>
<p>我把URL请求的逻辑都放在了fetch函数中，里面做了一些异常处理。值得说的有2点：</p>
<ol>
<li>在Header中设置了User-Agent，让访问看起来更像搜索引擎Bot。如果一个网站希望自己的内容被Google收录那么他就不会拒绝这样的UA的访问。</li>
<li>需要通过ioutil.ReadAll 读取resp的body内容，最后用string(body)把它转化成字符串</li>
</ol>
<p>接着就是解析页面的部分：</p>
<pre><code class="language-go">import (
    &quot;regexp&quot;
    &quot;strings&quot;
)

func parseUrls(url string) {
    body := fetch(url)
    body = strings.Replace(body, &quot;\n&quot;, &quot;&quot;, -1)
    rp := regexp.MustCompile(`&lt;div class=&quot;hd&quot;&gt;(.*?)&lt;/div&gt;`)
    titleRe := regexp.MustCompile(`&lt;span class=&quot;title&quot;&gt;(.*?)&lt;/span&gt;`)
    idRe := regexp.MustCompile(`&lt;a href=&quot;https://movie.douban.com/subject/(\d+)/&quot;`)
    items := rp.FindAllStringSubmatch(body, -1)
    for _, item := range items {
        fmt.Println(idRe.FindStringSubmatch(item[1])[1],
            titleRe.FindStringSubmatch(item[1])[1])
    }
}
</code></pre>
<p>这篇文章我们主要体验用标准库完成页面的解析，也就是用正则表达式包regexp来完成。不过要注意需要用<code>strings.Replace(body, &quot;\n&quot;, &quot;&quot;, -1)</code>这步把body内容中的回车符去掉，要不然下面的正则表达式<code>.*</code>就不符合了。<code>FindAllStringSubmatch</code>方法会把符合正则表达式的结果都解析出来（一个列表），而<code>FindStringSubmatch</code>是找第一个符合的结果。</p>
<p>Top250页面是要翻页的，最后在main函数里面实现抓取全部Top250页面。另外为了和之后的改进做对比，我们加上代码运行耗时的逻辑：</p>
<pre><code class="language-go">import (
       &quot;time&quot;
       &quot;strconv&quot;
)
func main() {
        start := time.Now()
        for i := 0; i &lt; 10; i++ {
                parseUrls(&quot;https://movie.douban.com/top250?start=&quot; + strconv.Itoa(25 * i))
        }
        elapsed := time.Since(start)
        fmt.Printf(&quot;Took %s&quot;, elapsed)
}
</code></pre>
<p>在Golang中把数字转成字符串需要使用<code>strconv.Itoa</code>（嘿嘿，本博客域名就是这个模块），这样就可以根据start的参数的不通拼出正确的页面路径。用一个for循环完成翻页。</p>
<p>运行起来非常快：</p>
<pre><code class="language-bash">❯ go run crawler/doubanCrawler1.go
... # 省略输出
Took 1.454627547s
</code></pre>
<p>通过终端输出可以看到我们拿到了对应电影条目的ID和电影标题！</p>
<h3 id="代码地址">代码地址</h3>
<p>完整代码可以在<a href="https://link.zhihu.com/?target=https%3A//github.com/golang-dev/strconv.code/blob/master/crawler/doubanCrawler1.go">这个地址</a>找到。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 Go 中恰到好处的内存对齐]]></title>
        <id>https://ChicRingo.github.io/post/zai-go-zhong-qia-dao-hao-chu-de-nei-cun-dui-qi/</id>
        <link href="https://ChicRingo.github.io/post/zai-go-zhong-qia-dao-hao-chu-de-nei-cun-dui-qi/">
        </link>
        <updated>2020-08-20T02:41:41.000Z</updated>
        <summary type="html"><![CDATA[<p>在Golang中对结构体成员进行内存对齐，以此保证内存的访问边界，并可以优化内存占用</p>
]]></summary>
        <content type="html"><![CDATA[<p>在Golang中对结构体成员进行内存对齐，以此保证内存的访问边界，并可以优化内存占用</p>
<!-- more -->
<p>原文地址：<a href="https://eddycjy.com/posts/go/talk/2018-12-26-go-memory-align/">在 Go 中恰到好处的内存对齐</a></p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2020/02/27/3wuT0A.png" alt="image" loading="lazy"></figure>
<h2 id="问题">问题</h2>
<pre><code class="language-go">type Part1 struct {
	a bool
	b int32
	c int8
	d int64
	e byte
}
</code></pre>
<p>在开始之前，希望你计算一下 <code>Part1</code> 共占用的大小是多少呢？</p>
<pre><code class="language-go">func main() {
	fmt.Printf(&quot;bool size: %d\n&quot;, unsafe.Sizeof(bool(true)))
	fmt.Printf(&quot;int32 size: %d\n&quot;, unsafe.Sizeof(int32(0)))
	fmt.Printf(&quot;int8 size: %d\n&quot;, unsafe.Sizeof(int8(0)))
	fmt.Printf(&quot;int64 size: %d\n&quot;, unsafe.Sizeof(int64(0)))
	fmt.Printf(&quot;byte size: %d\n&quot;, unsafe.Sizeof(byte(0)))
	fmt.Printf(&quot;string size: %d\n&quot;, unsafe.Sizeof(&quot;EDDYCJY&quot;))
}
</code></pre>
<p>输出结果：</p>
<pre><code>bool size: 1
int32 size: 4
int8 size: 1
int64 size: 8
byte size: 1
string size: 16
</code></pre>
<p>这么一算，<code>Part1</code> 这一个结构体的占用内存大小为 1+4+1+8+1 = 15 个字节。相信有的小伙伴是这么算的，看上去也没什么毛病</p>
<p>真实情况是怎么样的呢？我们实际调用看看，如下：</p>
<pre><code class="language-go">type Part1 struct {
	a bool
	b int32
	c int8
	d int64
	e byte
}

func main() {
	part1 := Part1{}

	fmt.Printf(&quot;part1 size: %d, align: %d\n&quot;, unsafe.Sizeof(part1), unsafe.Alignof(part1))
}
</code></pre>
<p>输出结果：</p>
<pre><code>part1 size: 32, align: 8
</code></pre>
<p>最终输出为占用 32 个字节。这与前面所预期的结果完全不一样。这充分地说明了先前的计算方式是错误的。为什么呢？</p>
<p>在这里要提到 “内存对齐” 这一概念，才能够用正确的姿势去计算，接下来我们详细的讲讲它是什么</p>
<h2 id="内存对齐">内存对齐</h2>
<p>有的小伙伴可能会认为内存读取，就是一个简单的字节数组摆放</p>
<figure data-type="image" tabindex="2"><img src="https://s2.ax1x.com/2020/02/27/3wuLff.png" alt="image" loading="lazy"></figure>
<p>上图表示一个坑一个萝卜的内存读取方式。但实际上 CPU 并不会以一个一个字节去读取和写入内存。相反 CPU 读取内存是<strong>一块一块读取</strong>的，块的大小可以为 2、4、6、8、16 字节等大小。块大小我们称其为<strong>内存访问粒度</strong>。如下图：</p>
<figure data-type="image" tabindex="3"><img src="https://s2.ax1x.com/2020/02/27/3wKSmj.png" alt="image" loading="lazy"></figure>
<p>在样例中，假设访问粒度为 4。 CPU 是以每 4 个字节大小的访问粒度去读取和写入内存的。这才是正确的姿势</p>
<h3 id="为什么要关心对齐">为什么要关心对齐</h3>
<ul>
<li>你正在编写的代码在性能（CPU、Memory）方面有一定的要求</li>
<li>你正在处理向量方面的指令</li>
<li>某些硬件平台（ARM）体系不支持未对齐的内存访问</li>
</ul>
<p>另外作为一个工程师，你也很有必要学习这块知识点哦 😃</p>
<h3 id="为什么要做对齐">为什么要做对齐</h3>
<ul>
<li>平台（移植性）原因：不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况</li>
<li>性能原因：若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://s2.ax1x.com/2020/02/27/3wKApT.png" alt="image" loading="lazy"></figure>
<p>在上图中，假设从 Index 1 开始读取，将会出现很崩溃的问题。因为它的内存访问边界是不对齐的。因此 CPU 会做一些额外的处理工作。如下：</p>
<ol>
<li>CPU <strong>首次</strong>读取未对齐地址的第一个内存块，读取 0-3 字节。并移除不需要的字节 0</li>
<li>CPU <strong>再次</strong>读取未对齐地址的第二个内存块，读取 4-7 字节。并移除不需要的字节 5、6、7 字节</li>
<li>合并 1-4 字节的数据</li>
<li>合并后放入寄存器</li>
</ol>
<p>从上述流程可得出，不做 “内存对齐” 是一件有点 “麻烦” 的事。因为它会增加许多耗费时间的动作</p>
<p>而假设做了内存对齐，从 Index 0 开始读取 4 个字节，只需要读取一次，也不需要额外的运算。这显然高效很多，是标准的<strong>空间换时间</strong>做法</p>
<h3 id="默认系数">默认系数</h3>
<p>在不同平台上的编译器都有自己默认的 “对齐系数”，可通过预编译命令 <code>#pragma pack(n)</code> 进行变更，n 就是代指 “对齐系数”。一般来讲，我们常用的平台的系数如下：</p>
<ul>
<li>32 位：4</li>
<li>64 位：8</li>
</ul>
<p>另外要注意，不同硬件平台占用的大小和对齐值都可能是不一样的。因此本文的值不是唯一的，调试的时候需按本机的实际情况考虑</p>
<h3 id="成员对齐">成员对齐</h3>
<pre><code class="language-go">func main() {
	fmt.Printf(&quot;bool align: %d\n&quot;, unsafe.Alignof(bool(true)))
	fmt.Printf(&quot;int32 align: %d\n&quot;, unsafe.Alignof(int32(0)))
	fmt.Printf(&quot;int8 align: %d\n&quot;, unsafe.Alignof(int8(0)))
	fmt.Printf(&quot;int64 align: %d\n&quot;, unsafe.Alignof(int64(0)))
	fmt.Printf(&quot;byte align: %d\n&quot;, unsafe.Alignof(byte(0)))
	fmt.Printf(&quot;string align: %d\n&quot;, unsafe.Alignof(&quot;EDDYCJY&quot;))
	fmt.Printf(&quot;map align: %d\n&quot;, unsafe.Alignof(map[string]string{}))
}
</code></pre>
<p>输出结果：</p>
<pre><code>bool align: 1
int32 align: 4
int8 align: 1
int64 align: 8
byte align: 1
string align: 8
map align: 8
</code></pre>
<p>在 Go 中可以调用 <code>unsafe.Alignof</code> 来返回相应类型的对齐系数。通过观察输出结果，可得知基本都是 <code>2^n</code>，最大也不会超过 8。这是因为我手提（64 位）编译器默认对齐系数是 8，因此最大值不会超过这个数</p>
<h3 id="整体对齐">整体对齐</h3>
<p>在上小节中，提到了结构体中的成员变量要做字节对齐。那么想当然身为最终结果的结构体，也是需要做字节对齐的</p>
<h3 id="对齐规则">对齐规则</h3>
<ul>
<li>结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>当前成员变量类型的长度</strong>（<code>unsafe.Sizeof</code>），取<strong>最小值作为当前类型的对齐值</strong>。其偏移量必须为对齐值的整数倍</li>
<li>结构体本身，对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>结构体的所有成员变量类型中的最大长度</strong>，取<strong>最大数的最小整数倍</strong>作为对齐值</li>
<li>结合以上两点，可得知若<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的</li>
</ul>
<h2 id="分析流程">分析流程</h2>
<p>接下来我们一起分析一下，“它” 到底经历了些什么，影响了 “预期” 结果</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>类型</th>
<th>偏移量</th>
<th>自身占用</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>bool</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>b</td>
<td>int32</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>c</td>
<td>int8</td>
<td>8</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>9</td>
<td>7</td>
</tr>
<tr>
<td>d</td>
<td>int64</td>
<td>16</td>
<td>8</td>
</tr>
<tr>
<td>e</td>
<td>byte</td>
<td>24</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>25</td>
<td>7</td>
</tr>
<tr>
<td>总占用大小</td>
<td>-</td>
<td>-</td>
<td>32</td>
</tr>
</tbody>
</table>
<h3 id="成员对齐-2">成员对齐</h3>
<ul>
<li>第一个成员 a
<ul>
<li>类型为 bool</li>
<li>大小/对齐值为 1 字节</li>
<li>初始地址，偏移量为 0。占用了第 1 位</li>
</ul>
</li>
<li>第二个成员 b
<ul>
<li>类型为 int32</li>
<li>大小/对齐值为 4 字节</li>
<li>根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此 2-4 位为 Padding。而当前数值从第 5 位开始填充，到第 8 位。如下：axxx|bbbb</li>
</ul>
</li>
<li>第三个成员 c
<ul>
<li>类型为 int8</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 8。不需要额外对齐，填充 1 个字节到第 9 位。如下：axxx|bbbb|c…</li>
</ul>
</li>
<li>第四个成员 d
<ul>
<li>类型为 int64</li>
<li>大小/对齐值为 8 字节</li>
<li>根据规则 1，其偏移量必须为 8 的整数倍。确定偏移量为 16，因此 9-16 位为 Padding。而当前数值从第 17 位开始写入，到第 24 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd</li>
</ul>
</li>
<li>第五个成员 e
<ul>
<li>类型为 byte</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 24。不需要额外对齐，填充 1 个字节到第 25 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd|e…</li>
</ul>
</li>
</ul>
<h3 id="整体对齐-2">整体对齐</h3>
<p>在每个成员变量进行对齐后，根据规则 2，整个结构体本身也要进行字节对齐，因为可发现它可能并不是 <code>2^n</code>，不是偶数倍。显然不符合对齐的规则</p>
<p>根据规则 2，可得出对齐值为 8。现在的偏移量为 25，不是 8 的整倍数。因此确定偏移量为 32。对结构体进行对齐</p>
<h3 id="结果">结果</h3>
<p>Part1 内存布局：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</p>
<h3 id="小结">小结</h3>
<p>通过本节的分析，可得知先前的 “推算” 为什么错误？</p>
<p>是因为实际内存管理并非 “一个萝卜一个坑” 的思想。而是一块一块。通过空间换时间（效率）的思想来完成这块读取、写入。另外也需要兼顾不同平台的内存操作情况</p>
<h2 id="巧妙的结构体">巧妙的结构体</h2>
<p>在上一小节，可得知根据成员变量的类型不同，其结构体的内存会产生对齐等动作。那假设字段顺序不同，会不会有什么变化呢？我们一起来试试吧 😃</p>
<pre><code class="language-go">type Part1 struct {
	a bool
	b int32
	c int8
	d int64
	e byte
}

type Part2 struct {
	e byte
	c int8
	a bool
	b int32
	d int64
}

func main() {
	part1 := Part1{}
	part2 := Part2{}

	fmt.Printf(&quot;part1 size: %d, align: %d\n&quot;, unsafe.Sizeof(part1), unsafe.Alignof(part1))
	fmt.Printf(&quot;part2 size: %d, align: %d\n&quot;, unsafe.Sizeof(part2), unsafe.Alignof(part2))
}
</code></pre>
<p>输出结果：</p>
<pre><code>part1 size: 32, align: 8
part2 size: 16, align: 8
</code></pre>
<p>通过结果可以惊喜的发现，只是 “简单” 对成员变量的字段顺序进行改变，就改变了结构体占用大小</p>
<p>接下来我们一起剖析一下 <code>Part2</code>，看看它的内部到底和上一位之间有什么区别，才导致了这样的结果？</p>
<h3 id="分析流程-2">分析流程</h3>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>类型</th>
<th>偏移量</th>
<th>自身占用</th>
</tr>
</thead>
<tbody>
<tr>
<td>e</td>
<td>byte</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>c</td>
<td>int8</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>a</td>
<td>bool</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>b</td>
<td>int32</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>d</td>
<td>int64</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>总占用大小</td>
<td>-</td>
<td>-</td>
<td>16</td>
</tr>
</tbody>
</table>
<h4 id="成员对齐-3">成员对齐</h4>
<ul>
<li>第一个成员 e
<ul>
<li>类型为 byte</li>
<li>大小/对齐值为 1 字节</li>
<li>初始地址，偏移量为 0。占用了第 1 位</li>
</ul>
</li>
<li>第二个成员 c
<ul>
<li>类型为 int8</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 2。不需要额外对齐</li>
</ul>
</li>
<li>第三个成员 a
<ul>
<li>类型为 bool</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 3。不需要额外对齐</li>
</ul>
</li>
<li>第四个成员 b
<ul>
<li>类型为 int32</li>
<li>大小/对齐值为 4 字节</li>
<li>根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此第 3 位为 Padding。而当前数值从第 4 位开始填充，到第 8 位。如下：ecax|bbbb</li>
</ul>
</li>
<li>第五个成员 d
<ul>
<li>类型为 int64</li>
<li>大小/对齐值为 8 字节</li>
<li>根据规则 1，其偏移量必须为 8 的整数倍。当前偏移量为 8。不需要额外对齐，从 9-16 位填充 8 个字节。如下：ecax|bbbb|dddd|dddd</li>
</ul>
</li>
</ul>
<h4 id="整体对齐-3">整体对齐</h4>
<p>符合规则 2，不需要额外对齐</p>
<h4 id="结果-2">结果</h4>
<p>Part2 内存布局：ecax|bbbb|dddd|dddd</p>
<h2 id="总结">总结</h2>
<p>通过对比 <code>Part1</code> 和 <code>Part2</code> 的内存布局，你会发现两者有很大的不同。如下：</p>
<ul>
<li>Part1：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</li>
<li>Part2：ecax|bbbb|dddd|dddd</li>
</ul>
<p>仔细一看，<code>Part1</code> 存在许多 Padding。显然它占据了不少空间，那么 Padding 是怎么出现的呢？</p>
<p>通过本文的介绍，可得知是由于不同类型导致需要进行字节对齐，以此保证内存的访问边界</p>
<p>那么也不难理解，为什么<strong>调整结构体内成员变量的字段顺序</strong>就能达到缩小结构体占用大小的疑问了，是因为巧妙地减少了 Padding 的存在。让它们更 “紧凑” 了。这一点对于加深 Go 的内存布局印象和大对象的优化非常有帮</p>
<p>当然了，没什么特殊问题，你可以不关注这一块。但你要知道这块知识点 😄</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Data structure alignment</a></li>
<li><a href="https://www.ibm.com/developerworks/library/pa-dalign/">Data alignment</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang 中零值的坑]]></title>
        <id>https://ChicRingo.github.io/post/golang-zhong-ling-zhi-de-keng/</id>
        <link href="https://ChicRingo.github.io/post/golang-zhong-ling-zhi-de-keng/">
        </link>
        <updated>2020-08-19T11:13:43.000Z</updated>
        <summary type="html"><![CDATA[<p>对于int, string, bool来说，声明这三种基本类型的变量，Go会默认分配一个零值，零值分别为 0 , '' ,false，所以在GORM中通过tag定义字段的默认值后，这些有默认值的字段在使用这些零值作为参数时，GORM不会把这些字段的值插入数据库中，这个坑一定要切记。</p>
]]></summary>
        <content type="html"><![CDATA[<p>对于int, string, bool来说，声明这三种基本类型的变量，Go会默认分配一个零值，零值分别为 0 , '' ,false，所以在GORM中通过tag定义字段的默认值后，这些有默认值的字段在使用这些零值作为参数时，GORM不会把这些字段的值插入数据库中，这个坑一定要切记。</p>
<!-- more -->
<h2 id="默认值">默认值</h2>
<p>可以通过 tag 定义字段的默认值，比如：</p>
<pre><code class="language-go">type User struct {
  ID   int64
  Name string `gorm:&quot;default:'小王子'&quot;`
  Age  int64
}
</code></pre>
<p><strong>注意：</strong> 通过tag定义字段的默认值，在创建记录时候生成的 SQL 语句会排除没有值或值为 零值 的字段。 在将记录插入到数据库后，Gorm会从数据库加载那些字段的默认值。</p>
<p>举个例子：</p>
<pre><code class="language-go">var user = User{Name: &quot;&quot;, Age: 99}
db.Create(&amp;user)
</code></pre>
<p>上面代码实际执行的SQL语句是<code>INSERT INTO users(&quot;age&quot;) values('99');</code>，排除了零值字段<code>Name</code>，而在数据库中这一条数据会使用设置的默认值<code>小王子</code>作为Name字段的值。</p>
<p>**注意：**所有字段的零值, 比如<code>0</code>, <code>&quot;&quot;</code>,<code>false</code>或者其它<code>零值</code>，都不会保存到数据库内，但会使用他们的默认值。 如果你想避免这种情况，可以考虑使用指针或实现 <code>Scanner/Valuer</code>接口，比如：</p>
<h3 id="使用指针方式实现零值存入数据库">使用指针方式实现零值存入数据库</h3>
<pre><code class="language-go">// 使用指针
type User struct {
  ID   int64
  Name *string `gorm:&quot;default:'小王子'&quot;`
  Age  int64
}
user := User{Name: new(string), Age: 18))}
db.Create(&amp;user)  // 此时数据库中该条记录name字段的值就是''
</code></pre>
<h3 id="使用scannervaluer接口方式实现零值存入数据库">使用Scanner/Valuer接口方式实现零值存入数据库</h3>
<pre><code class="language-go">// 使用 Scanner/Valuer
type User struct {
	ID int64
	Name sql.NullString `gorm:&quot;default:'小王子'&quot;` // sql.NullString 实现了Scanner/Valuer接口
	Age  int64
}
user := User{Name: sql.NullString{&quot;&quot;, true}, Age:18}
db.Create(&amp;user)  // 此时数据库中该条记录name字段的值就是''
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang 中 range 的坑]]></title>
        <id>https://ChicRingo.github.io/post/golang-zhong-range-de-keng/</id>
        <link href="https://ChicRingo.github.io/post/golang-zhong-range-de-keng/">
        </link>
        <updated>2020-08-19T04:25:55.000Z</updated>
        <summary type="html"><![CDATA[<p>避免踩坑指北，Golang 中容易在 for range 中踩到的坑</p>
]]></summary>
        <content type="html"><![CDATA[<p>避免踩坑指北，Golang 中容易在 for range 中踩到的坑</p>
<!-- more -->
<h2 id="使用-range-迭代遍历数组">使用 range 迭代遍历数组</h2>
<p>range 会复制对象，而不是不是直接在原对象上操作。</p>
<p>示例一：</p>
<pre><code class="language-go">func main() {
    a := [3]int{1, 2, 3}
    for _, v := range a { // 复制一份a遍历[1, 2, 3]
        v += 100 // v是复制对象中的值，不会改变a数组元素的值
    }
    fmt.Println(a) // 1 2 3
}
</code></pre>
<p>示例二：</p>
<pre><code class="language-go">func main() {
    a := [3]int{1, 2, 3}
    for i, v := range a { // i,v从a复制的对象里提取出
        if i == 0 {
            a[1], a[2] = 200, 300
            fmt.Println(a) // 输出[1 200 300]
        }
        a[i] = v + 100 // v是复制对象里的元素[1, 2, 3]
    }
    fmt.Println(a) // 输出[101, 102, 103]
}
</code></pre>
<p>结果：</p>
<pre><code class="language-powershell">[1 200 300]
[101 102 103]
</code></pre>
<h2 id="使用-range-迭代遍历切片">使用 range 迭代遍历切片</h2>
<p>range迭代遍历引用类型时，底层的数据不会被复制：</p>
<pre><code class="language-go">func main() {
    a := []int{1, 2, 3} // 改成slice
    for i, v := range a {
        if i == 0 {
            a[1], a[2] = 200, 300
            fmt.Println(a) // [1 200 300]
        }
        a[i] = v + 100
    }
    fmt.Println(a) // 输出[101 300 400]
}

</code></pre>
<p>结果：</p>
<pre><code class="language-powershell">[1 200 300]
[101 300 400]
</code></pre>
<p>因为切片的内部结构为struct slice{*point, len, cap}。</p>
<p>数据部分是一个指针，指向地址，复制对象的时候只是把指针的值复制了，而不是重新拷贝一块新的内存再把值放进去，所以修改的时候还是修改的原来的值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go 为什么这么“快”]]></title>
        <id>https://ChicRingo.github.io/post/go-wei-shi-me-zhe-me-kuai/</id>
        <link href="https://ChicRingo.github.io/post/go-wei-shi-me-zhe-me-kuai/">
        </link>
        <updated>2020-08-19T02:49:40.000Z</updated>
        <summary type="html"><![CDATA[<p>本文主要介绍了 Go 程序为了实现极高的并发性能，其内部调度器的实现架构（G-P-M 模型），以及为了最大限度利用计算资源，Go 调度器是如何处理线程阻塞的场景</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文主要介绍了 Go 程序为了实现极高的并发性能，其内部调度器的实现架构（G-P-M 模型），以及为了最大限度利用计算资源，Go 调度器是如何处理线程阻塞的场景</p>
<!-- more -->
<p>转自<a href="https://zhuanlan.zhihu.com/p/111346689">知乎：Go为什么这么“快”</a></p>
<h2 id="怎么让我们的系统更快"><strong>怎么让我们的系统更快</strong></h2>
<p>随着信息技术的迅速发展，单台服务器处理能力越来越强，迫使编程模式由从前的串行模式升级到并发模型。</p>
<p>并发模型包含 IO 多路复用、多进程以及多线程，这几种模型都各有优劣，现代复杂的高并发架构大多是几种模型协同使用，不同场景应用不同模型，扬长避短，发挥服务器的最大性能。</p>
<p>而<strong>多线程，因为其轻量和易用</strong>，成为并发编程中使用频率最高的并发模型，包括后衍生的协程等其他子产品，也都基于它。</p>
<h2 id="并发-并行"><strong>并发 ≠ 并行</strong></h2>
<p><strong>并发 (concurrency) 和 并行 ( parallelism) 是不同的。</strong></p>
<p>在单个 CPU 核上，线程通过时间片或者让出控制权来实现任务切换，达到 &quot;同时&quot; 运行多个任务的目的，这就是所谓的并发。但实际上任何时刻都只有一个任务被执行，其他任务通过某种算法来排队。</p>
<p>多核 CPU 可以让同一进程内的 &quot;多个线程&quot; 做到真正意义上的同时运行，这才是并行。</p>
<h2 id="进程-线程-协程"><strong>进程、线程、协程</strong></h2>
<p>进程：进程是系统进行资源分配的基本单位，有独立的内存空间。</p>
<p>线程：线程是 CPU 调度和分派的基本单位，线程依附于进程存在，每个线程会共享父进程的资源。</p>
<p>协程：**协程是一种用户态的轻量级线程，**协程的调度完全由用户控制，协程间切换只需要保存任务的上下文，没有内核的开销。</p>
<h2 id="线程上下文切换"><strong>线程上下文切换</strong></h2>
<p>由于中断处理，多任务处理，用户态切换等原因会导致 CPU 从一个线程切换到另一个线程，切换过程需要保存当前进程的状态并恢复另一个进程的状态。</p>
<p><strong>上下文切换的代价是高昂的</strong>，因为在核心上交换线程会花费很多时间。上下文切换的延迟取决于不同的因素，大概在在 50 到 100 纳秒之间。考虑到硬件平均在每个核心上每纳秒执行 12 条指令，那么一次上下文切换可能会花费 600 到 1200 条指令的延迟时间。实际上，上下文切换占用了大量程序执行指令的时间。</p>
<p>如果存在<strong>跨核上下文切换</strong>（Cross-Core Context Switch），可能会导致 CPU 缓存失效（CPU 从缓存访问数据的成本大约 3 到 40 个时钟周期，从主存访问数据的成本大约 100 到 300 个时钟周期），这种场景的切换成本会更加昂贵。</p>
<h2 id="golang-为并发而生"><strong>Golang 为并发而生</strong></h2>
<p>Golang 从 2009 年正式发布以来，依靠其极高运行速度和高效的开发效率，迅速占据市场份额。Golang 从语言级别支持并发，通过轻量级协程 Goroutine 来实现程序并发运行。</p>
<p><strong>Goroutine 非常轻量</strong>，主要体现在以下两个方面：</p>
<p><strong>上下文切换代价小：</strong> Goroutine 上下文切换只涉及到三个寄存器（PC / SP / DX）的值修改；而对比线程的上下文切换则需要涉及模式切换（从用户态切换到内核态）、以及 16 个寄存器、PC、SP…等寄存器的刷新；</p>
<p><strong>内存占用少：</strong> 线程栈空间通常是 2M，Goroutine 栈空间最小 2K；</p>
<p>Golang 程序中可以轻松支持<strong>10w 级别</strong>的 Goroutine 运行，而线程数量达到 1k 时，内存占用就已经达到 2G。</p>
<h2 id="go-调度器实现机制"><strong>Go 调度器实现机制：</strong></h2>
<p>Go 程序通过调度器来调度**Goroutine 在内核线程上执行，**但是 G</p>
<ul>
<li><em>Goroutine</em>并不直接绑定 OS 线程 M - <em>Machine</em>运行，而是由 Goroutine Scheduler 中的 P - <em>Processor</em> （逻辑处理器）来作获取内核线程资源的『中介』。</li>
</ul>
<p>Go 调度器模型我们通常叫做<strong>G-P-M 模型</strong>，他包括 4 个重要结构，分别是<strong>G、P、M、Sched：</strong></p>
<p>**G:Goroutine，**每个 Goroutine 对应一个 G 结构体，G 存储 Goroutine 的运行堆栈、状态以及任务函数，可重用。</p>
<p>G 并非执行体，每个 G 需要绑定到 P 才能被调度执行。</p>
<p>**P: Processor，**表示逻辑处理器，对 G 来说，P 相当于 CPU 核，G 只有绑定到 P 才能被调度。对 M 来说，P 提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等。</p>
<p>P 的数量决定了系统内最大可并行的 G 的数量（前提：物理 CPU 核数 &gt;= P 的数量）。</p>
<p><strong>P 的数量由用户设置的 GoMAXPROCS 决定，但是不论 GoMAXPROCS 设置为多大，P 的数量最大为 256。</strong></p>
<p>**M: Machine，**OS 内核线程抽象，代表着真正执行计算的资源，在绑定有效的 P 后，进入 schedule 循环；而 schedule 循环的机制大致是从 Global 队列、P 的 Local 队列以及 wait 队列中获取。</p>
<p>**M 的数量是不定的，由 Go Runtime 调整，**为了防止创建过多 OS 线程导致系统调度不过来，目前默认最大限制为 10000 个。</p>
<p>M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。</p>
<p>**Sched：Go 调度器，**它维护有存储 M 和 G 的队列以及调度器的一些状态信息等。</p>
<p>调度器循环的机制大致是从各种队列、P 的本地队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 Goexit 做清理工作并回到 M，如此反复。</p>
<p><strong>理解 M、P、G 三者的关系，可以通过经典的地鼠推车搬砖的模型来说明其三者关系：</strong></p>
<figure data-type="image" tabindex="1"><img src="https://pic3.zhimg.com/80/v2-a27259141ff915578ab5165d75432930_1440w.jpg" alt="img" loading="lazy"></figure>
<p><strong>地鼠(Gopher)的工作任务是：<strong>工地上有若干砖头，地鼠</strong>借助小车</strong>把砖头运送到火种上去烧制。<strong>M 就可以看作图中的地鼠，P 就是小车，G 就是小车里装的砖。</strong></p>
<p>弄清楚了它们三者的关系，下面我们就开始重点聊地鼠是如何在搬运砖块的。</p>
<p><strong>Processor（P）：</strong></p>
<p>根据用户设置的 **GoMAXPROCS **值来创建一批小车(P)。</p>
<p><strong>Goroutine(G)：</strong></p>
<p>通过 Go 关键字就是用来创建一个 Goroutine，也就相当于制造一块砖(G)，然后将这块砖(G)放入当前这辆小车(P)中。</p>
<p><strong>Machine (M)：</strong></p>
<p>地鼠(M)不能通过外部创建出来，只能砖(G)太多了，地鼠(M)又太少了，实在忙不过来，<strong>刚好还有空闲的小车(P)没有使用</strong>，那就从别处再借些地鼠(M)过来直到把小车(P)用完为止。</p>
<p>这里有一个地鼠(M)不够用，从别处借地鼠(M)的过程，这个过程就是创建一个内核线程(M)。</p>
<p>**需要注意的是：**地鼠(M) 如果没有小车(P)是没办法运砖的，<strong>小车(P)的数量决定了能够干活的地鼠(M)数量</strong>，在 Go 程序里面对应的是活动线程数；</p>
<p><strong>在 Go 程序里我们通过下面的图示来展示 G-P-M 模型：</strong></p>
<figure data-type="image" tabindex="2"><img src="https://pic2.zhimg.com/80/v2-a39b9615c2a4dc7fc3a5af9ff93da828_1440w.jpg" alt="img" loading="lazy"></figure>
<p>P 代表可以“并行”运行的逻辑处理器，每个 P 都被分配到一个系统线程 M，G 代表 Go 协程。</p>
<p>Go 调度器中有两个不同的运行队列：<strong>全局运行队列(GRQ)和本地运行队列(LRQ)。</strong></p>
<p>每个 P 都有一个 LRQ，用于管理分配给在 P 的上下文中执行的 Goroutines，这些 Goroutine 轮流被和 P 绑定的 M 进行上下文切换。GRQ 适用于尚未分配给 P 的 Goroutines。</p>
<p>**从上图可以看出，G 的数量可以远远大于 M 的数量，换句话说，Go 程序可以利用少量的内核级线程来支撑大量 Goroutine 的并发。**多个 Goroutine 通过用户级别的上下文切换来共享内核线程 M 的计算资源，但对于操作系统来说并没有线程上下文切换产生的性能损耗。</p>
<p><strong>为了更加充分利用线程的计算资源，Go 调度器采取了以下几种调度策略：</strong></p>
<p><strong>任务窃取（work-stealing）</strong></p>
<p>我们知道，现实情况有的 Goroutine 运行的快，有的慢，那么势必肯定会带来的问题就是，忙的忙死，闲的闲死，Go 肯定不允许摸鱼的 P 存在，势必要充分利用好计算资源。</p>
<p>为了提高 Go 并行处理能力，调高整体处理效率，当每个 P 之间的 G 任务不均衡时，调度器允许从 GRQ，或者其他 P 的 LRQ 中获取 G 执行。</p>
<p><strong>减少阻塞</strong></p>
<p>如果正在执行的 Goroutine 阻塞了线程 M 怎么办？P 上 LRQ 中的 Goroutine 会获取不到调度么？</p>
<p><strong>在 Go 里面阻塞主要分为一下 4 种场景：</strong></p>
<p><strong>场景 1：由于原子、互斥量或通道操作调用导致 Goroutine 阻塞</strong>，调度器将把当前阻塞的 Goroutine 切换出去，重新调度 LRQ 上的其他 Goroutine；</p>
<p><strong>场景 2：由于网络请求和 IO 操作导致 Goroutine 阻塞</strong>，这种阻塞的情况下，我们的 G 和 M 又会怎么做呢？</p>
<p>Go 程序提供了**网络轮询器（NetPoller）**来处理网络请求和 IO 操作的问题，其后台通过 kqueue（MacOS），epoll（Linux）或 iocp（Windows）来实现 IO 多路复用。</p>
<p>通过使用 NetPoller 进行网络系统调用，调度器可以防止 Goroutine 在进行这些系统调用时阻塞 M。这可以让 M 执行 P 的 LRQ 中其他的 Goroutines，而不需要创建新的 M。有助于减少操作系统上的调度负载。</p>
<p>**下图展示它的工作原理：**G1 正在 M 上执行，还有 3 个 Goroutine 在 LRQ 上等待执行。网络轮询器空闲着，什么都没干。</p>
<figure data-type="image" tabindex="3"><img src="https://pic3.zhimg.com/80/v2-b89070ec76ea9aaf4a3b8107e8f1fe84_1440w.jpg" alt="img" loading="lazy"></figure>
<p>接下来，G1 想要进行网络系统调用，因此它被移动到网络轮询器并且处理异步网络系统调用。然后，M 可以从<br>
LRQ 执行另外的 Goroutine。此时，G2 就被上下文切换到 M 上了。</p>
<figure data-type="image" tabindex="4"><img src="https://pic2.zhimg.com/80/v2-62455d37b17ddfe216aa596338cf5e2a_1440w.jpg" alt="img" loading="lazy"></figure>
<p>最后，异步网络系统调用由网络轮询器完成，G1 被移回到 P 的 LRQ 中。一旦 G1 可以在 M 上进行上下文切换，它负责的 Go 相关代码就可以再次执行。这里的最大优势是，执行网络系统调用不需要额外的 M。网络轮询器使用系统线程，它时刻处理一个有效的事件循环。</p>
<figure data-type="image" tabindex="5"><img src="https://pic3.zhimg.com/80/v2-c9237c70726b41ca722e0b4bf883b553_1440w.jpg" alt="img" loading="lazy"></figure>
<p>这种调用方式看起来很复杂，值得庆幸的是，<strong>Go 语言将该“复杂性”隐藏在 Runtime 中</strong>：Go 开发者无需关注 socket 是否是 non-block 的，也无需亲自注册文件描述符的回调，只需在每个连接对应的 Goroutine 中以“block I/O”的方式对待 socket 处理即可，<strong>实现了 goroutine-per-connection 简单的网络编程模式</strong>（但是大量的 Goroutine 也会带来额外的问题，比如栈内存增加和调度器负担加重）。</p>
<p>用户层眼中看到的 Goroutine 中的“block socket”，实际上是通过 Go runtime 中的 netpoller 通过 Non-block socket +<br>
I/O 多路复用机制“模拟”出来的。Go 中的 net 库正是按照这方式实现的。</p>
<p>**场景 3：**当调用一些系统方法的时候，如果系统方法调用的时候发生阻塞，这种情况下，网络轮询器（NetPoller）无法使用，而进行系统调用的 Goroutine 将阻塞当前 M。</p>
<p>让我们来看看同步系统调用（如文件 I/O）会导致 M 阻塞的情况：G1 将进行同步系统调用以阻塞 M1。</p>
<figure data-type="image" tabindex="6"><img src="https://picb.zhimg.com/80/v2-bc3e58a8f34c24c0229a4add669a3e52_1440w.jpg" alt="img" loading="lazy"></figure>
<p>调度器介入后：识别出 G1 已导致 M1 阻塞，此时，调度器将 M1 与 P 分离，同时也将 G1 带走。然后调度器引入新的 M2 来服务 P。此时，可以从 LRQ 中选择 G2 并在 M2 上进行上下文切换。</p>
<figure data-type="image" tabindex="7"><img src="https://picb.zhimg.com/80/v2-9875a8b04b3653e0da8e0794dea7035e_1440w.jpg" alt="img" loading="lazy"></figure>
<p>阻塞的系统调用完成后：G1 可以移回 LRQ 并再次由 P 执行。如果这种情况再次发生，M1 将被放在旁边以备将来重复使用**。**</p>
<figure data-type="image" tabindex="8"><img src="https://picb.zhimg.com/80/v2-c0398b611bfcbe16309882a9a59c39d7_1440w.jpg" alt="img" loading="lazy"></figure>
<p>**场景 4：**如果在 Goroutine 去执行一个 sleep 操作，导致 M 被阻塞了。</p>
<p>Go 程序后台有一个监控线程 sysmon，它监控那些长时间运行的 G 任务然后设置可以强占的标识符，别的 Goroutine 就可以抢先进来执行。</p>
<p>只要下次这个 Goroutine 进行函数调用，那么就会被强占，同时也会保护现场，然后重新放入 P 的本地队列里面等待下次执行。</p>
<h2 id="小结"><strong>小结</strong></h2>
<p>本文主要从 Go 调度器架构层面上介绍了 G-P-M 模型，通过该模型怎样实现少量内核线程支撑大量 Goroutine 的并发运行。以及通过 NetPoller、sysmon 等帮助 Go 程序减少线程阻塞，充分利用已有的计算资源，从而最大限度提高 Go 程序的运行效率。</p>
<p><strong>参考文档：</strong></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html">https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html">https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html">https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000016038785">https://segmentfault.com/a/1190000016038785</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000016611742">https://segmentfault.com/a/1190000016611742</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000017333717">https://segmentfault.com/a/1190000017333717</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000015352983">https://segmentfault.com/a/1190000015352983</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000015464889">https://segmentfault.com/a/1190000015464889</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/lxmhhy/p/6041001.html">https://www.cnblogs.com/lxmhhy/p/6041001.html</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/mokafamily/p/9975980.html">https://www.cnblogs.com/mokafamily/p/9975980.html</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//studyGolang.com/articles/9211">https://studyGolang.com/articles/9211</a></p>
<p>https://www.zhihu.com/question/20862617</p>
<p><a href="https://link.zhihu.com/?target=https%3A//codeburst.io/why-Goroutines-are-not-lightweight-threads-7c460c1f155f">https://codeburst.io/why-Goroutines-are-not-lightweight-threads-7c460c1f155f</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/tiandyoin/article/details/76556702">https://blog.csdn.net/tiandyoin/article/details/76556702</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/cc3c0fefee43">https://www.jianshu.com/p/cc3c0fefee43</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/a315224886d2">https://www.jianshu.com/p/a315224886d2</a></p>
<p>作者： joellwang，腾讯 CSIG 后台开发工程师</p>
<p>更多精彩，尽在 <a href="https://www.zhihu.com/org/teng-xun-ji-zhu-gong-cheng">腾讯技术</a></p>
]]></content>
    </entry>
</feed>