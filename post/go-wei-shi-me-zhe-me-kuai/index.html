<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="ChicRingo个人博客">
<meta name="description" content="温故而知新">
<meta name="theme-color" content="#000">
<title>Go 为什么这么“快” | ChicRingo个人博客</title>
<link rel="shortcut icon" href="/favicon.ico?v=1597825015761">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





  <meta name="description" content="Go 为什么这么“快”" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>ChicRingo个人博客</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">ChicRingo</p>
    
    <div class="site-description right-motion">
      
        <p id="binft">一条咸鱼</p>
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">3</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">3</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">3</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  

  



  <div style="width: 100%; position: relative;">
    <canvas id="canvasDiyBlock" style="width:100%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
    <script src="/media/js/magic/clock.js"></script>
  </div>

</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%80%8E%E4%B9%88%E8%AE%A9%E6%88%91%E4%BB%AC%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9B%B4%E5%BF%AB"><strong>怎么让我们的系统更快</strong></a></li>
<li><a href="#%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C"><strong>并发 ≠ 并行</strong></a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B"><strong>进程、线程、协程</strong></a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><strong>线程上下文切换</strong></a></li>
<li><a href="#golang-%E4%B8%BA%E5%B9%B6%E5%8F%91%E8%80%8C%E7%94%9F"><strong>Golang 为并发而生</strong></a></li>
<li><a href="#go-%E8%B0%83%E5%BA%A6%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><strong>Go 调度器实现机制：</strong></a></li>
<li><a href="#%E5%B0%8F%E7%BB%93"><strong>小结</strong></a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://ChicRingo.github.io/post/go-wei-shi-me-zhe-me-kuai/">
      Go 为什么这么“快”
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-08-19 10:49:40">2020-08-19</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>13<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>3486<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <blockquote>
<p>本文主要介绍了 Go 程序为了实现极高的并发性能，其内部调度器的实现架构（G-P-M 模型），以及为了最大限度利用计算资源，Go 调度器是如何处理线程阻塞的场景</p>
</blockquote>
<!-- more -->
<h2 id="怎么让我们的系统更快"><strong>怎么让我们的系统更快</strong></h2>
<p>随着信息技术的迅速发展，单台服务器处理能力越来越强，迫使编程模式由从前的串行模式升级到并发模型。</p>
<p>并发模型包含 IO 多路复用、多进程以及多线程，这几种模型都各有优劣，现代复杂的高并发架构大多是几种模型协同使用，不同场景应用不同模型，扬长避短，发挥服务器的最大性能。</p>
<p>而<strong>多线程，因为其轻量和易用</strong>，成为并发编程中使用频率最高的并发模型，包括后衍生的协程等其他子产品，也都基于它。</p>
<h2 id="并发-并行"><strong>并发 ≠ 并行</strong></h2>
<p><strong>并发 (concurrency) 和 并行 ( parallelism) 是不同的。</strong></p>
<p>在单个 CPU 核上，线程通过时间片或者让出控制权来实现任务切换，达到 &quot;同时&quot; 运行多个任务的目的，这就是所谓的并发。但实际上任何时刻都只有一个任务被执行，其他任务通过某种算法来排队。</p>
<p>多核 CPU 可以让同一进程内的 &quot;多个线程&quot; 做到真正意义上的同时运行，这才是并行。</p>
<h2 id="进程-线程-协程"><strong>进程、线程、协程</strong></h2>
<p>进程：进程是系统进行资源分配的基本单位，有独立的内存空间。</p>
<p>线程：线程是 CPU 调度和分派的基本单位，线程依附于进程存在，每个线程会共享父进程的资源。</p>
<p>协程：**协程是一种用户态的轻量级线程，**协程的调度完全由用户控制，协程间切换只需要保存任务的上下文，没有内核的开销。</p>
<h2 id="线程上下文切换"><strong>线程上下文切换</strong></h2>
<p>由于中断处理，多任务处理，用户态切换等原因会导致 CPU 从一个线程切换到另一个线程，切换过程需要保存当前进程的状态并恢复另一个进程的状态。</p>
<p><strong>上下文切换的代价是高昂的</strong>，因为在核心上交换线程会花费很多时间。上下文切换的延迟取决于不同的因素，大概在在 50 到 100 纳秒之间。考虑到硬件平均在每个核心上每纳秒执行 12 条指令，那么一次上下文切换可能会花费 600 到 1200 条指令的延迟时间。实际上，上下文切换占用了大量程序执行指令的时间。</p>
<p>如果存在<strong>跨核上下文切换</strong>（Cross-Core Context Switch），可能会导致 CPU 缓存失效（CPU 从缓存访问数据的成本大约 3 到 40 个时钟周期，从主存访问数据的成本大约 100 到 300 个时钟周期），这种场景的切换成本会更加昂贵。</p>
<h2 id="golang-为并发而生"><strong>Golang 为并发而生</strong></h2>
<p>Golang 从 2009 年正式发布以来，依靠其极高运行速度和高效的开发效率，迅速占据市场份额。Golang 从语言级别支持并发，通过轻量级协程 Goroutine 来实现程序并发运行。</p>
<p><strong>Goroutine 非常轻量</strong>，主要体现在以下两个方面：</p>
<p><strong>上下文切换代价小：</strong> Goroutine 上下文切换只涉及到三个寄存器（PC / SP / DX）的值修改；而对比线程的上下文切换则需要涉及模式切换（从用户态切换到内核态）、以及 16 个寄存器、PC、SP…等寄存器的刷新；</p>
<p><strong>内存占用少：</strong> 线程栈空间通常是 2M，Goroutine 栈空间最小 2K；</p>
<p>Golang 程序中可以轻松支持<strong>10w 级别</strong>的 Goroutine 运行，而线程数量达到 1k 时，内存占用就已经达到 2G。</p>
<h2 id="go-调度器实现机制"><strong>Go 调度器实现机制：</strong></h2>
<p>Go 程序通过调度器来调度**Goroutine 在内核线程上执行，**但是 G</p>
<ul>
<li><em>Goroutine</em>并不直接绑定 OS 线程 M - <em>Machine</em>运行，而是由 Goroutine Scheduler 中的 P - <em>Processor</em> （逻辑处理器）来作获取内核线程资源的『中介』。</li>
</ul>
<p>Go 调度器模型我们通常叫做<strong>G-P-M 模型</strong>，他包括 4 个重要结构，分别是<strong>G、P、M、Sched：</strong></p>
<p>**G:Goroutine，**每个 Goroutine 对应一个 G 结构体，G 存储 Goroutine 的运行堆栈、状态以及任务函数，可重用。</p>
<p>G 并非执行体，每个 G 需要绑定到 P 才能被调度执行。</p>
<p>**P: Processor，**表示逻辑处理器，对 G 来说，P 相当于 CPU 核，G 只有绑定到 P 才能被调度。对 M 来说，P 提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等。</p>
<p>P 的数量决定了系统内最大可并行的 G 的数量（前提：物理 CPU 核数 &gt;= P 的数量）。</p>
<p><strong>P 的数量由用户设置的 GoMAXPROCS 决定，但是不论 GoMAXPROCS 设置为多大，P 的数量最大为 256。</strong></p>
<p>**M: Machine，**OS 内核线程抽象，代表着真正执行计算的资源，在绑定有效的 P 后，进入 schedule 循环；而 schedule 循环的机制大致是从 Global 队列、P 的 Local 队列以及 wait 队列中获取。</p>
<p>**M 的数量是不定的，由 Go Runtime 调整，**为了防止创建过多 OS 线程导致系统调度不过来，目前默认最大限制为 10000 个。</p>
<p>M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。</p>
<p>**Sched：Go 调度器，**它维护有存储 M 和 G 的队列以及调度器的一些状态信息等。</p>
<p>调度器循环的机制大致是从各种队列、P 的本地队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 Goexit 做清理工作并回到 M，如此反复。</p>
<p><strong>理解 M、P、G 三者的关系，可以通过经典的地鼠推车搬砖的模型来说明其三者关系：</strong></p>
<figure data-type="image" tabindex="1"><img src="https://pic3.zhimg.com/80/v2-a27259141ff915578ab5165d75432930_1440w.jpg" alt="img" loading="lazy"></figure>
<p><strong>地鼠(Gopher)的工作任务是：<strong>工地上有若干砖头，地鼠</strong>借助小车</strong>把砖头运送到火种上去烧制。<strong>M 就可以看作图中的地鼠，P 就是小车，G 就是小车里装的砖。</strong></p>
<p>弄清楚了它们三者的关系，下面我们就开始重点聊地鼠是如何在搬运砖块的。</p>
<p><strong>Processor（P）：</strong></p>
<p>根据用户设置的 **GoMAXPROCS **值来创建一批小车(P)。</p>
<p><strong>Goroutine(G)：</strong></p>
<p>通过 Go 关键字就是用来创建一个 Goroutine，也就相当于制造一块砖(G)，然后将这块砖(G)放入当前这辆小车(P)中。</p>
<p><strong>Machine (M)：</strong></p>
<p>地鼠(M)不能通过外部创建出来，只能砖(G)太多了，地鼠(M)又太少了，实在忙不过来，<strong>刚好还有空闲的小车(P)没有使用</strong>，那就从别处再借些地鼠(M)过来直到把小车(P)用完为止。</p>
<p>这里有一个地鼠(M)不够用，从别处借地鼠(M)的过程，这个过程就是创建一个内核线程(M)。</p>
<p>**需要注意的是：**地鼠(M) 如果没有小车(P)是没办法运砖的，<strong>小车(P)的数量决定了能够干活的地鼠(M)数量</strong>，在 Go 程序里面对应的是活动线程数；</p>
<p><strong>在 Go 程序里我们通过下面的图示来展示 G-P-M 模型：</strong></p>
<figure data-type="image" tabindex="2"><img src="https://pic2.zhimg.com/80/v2-a39b9615c2a4dc7fc3a5af9ff93da828_1440w.jpg" alt="img" loading="lazy"></figure>
<p>P 代表可以“并行”运行的逻辑处理器，每个 P 都被分配到一个系统线程 M，G 代表 Go 协程。</p>
<p>Go 调度器中有两个不同的运行队列：<strong>全局运行队列(GRQ)和本地运行队列(LRQ)。</strong></p>
<p>每个 P 都有一个 LRQ，用于管理分配给在 P 的上下文中执行的 Goroutines，这些 Goroutine 轮流被和 P 绑定的 M 进行上下文切换。GRQ 适用于尚未分配给 P 的 Goroutines。</p>
<p>**从上图可以看出，G 的数量可以远远大于 M 的数量，换句话说，Go 程序可以利用少量的内核级线程来支撑大量 Goroutine 的并发。**多个 Goroutine 通过用户级别的上下文切换来共享内核线程 M 的计算资源，但对于操作系统来说并没有线程上下文切换产生的性能损耗。</p>
<p><strong>为了更加充分利用线程的计算资源，Go 调度器采取了以下几种调度策略：</strong></p>
<p><strong>任务窃取（work-stealing）</strong></p>
<p>我们知道，现实情况有的 Goroutine 运行的快，有的慢，那么势必肯定会带来的问题就是，忙的忙死，闲的闲死，Go 肯定不允许摸鱼的 P 存在，势必要充分利用好计算资源。</p>
<p>为了提高 Go 并行处理能力，调高整体处理效率，当每个 P 之间的 G 任务不均衡时，调度器允许从 GRQ，或者其他 P 的 LRQ 中获取 G 执行。</p>
<p><strong>减少阻塞</strong></p>
<p>如果正在执行的 Goroutine 阻塞了线程 M 怎么办？P 上 LRQ 中的 Goroutine 会获取不到调度么？</p>
<p><strong>在 Go 里面阻塞主要分为一下 4 种场景：</strong></p>
<p><strong>场景 1：由于原子、互斥量或通道操作调用导致 Goroutine 阻塞</strong>，调度器将把当前阻塞的 Goroutine 切换出去，重新调度 LRQ 上的其他 Goroutine；</p>
<p><strong>场景 2：由于网络请求和 IO 操作导致 Goroutine 阻塞</strong>，这种阻塞的情况下，我们的 G 和 M 又会怎么做呢？</p>
<p>Go 程序提供了**网络轮询器（NetPoller）**来处理网络请求和 IO 操作的问题，其后台通过 kqueue（MacOS），epoll（Linux）或 iocp（Windows）来实现 IO 多路复用。</p>
<p>通过使用 NetPoller 进行网络系统调用，调度器可以防止 Goroutine 在进行这些系统调用时阻塞 M。这可以让 M 执行 P 的 LRQ 中其他的 Goroutines，而不需要创建新的 M。有助于减少操作系统上的调度负载。</p>
<p>**下图展示它的工作原理：**G1 正在 M 上执行，还有 3 个 Goroutine 在 LRQ 上等待执行。网络轮询器空闲着，什么都没干。</p>
<figure data-type="image" tabindex="3"><img src="https://pic3.zhimg.com/80/v2-b89070ec76ea9aaf4a3b8107e8f1fe84_1440w.jpg" alt="img" loading="lazy"></figure>
<p>接下来，G1 想要进行网络系统调用，因此它被移动到网络轮询器并且处理异步网络系统调用。然后，M 可以从<br>
LRQ 执行另外的 Goroutine。此时，G2 就被上下文切换到 M 上了。</p>
<figure data-type="image" tabindex="4"><img src="https://pic2.zhimg.com/80/v2-62455d37b17ddfe216aa596338cf5e2a_1440w.jpg" alt="img" loading="lazy"></figure>
<p>最后，异步网络系统调用由网络轮询器完成，G1 被移回到 P 的 LRQ 中。一旦 G1 可以在 M 上进行上下文切换，它负责的 Go 相关代码就可以再次执行。这里的最大优势是，执行网络系统调用不需要额外的 M。网络轮询器使用系统线程，它时刻处理一个有效的事件循环。</p>
<figure data-type="image" tabindex="5"><img src="https://pic3.zhimg.com/80/v2-c9237c70726b41ca722e0b4bf883b553_1440w.jpg" alt="img" loading="lazy"></figure>
<p>这种调用方式看起来很复杂，值得庆幸的是，<strong>Go 语言将该“复杂性”隐藏在 Runtime 中</strong>：Go 开发者无需关注 socket 是否是 non-block 的，也无需亲自注册文件描述符的回调，只需在每个连接对应的 Goroutine 中以“block I/O”的方式对待 socket 处理即可，<strong>实现了 goroutine-per-connection 简单的网络编程模式</strong>（但是大量的 Goroutine 也会带来额外的问题，比如栈内存增加和调度器负担加重）。</p>
<p>用户层眼中看到的 Goroutine 中的“block socket”，实际上是通过 Go runtime 中的 netpoller 通过 Non-block socket +<br>
I/O 多路复用机制“模拟”出来的。Go 中的 net 库正是按照这方式实现的。</p>
<p>**场景 3：**当调用一些系统方法的时候，如果系统方法调用的时候发生阻塞，这种情况下，网络轮询器（NetPoller）无法使用，而进行系统调用的 Goroutine 将阻塞当前 M。</p>
<p>让我们来看看同步系统调用（如文件 I/O）会导致 M 阻塞的情况：G1 将进行同步系统调用以阻塞 M1。</p>
<figure data-type="image" tabindex="6"><img src="https://picb.zhimg.com/80/v2-bc3e58a8f34c24c0229a4add669a3e52_1440w.jpg" alt="img" loading="lazy"></figure>
<p>调度器介入后：识别出 G1 已导致 M1 阻塞，此时，调度器将 M1 与 P 分离，同时也将 G1 带走。然后调度器引入新的 M2 来服务 P。此时，可以从 LRQ 中选择 G2 并在 M2 上进行上下文切换。</p>
<figure data-type="image" tabindex="7"><img src="https://picb.zhimg.com/80/v2-9875a8b04b3653e0da8e0794dea7035e_1440w.jpg" alt="img" loading="lazy"></figure>
<p>阻塞的系统调用完成后：G1 可以移回 LRQ 并再次由 P 执行。如果这种情况再次发生，M1 将被放在旁边以备将来重复使用**。**</p>
<figure data-type="image" tabindex="8"><img src="https://picb.zhimg.com/80/v2-c0398b611bfcbe16309882a9a59c39d7_1440w.jpg" alt="img" loading="lazy"></figure>
<p>**场景 4：**如果在 Goroutine 去执行一个 sleep 操作，导致 M 被阻塞了。</p>
<p>Go 程序后台有一个监控线程 sysmon，它监控那些长时间运行的 G 任务然后设置可以强占的标识符，别的 Goroutine 就可以抢先进来执行。</p>
<p>只要下次这个 Goroutine 进行函数调用，那么就会被强占，同时也会保护现场，然后重新放入 P 的本地队列里面等待下次执行。</p>
<h2 id="小结"><strong>小结</strong></h2>
<p>本文主要从 Go 调度器架构层面上介绍了 G-P-M 模型，通过该模型怎样实现少量内核线程支撑大量 Goroutine 的并发运行。以及通过 NetPoller、sysmon 等帮助 Go 程序减少线程阻塞，充分利用已有的计算资源，从而最大限度提高 Go 程序的运行效率。</p>
<p><strong>参考文档：</strong></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html">https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html">https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html">https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000016038785">https://segmentfault.com/a/1190000016038785</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000016611742">https://segmentfault.com/a/1190000016611742</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000017333717">https://segmentfault.com/a/1190000017333717</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000015352983">https://segmentfault.com/a/1190000015352983</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000015464889">https://segmentfault.com/a/1190000015464889</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/lxmhhy/p/6041001.html">https://www.cnblogs.com/lxmhhy/p/6041001.html</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/mokafamily/p/9975980.html">https://www.cnblogs.com/mokafamily/p/9975980.html</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//studyGolang.com/articles/9211">https://studyGolang.com/articles/9211</a></p>
<p>https://www.zhihu.com/question/20862617</p>
<p><a href="https://link.zhihu.com/?target=https%3A//codeburst.io/why-Goroutines-are-not-lightweight-threads-7c460c1f155f">https://codeburst.io/why-Goroutines-are-not-lightweight-threads-7c460c1f155f</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/tiandyoin/article/details/76556702">https://blog.csdn.net/tiandyoin/article/details/76556702</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/cc3c0fefee43">https://www.jianshu.com/p/cc3c0fefee43</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/a315224886d2">https://www.jianshu.com/p/a315224886d2</a></p>
<p>作者： joellwang，腾讯 CSIG 后台开发工程师</p>
<p>更多精彩，尽在 <a href="https://www.zhihu.com/org/teng-xun-ji-zhu-gong-cheng">腾讯技术</a></p>
<p>转自<a href="https://zhuanlan.zhihu.com/p/111346689">知乎：Go为什么这么“快”</a></p>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      ChicRingo
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://ChicRingo.github.io/post/go-wei-shi-me-zhe-me-kuai/" title="Go 为什么这么“快”">https://ChicRingo.github.io/post/go-wei-shi-me-zhe-me-kuai/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Golang 中 range 的坑" href="https://ChicRingo.github.io/post/golang-zhong-range-de-keng/">Golang 中 range 的坑</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Golang 中 range 的坑" href="https://ChicRingo.github.io/post/golang-zhong-range-de-keng/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="Golang面试题，待更新" href="https://ChicRingo.github.io/post/golang-mian-shi-ti/">Golang面试题，待更新</a>
        <a class="nav-mobile-next" title="Golang面试题，待更新" href="https://ChicRingo.github.io/post/golang-mian-shi-ti/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 5px;bottom: px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'tororo'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'aoba') {
				AIimgSrc.push(message_Path + "model/aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'aoba') {
							model = message_Path + "model/aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'true'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px;border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ChicRingo.github.io/post/golang-zhong-range-de-keng/"" data-c="
          &lt;h2 id=&#34;使用-range-迭代遍历数组&#34;&gt;使用 range 迭代遍历数组&lt;/h2&gt;
&lt;p&gt;range 会复制对象，而不是不是直接在原对象上操作。&lt;/p&gt;
&lt;p&gt;示例一：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    a := [3]int{1, 2, 3}
    for _, v := range a { // 复制一份a遍历[1, 2, 3]
        v += 100 // v是复制对象中的值，不会改变a数组元素的值
    }
    fmt.Println(a) // 1 2 3
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例二：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    a := [3]int{1, 2, 3}
    for i, v := range a { // i,v从a复制的对象里提取出
        if i == 0 {
            a[1], a[2] = 200, 300
            fmt.Println(a) // 输出[1 200 300]
        }
        a[i] = v + 100 // v是复制对象里的元素[1, 2, 3]
    }
    fmt.Println(a) // 输出[101, 102, 103]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;[1 200 300]
[101 102 103]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用-range-迭代遍历切片&#34;&gt;使用 range 迭代遍历切片&lt;/h2&gt;
&lt;p&gt;range迭代遍历引用类型时，底层的数据不会被复制：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    a := []int{1, 2, 3} // 改成slice
    for i, v := range a {
        if i == 0 {
            a[1], a[2] = 200, 300
            fmt.Println(a) // [1 200 300]
        }
        a[i] = v + 100
    }
    fmt.Println(a) // 输出[101 300 400]
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;[1 200 300]
[101 300 400]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为切片的内部结构为struct slice{*point, len, cap}。&lt;/p&gt;
&lt;p&gt;数据部分是一个指针，指向地址，复制对象的时候只是把指针的值复制了，而不是重新拷贝一块新的内存再把值放进去，所以修改的时候还是修改的原来的值。&lt;/p&gt;
">Golang 中 range 的坑</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ChicRingo.github.io/post/go-wei-shi-me-zhe-me-kuai/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;本文主要介绍了 Go 程序为了实现极高的并发性能，其内部调度器的实现架构（G-P-M 模型），以及为了最大限度利用计算资源，Go 调度器是如何处理线程阻塞的场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;怎么让我们的系统更快&#34;&gt;&lt;strong&gt;怎么让我们的系统更快&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;随着信息技术的迅速发展，单台服务器处理能力越来越强，迫使编程模式由从前的串行模式升级到并发模型。&lt;/p&gt;
&lt;p&gt;并发模型包含 IO 多路复用、多进程以及多线程，这几种模型都各有优劣，现代复杂的高并发架构大多是几种模型协同使用，不同场景应用不同模型，扬长避短，发挥服务器的最大性能。&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;多线程，因为其轻量和易用&lt;/strong&gt;，成为并发编程中使用频率最高的并发模型，包括后衍生的协程等其他子产品，也都基于它。&lt;/p&gt;
&lt;h2 id=&#34;并发-并行&#34;&gt;&lt;strong&gt;并发 ≠ 并行&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;并发 (concurrency) 和 并行 ( parallelism) 是不同的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在单个 CPU 核上，线程通过时间片或者让出控制权来实现任务切换，达到 &amp;quot;同时&amp;quot; 运行多个任务的目的，这就是所谓的并发。但实际上任何时刻都只有一个任务被执行，其他任务通过某种算法来排队。&lt;/p&gt;
&lt;p&gt;多核 CPU 可以让同一进程内的 &amp;quot;多个线程&amp;quot; 做到真正意义上的同时运行，这才是并行。&lt;/p&gt;
&lt;h2 id=&#34;进程-线程-协程&#34;&gt;&lt;strong&gt;进程、线程、协程&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;进程：进程是系统进行资源分配的基本单位，有独立的内存空间。&lt;/p&gt;
&lt;p&gt;线程：线程是 CPU 调度和分派的基本单位，线程依附于进程存在，每个线程会共享父进程的资源。&lt;/p&gt;
&lt;p&gt;协程：**协程是一种用户态的轻量级线程，**协程的调度完全由用户控制，协程间切换只需要保存任务的上下文，没有内核的开销。&lt;/p&gt;
&lt;h2 id=&#34;线程上下文切换&#34;&gt;&lt;strong&gt;线程上下文切换&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;由于中断处理，多任务处理，用户态切换等原因会导致 CPU 从一个线程切换到另一个线程，切换过程需要保存当前进程的状态并恢复另一个进程的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文切换的代价是高昂的&lt;/strong&gt;，因为在核心上交换线程会花费很多时间。上下文切换的延迟取决于不同的因素，大概在在 50 到 100 纳秒之间。考虑到硬件平均在每个核心上每纳秒执行 12 条指令，那么一次上下文切换可能会花费 600 到 1200 条指令的延迟时间。实际上，上下文切换占用了大量程序执行指令的时间。&lt;/p&gt;
&lt;p&gt;如果存在&lt;strong&gt;跨核上下文切换&lt;/strong&gt;（Cross-Core Context Switch），可能会导致 CPU 缓存失效（CPU 从缓存访问数据的成本大约 3 到 40 个时钟周期，从主存访问数据的成本大约 100 到 300 个时钟周期），这种场景的切换成本会更加昂贵。&lt;/p&gt;
&lt;h2 id=&#34;golang-为并发而生&#34;&gt;&lt;strong&gt;Golang 为并发而生&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Golang 从 2009 年正式发布以来，依靠其极高运行速度和高效的开发效率，迅速占据市场份额。Golang 从语言级别支持并发，通过轻量级协程 Goroutine 来实现程序并发运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Goroutine 非常轻量&lt;/strong&gt;，主要体现在以下两个方面：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文切换代价小：&lt;/strong&gt; Goroutine 上下文切换只涉及到三个寄存器（PC / SP / DX）的值修改；而对比线程的上下文切换则需要涉及模式切换（从用户态切换到内核态）、以及 16 个寄存器、PC、SP…等寄存器的刷新；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存占用少：&lt;/strong&gt; 线程栈空间通常是 2M，Goroutine 栈空间最小 2K；&lt;/p&gt;
&lt;p&gt;Golang 程序中可以轻松支持&lt;strong&gt;10w 级别&lt;/strong&gt;的 Goroutine 运行，而线程数量达到 1k 时，内存占用就已经达到 2G。&lt;/p&gt;
&lt;h2 id=&#34;go-调度器实现机制&#34;&gt;&lt;strong&gt;Go 调度器实现机制：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Go 程序通过调度器来调度**Goroutine 在内核线程上执行，**但是 G&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Goroutine&lt;/em&gt;并不直接绑定 OS 线程 M - &lt;em&gt;Machine&lt;/em&gt;运行，而是由 Goroutine Scheduler 中的 P - &lt;em&gt;Processor&lt;/em&gt; （逻辑处理器）来作获取内核线程资源的『中介』。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Go 调度器模型我们通常叫做&lt;strong&gt;G-P-M 模型&lt;/strong&gt;，他包括 4 个重要结构，分别是&lt;strong&gt;G、P、M、Sched：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**G:Goroutine，**每个 Goroutine 对应一个 G 结构体，G 存储 Goroutine 的运行堆栈、状态以及任务函数，可重用。&lt;/p&gt;
&lt;p&gt;G 并非执行体，每个 G 需要绑定到 P 才能被调度执行。&lt;/p&gt;
&lt;p&gt;**P: Processor，**表示逻辑处理器，对 G 来说，P 相当于 CPU 核，G 只有绑定到 P 才能被调度。对 M 来说，P 提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等。&lt;/p&gt;
&lt;p&gt;P 的数量决定了系统内最大可并行的 G 的数量（前提：物理 CPU 核数 &amp;gt;= P 的数量）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P 的数量由用户设置的 GoMAXPROCS 决定，但是不论 GoMAXPROCS 设置为多大，P 的数量最大为 256。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**M: Machine，**OS 内核线程抽象，代表着真正执行计算的资源，在绑定有效的 P 后，进入 schedule 循环；而 schedule 循环的机制大致是从 Global 队列、P 的 Local 队列以及 wait 队列中获取。&lt;/p&gt;
&lt;p&gt;**M 的数量是不定的，由 Go Runtime 调整，**为了防止创建过多 OS 线程导致系统调度不过来，目前默认最大限制为 10000 个。&lt;/p&gt;
&lt;p&gt;M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。&lt;/p&gt;
&lt;p&gt;**Sched：Go 调度器，**它维护有存储 M 和 G 的队列以及调度器的一些状态信息等。&lt;/p&gt;
&lt;p&gt;调度器循环的机制大致是从各种队列、P 的本地队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 Goexit 做清理工作并回到 M，如此反复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;理解 M、P、G 三者的关系，可以通过经典的地鼠推车搬砖的模型来说明其三者关系：&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/80/v2-a27259141ff915578ab5165d75432930_1440w.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;地鼠(Gopher)的工作任务是：&lt;strong&gt;工地上有若干砖头，地鼠&lt;/strong&gt;借助小车&lt;/strong&gt;把砖头运送到火种上去烧制。&lt;strong&gt;M 就可以看作图中的地鼠，P 就是小车，G 就是小车里装的砖。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;弄清楚了它们三者的关系，下面我们就开始重点聊地鼠是如何在搬运砖块的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Processor（P）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据用户设置的 **GoMAXPROCS **值来创建一批小车(P)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Goroutine(G)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 Go 关键字就是用来创建一个 Goroutine，也就相当于制造一块砖(G)，然后将这块砖(G)放入当前这辆小车(P)中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Machine (M)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;地鼠(M)不能通过外部创建出来，只能砖(G)太多了，地鼠(M)又太少了，实在忙不过来，&lt;strong&gt;刚好还有空闲的小车(P)没有使用&lt;/strong&gt;，那就从别处再借些地鼠(M)过来直到把小车(P)用完为止。&lt;/p&gt;
&lt;p&gt;这里有一个地鼠(M)不够用，从别处借地鼠(M)的过程，这个过程就是创建一个内核线程(M)。&lt;/p&gt;
&lt;p&gt;**需要注意的是：**地鼠(M) 如果没有小车(P)是没办法运砖的，&lt;strong&gt;小车(P)的数量决定了能够干活的地鼠(M)数量&lt;/strong&gt;，在 Go 程序里面对应的是活动线程数；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 Go 程序里我们通过下面的图示来展示 G-P-M 模型：&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/80/v2-a39b9615c2a4dc7fc3a5af9ff93da828_1440w.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;P 代表可以“并行”运行的逻辑处理器，每个 P 都被分配到一个系统线程 M，G 代表 Go 协程。&lt;/p&gt;
&lt;p&gt;Go 调度器中有两个不同的运行队列：&lt;strong&gt;全局运行队列(GRQ)和本地运行队列(LRQ)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个 P 都有一个 LRQ，用于管理分配给在 P 的上下文中执行的 Goroutines，这些 Goroutine 轮流被和 P 绑定的 M 进行上下文切换。GRQ 适用于尚未分配给 P 的 Goroutines。&lt;/p&gt;
&lt;p&gt;**从上图可以看出，G 的数量可以远远大于 M 的数量，换句话说，Go 程序可以利用少量的内核级线程来支撑大量 Goroutine 的并发。**多个 Goroutine 通过用户级别的上下文切换来共享内核线程 M 的计算资源，但对于操作系统来说并没有线程上下文切换产生的性能损耗。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了更加充分利用线程的计算资源，Go 调度器采取了以下几种调度策略：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任务窃取（work-stealing）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道，现实情况有的 Goroutine 运行的快，有的慢，那么势必肯定会带来的问题就是，忙的忙死，闲的闲死，Go 肯定不允许摸鱼的 P 存在，势必要充分利用好计算资源。&lt;/p&gt;
&lt;p&gt;为了提高 Go 并行处理能力，调高整体处理效率，当每个 P 之间的 G 任务不均衡时，调度器允许从 GRQ，或者其他 P 的 LRQ 中获取 G 执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减少阻塞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果正在执行的 Goroutine 阻塞了线程 M 怎么办？P 上 LRQ 中的 Goroutine 会获取不到调度么？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 Go 里面阻塞主要分为一下 4 种场景：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 1：由于原子、互斥量或通道操作调用导致 Goroutine 阻塞&lt;/strong&gt;，调度器将把当前阻塞的 Goroutine 切换出去，重新调度 LRQ 上的其他 Goroutine；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景 2：由于网络请求和 IO 操作导致 Goroutine 阻塞&lt;/strong&gt;，这种阻塞的情况下，我们的 G 和 M 又会怎么做呢？&lt;/p&gt;
&lt;p&gt;Go 程序提供了**网络轮询器（NetPoller）**来处理网络请求和 IO 操作的问题，其后台通过 kqueue（MacOS），epoll（Linux）或 iocp（Windows）来实现 IO 多路复用。&lt;/p&gt;
&lt;p&gt;通过使用 NetPoller 进行网络系统调用，调度器可以防止 Goroutine 在进行这些系统调用时阻塞 M。这可以让 M 执行 P 的 LRQ 中其他的 Goroutines，而不需要创建新的 M。有助于减少操作系统上的调度负载。&lt;/p&gt;
&lt;p&gt;**下图展示它的工作原理：**G1 正在 M 上执行，还有 3 个 Goroutine 在 LRQ 上等待执行。网络轮询器空闲着，什么都没干。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/80/v2-b89070ec76ea9aaf4a3b8107e8f1fe84_1440w.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;接下来，G1 想要进行网络系统调用，因此它被移动到网络轮询器并且处理异步网络系统调用。然后，M 可以从&lt;br&gt;
LRQ 执行另外的 Goroutine。此时，G2 就被上下文切换到 M 上了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/80/v2-62455d37b17ddfe216aa596338cf5e2a_1440w.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;最后，异步网络系统调用由网络轮询器完成，G1 被移回到 P 的 LRQ 中。一旦 G1 可以在 M 上进行上下文切换，它负责的 Go 相关代码就可以再次执行。这里的最大优势是，执行网络系统调用不需要额外的 M。网络轮询器使用系统线程，它时刻处理一个有效的事件循环。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/80/v2-c9237c70726b41ca722e0b4bf883b553_1440w.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这种调用方式看起来很复杂，值得庆幸的是，&lt;strong&gt;Go 语言将该“复杂性”隐藏在 Runtime 中&lt;/strong&gt;：Go 开发者无需关注 socket 是否是 non-block 的，也无需亲自注册文件描述符的回调，只需在每个连接对应的 Goroutine 中以“block I/O”的方式对待 socket 处理即可，&lt;strong&gt;实现了 goroutine-per-connection 简单的网络编程模式&lt;/strong&gt;（但是大量的 Goroutine 也会带来额外的问题，比如栈内存增加和调度器负担加重）。&lt;/p&gt;
&lt;p&gt;用户层眼中看到的 Goroutine 中的“block socket”，实际上是通过 Go runtime 中的 netpoller 通过 Non-block socket +&lt;br&gt;
I/O 多路复用机制“模拟”出来的。Go 中的 net 库正是按照这方式实现的。&lt;/p&gt;
&lt;p&gt;**场景 3：**当调用一些系统方法的时候，如果系统方法调用的时候发生阻塞，这种情况下，网络轮询器（NetPoller）无法使用，而进行系统调用的 Goroutine 将阻塞当前 M。&lt;/p&gt;
&lt;p&gt;让我们来看看同步系统调用（如文件 I/O）会导致 M 阻塞的情况：G1 将进行同步系统调用以阻塞 M1。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://picb.zhimg.com/80/v2-bc3e58a8f34c24c0229a4add669a3e52_1440w.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;调度器介入后：识别出 G1 已导致 M1 阻塞，此时，调度器将 M1 与 P 分离，同时也将 G1 带走。然后调度器引入新的 M2 来服务 P。此时，可以从 LRQ 中选择 G2 并在 M2 上进行上下文切换。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://picb.zhimg.com/80/v2-9875a8b04b3653e0da8e0794dea7035e_1440w.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;阻塞的系统调用完成后：G1 可以移回 LRQ 并再次由 P 执行。如果这种情况再次发生，M1 将被放在旁边以备将来重复使用**。**&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://picb.zhimg.com/80/v2-c0398b611bfcbe16309882a9a59c39d7_1440w.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;**场景 4：**如果在 Goroutine 去执行一个 sleep 操作，导致 M 被阻塞了。&lt;/p&gt;
&lt;p&gt;Go 程序后台有一个监控线程 sysmon，它监控那些长时间运行的 G 任务然后设置可以强占的标识符，别的 Goroutine 就可以抢先进来执行。&lt;/p&gt;
&lt;p&gt;只要下次这个 Goroutine 进行函数调用，那么就会被强占，同时也会保护现场，然后重新放入 P 的本地队列里面等待下次执行。&lt;/p&gt;
&lt;h2 id=&#34;小结&#34;&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;本文主要从 Go 调度器架构层面上介绍了 G-P-M 模型，通过该模型怎样实现少量内核线程支撑大量 Goroutine 的并发运行。以及通过 NetPoller、sysmon 等帮助 Go 程序减少线程阻塞，充分利用已有的计算资源，从而最大限度提高 Go 程序的运行效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考文档：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html&#34;&gt;https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html&#34;&gt;https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html&#34;&gt;https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000016038785&#34;&gt;https://segmentfault.com/a/1190000016038785&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000016611742&#34;&gt;https://segmentfault.com/a/1190000016611742&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000017333717&#34;&gt;https://segmentfault.com/a/1190000017333717&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000015352983&#34;&gt;https://segmentfault.com/a/1190000015352983&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000015464889&#34;&gt;https://segmentfault.com/a/1190000015464889&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//www.cnblogs.com/lxmhhy/p/6041001.html&#34;&gt;https://www.cnblogs.com/lxmhhy/p/6041001.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//www.cnblogs.com/mokafamily/p/9975980.html&#34;&gt;https://www.cnblogs.com/mokafamily/p/9975980.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//studyGolang.com/articles/9211&#34;&gt;https://studyGolang.com/articles/9211&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;https://www.zhihu.com/question/20862617&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//codeburst.io/why-Goroutines-are-not-lightweight-threads-7c460c1f155f&#34;&gt;https://codeburst.io/why-Goroutines-are-not-lightweight-threads-7c460c1f155f&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//blog.csdn.net/tiandyoin/article/details/76556702&#34;&gt;https://blog.csdn.net/tiandyoin/article/details/76556702&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/cc3c0fefee43&#34;&gt;https://www.jianshu.com/p/cc3c0fefee43&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/a315224886d2&#34;&gt;https://www.jianshu.com/p/a315224886d2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者： joellwang，腾讯 CSIG 后台开发工程师&lt;/p&gt;
&lt;p&gt;更多精彩，尽在 &lt;a href=&#34;https://www.zhihu.com/org/teng-xun-ji-zhu-gong-cheng&#34;&gt;腾讯技术&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转自&lt;a href=&#34;https://zhuanlan.zhihu.com/p/111346689&#34;&gt;知乎：Go为什么这么“快”&lt;/a&gt;&lt;/p&gt;
">Go 为什么这么“快”</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ChicRingo.github.io/post/golang-mian-shi-ti/"" data-c="
          &lt;ol&gt;
&lt;li&gt;
&lt;h2 id=&#34;go的goroutine为什么快&#34;&gt;go的goroutine为什么快&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Goroutine 非常轻量&lt;/strong&gt;，主要体现在以下两个方面：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上下文切换代价小：&lt;/strong&gt; Goroutine 上下文切换只涉及到三个寄存器（PC / SP / DX）的值修改；而对比线程的上下文切换则需要涉及模式切换（从用户态切换到内核态）、以及 16 个寄存器、PC、SP…等寄存器的刷新；&lt;/p&gt;
&lt;p&gt;**内存占用少：**线程栈空间通常是 2M，Goroutine 栈空间最小 2K；&lt;/p&gt;
&lt;p&gt;Golang 程序中可以轻松支持&lt;strong&gt;10w 级别&lt;/strong&gt;的 Goroutine 运行，而线程数量达到 1k 时，内存占用就已经达到 2G。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 Go 程序里我们通过下面的图示来展示 G-P-M 模型：&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/80/v2-a39b9615c2a4dc7fc3a5af9ff93da828_1440w.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;P 代表可以“并行”运行的逻辑处理器，每个 P 都被分配到一个系统线程 M，G 代表 Go 协程。&lt;/p&gt;
&lt;p&gt;Go 调度器中有两个不同的运行队列：&lt;strong&gt;全局运行队列(GRQ)和本地运行队列(LRQ)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个 P 都有一个 LRQ，用于管理分配给在 P 的上下文中执行的 Goroutines，这些 Goroutine 轮流被和 P 绑定的 M 进行上下文切换。GRQ 适用于尚未分配给 P 的 Goroutines。&lt;/p&gt;
&lt;p&gt;**从上图可以看出，G 的数量可以远远大于 M 的数量，换句话说，Go 程序可以利用少量的内核级线程来支撑大量 Goroutine 的并发。**多个 Goroutine 通过用户级别的上下文切换来共享内核线程 M 的计算资源，但对于操作系统来说并没有线程上下文切换产生的性能损耗。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/111346689&#34;&gt;Go 为什么这么“快”&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;红黑树的特点&#34;&gt;红黑树的特点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4 id=&#34;&#34;&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;每个节点非红即黑；&lt;/li&gt;
&lt;li&gt;根节点总是黑色的；&lt;/li&gt;
&lt;li&gt;每个叶子节点都是黑色的空节点（NIL节点）；&lt;/li&gt;
&lt;li&gt;如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；&lt;/li&gt;
&lt;li&gt;从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2017/12/6/1602b6016e143cf3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;红黑树的应用&#34;&gt;红黑树的应用：&lt;/h5&gt;
&lt;p&gt;TreeMap、TreeSet以及JAVA8的HashMap底层都用到了红黑树。&lt;/p&gt;
&lt;h5 id=&#34;红黑树自平衡调整方法&#34;&gt;红黑树自平衡调整方法：&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;变色&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;变色仅仅指的是红黑树节点的变色。因为红黑树节点必须是【红】或者【黑】这两中颜色，所以变色只是将当前的节点颜色进行变化，以满足特性（2，3，4，5）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;旋转&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;左旋操作动画（更加容易理解和记忆）：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20191224152932810.gif&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;/*************对红黑树节点x进行左旋操作 ******************/
/* 左旋示意图：对节点x进行左旋 
 *     p                       p 
 *    /                       / 
 *   x                       y 
 *  / \                     / \ 
 * lx  y      -----&amp;gt;       x  ry 
 *    / \                 / \ 
 *   ly ry               lx ly 
 * 左旋做了三件事： 
 * 1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时) 
 * 2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右) 
 * 3. 将y的左子节点设为x，将x的父节点设为y 
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;左旋操作动画&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20191224153029893.gif&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;/*************对红黑树节点y进行右旋操作 ******************/
/* 右旋示意图：对节点y进行右旋
 *        p                   p
 *       /                   /
 *      y                   x
 *     / \                 / \
 *    x  ry   -----&amp;gt;      lx  y
 *   / \                     / \
 * lx  rx                   rx ry
 * 右旋做了三件事：
 * 1. 将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时)
 * 2. 将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右)
 * 3. 将x的右子节点设为y，将y的父节点设为x
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h4 id=&#34;延伸为什么着色成红色而不是黑色呢为什么呢&#34;&gt;延伸：为什么着色成红色，而不是黑色呢？为什么呢？&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;红黑树节点的添加&#34;&gt;红黑树节点的添加&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;红黑树的第 5 条特征规定，任一节点到它子树的每个叶子节点的路径中都包含同样数量的黑节点。也就是说当我们往红黑树中插入一个黑色节点时，会违背这条特征。&lt;/li&gt;
&lt;li&gt;同时第 4 条特征规定红色节点的左右孩子一定都是黑色节点，&lt;strong&gt;有可能&lt;/strong&gt;当我们给一个红色节点下插入一个红色节点时，会违背这条特征。&lt;/li&gt;
&lt;li&gt;因此我们需要在插入黑色节点后进行结构调整，保证红黑树始终满足这 5 条特征。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;红黑树插入后节点的调整思想&#34;&gt;红黑树插入后节点的调整思想&lt;/h5&gt;
&lt;p&gt;我们插入黑色节点的时候担心违背第5条，插入红色节点时担心违背第4条，所以我们将将插入的节点&lt;strong&gt;改为红色&lt;/strong&gt;，然后判断插入的节点的父亲是不是红色，是的话进行修改调整（变色、左旋、右旋）。同时在调整的过程中我们需要遵守&lt;code&gt;5条特性&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;为什么要用红黑树？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。详细了解可以查看 &lt;a href=&#34;https://juejin.im/post/5a27c6946fb9a04509096248&#34;&gt;漫画：什么是红黑树？&lt;/a&gt;（也介绍到了二叉查找树，非常推荐）&lt;/p&gt;
&lt;p&gt;推荐文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5a27c6946fb9a04509096248&#34;&gt;漫画：什么是红黑树？&lt;/a&gt;（也介绍到了二叉查找树，非常推荐）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dandanlove.com/2018/03/18/red-black-tree/&#34;&gt;寻找红黑树的操作手册&lt;/a&gt;（文章排版以及思路真的不错）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/24367771&#34;&gt;红黑树深入剖析及Java实现&lt;/a&gt;（美团点评技术团队）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;二叉树的特点&#34;&gt;二叉树的特点&lt;/h2&gt;
&lt;p&gt;只有一个根节点，每个非根节点只有一个父节点&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;叉树节点的子节点最多只能有两个&lt;/li&gt;
&lt;li&gt;二叉树有左右之分&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91&#34;&gt;二叉树&lt;/a&gt;（百度百科）&lt;/p&gt;
&lt;p&gt;(1)&lt;a href=&#34;https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91&#34;&gt;完全二叉树&lt;/a&gt;——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树，不需要填满二叉树，比如&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/frMsQia9rIXMyK0XoJlebciaYSDzrnHZib0w1jouSiaF0uibq7XZbKg6SOyKcNXJOgq9hOB1NegL0rttWEvXcSFxELA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;(2)&lt;a href=&#34;https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91&#34;&gt;满二叉树&lt;/a&gt;——除了叶结点外，每一个结点都有左右子叶，且叶子结点都处在最底层的二叉树。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/frMsQia9rIXNbNiaBaYCDOdWLXFNLmPSWf9CibibBs6u2GPyUib0or10qwUZQD0V6IicJlhnPhEYopDLLuAuJ1IutZww/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;(3)&lt;a href=&#34;https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/10421057&#34;&gt;平衡二叉树&lt;/a&gt;——平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树，或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。&lt;/p&gt;
&lt;h5 id=&#34;二叉查找树bst具备什么特性呢&#34;&gt;二叉查找树（BST）具备什么特性呢？&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;左&lt;/strong&gt;子树上所有结点的值均&lt;strong&gt;小于或等于&lt;/strong&gt;它的根结点的值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;右&lt;/strong&gt;子树上所有结点的值均&lt;strong&gt;大于或等于&lt;/strong&gt;它的根结点的值。&lt;/li&gt;
&lt;li&gt;左、右子树也分别为二叉排序树。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺陷：有可能会变成线性&lt;/p&gt;
&lt;p&gt;下图中这棵树，就是一颗典型的二叉查找树：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2017/12/6/1602b600eb27d6ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;堆&#34;&gt;堆&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_33186366/article/details/51876191&#34;&gt;数据结构之堆的定义&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;如何快速建立一个平衡二叉树&#34;&gt;如何快速建立一个平衡二叉树&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91&#34;&gt;平衡二叉树&lt;/a&gt;（百度百科，平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任意节点的左右子树的高度差都小于等于1。&lt;/li&gt;
&lt;li&gt;找最低失衡节点，那就是找从最底层（叶子节点层）往最高层（root层）中最先出现左右子树高度差大于1的节点。&lt;/li&gt;
&lt;li&gt;找替代节点就是找极值点，如果是左子树失衡，那就找左子树中的最大值，因为当左子树失衡时就表示我们不需要处理右子树，所以找到左子树的最大值，之后把右子树赋给该节点的右子节点即可。&lt;/li&gt;
&lt;li&gt;同理，如果是右子树失衡那就找右子树中的最小值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;平衡二叉树的特点&#34;&gt;平衡二叉树的特点&lt;/h2&gt;
&lt;p&gt;任意节点的左右子树的高度差都小于等于1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;树的层序遍历&#34;&gt;树的层序遍历&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;判断树是否左右对称或数组是否左右对称&#34;&gt;判断树是否左右对称或数组是否左右对称&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;linux常用命令&#34;&gt;Linux常用命令&lt;/h2&gt;
&lt;h5 id=&#34;目录切换命令&#34;&gt;目录切换命令&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;cd usr&lt;/code&gt;：&lt;/strong&gt; 切换到该目录下usr目录&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;cd ..（或cd../）&lt;/code&gt;：&lt;/strong&gt; 切换到上一层目录&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;cd /&lt;/code&gt;：&lt;/strong&gt; 切换到系统根目录&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;cd ~&lt;/code&gt;：&lt;/strong&gt; 切换到用户主目录&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;cd -&lt;/code&gt;：&lt;/strong&gt; 切换到上一个操作所在目录&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;目录的操作命令增删改查&#34;&gt;目录的操作命令(增删改查)&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;mkdir 目录名称&lt;/code&gt;：&lt;/strong&gt; 增加目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ls或者ll&lt;/code&gt;&lt;/strong&gt;（ll是ls -l的别名，ll命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;find 目录 参数&lt;/code&gt;：&lt;/strong&gt; 寻找目录（查）&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列出当前目录及子目录下所有文件和文件夹: &lt;code&gt;find .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;/home&lt;/code&gt;目录下查找以.txt结尾的文件名:&lt;code&gt;find /home -name &amp;quot;*.txt&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;同上，但忽略大小写: &lt;code&gt;find /home -iname &amp;quot;*.txt&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当前目录及子目录下查找所有以.txt和.pdf结尾的文件:&lt;code&gt;find . \( -name &amp;quot;*.txt&amp;quot; -o -name &amp;quot;*.pdf&amp;quot; \)&lt;/code&gt;或&lt;code&gt;find . -name &amp;quot;*.txt&amp;quot; -o -name &amp;quot;*.pdf&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;mv 目录名称 新目录名称&lt;/code&gt;：&lt;/strong&gt; 修改目录的名称（改）&lt;/p&gt;
&lt;p&gt;注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;mv 目录名称 目录的新位置&lt;/code&gt;：&lt;/strong&gt; 移动目录的位置---剪切（改）&lt;/p&gt;
&lt;p&gt;注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;cp -r 目录名称 目录拷贝的目标位置&lt;/code&gt;：&lt;/strong&gt; 拷贝目录（改），-r代表递归拷贝&lt;/p&gt;
&lt;p&gt;注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;rm [-rf] 目录&lt;/code&gt;:&lt;/strong&gt; 删除目录（删）&lt;/p&gt;
&lt;p&gt;注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用&lt;code&gt;rm -rf&lt;/code&gt; 目录/文件/压缩包&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;http状态码&#34;&gt;http状态码&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E7%8A%B6%E6%80%81%E7%A0%81.png&#34; alt=&#34;状态码&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;常见的状态码有200,301,302,304,404,500,403。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;200&lt;/strong&gt;：最常见，表示服务器响应成功，服务器找到了客户端请求的内容，并将内容发送给了客户端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;500&lt;/strong&gt;：比较常见，表示程序错误，就是说请求的网页程序本身就报错了。现在的浏览器会对状态码500做出一定的处理，所以在一般情况下会返回一个定制的错误页面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;502&lt;/strong&gt;：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效响应，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;504&lt;/strong&gt;：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;400&lt;/strong&gt;：为包含语法错误，无法被服务器解析&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;403&lt;/strong&gt;：为服务器已经接收请求，但是被拒绝执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;404&lt;/strong&gt;：服务器上没有该资源，或者说是服务器上没有找到客户端请求的资源，是最常见的请求错误码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;301&lt;/strong&gt;：临时跳转。url地址a可以向url地址b上跳转，但这并不意味着是永久性的，有可能过短时间就从url地址a跳转到地址c。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;302&lt;/strong&gt;：永久性的重定向。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;304&lt;/strong&gt;：被请求的资源内容没有发生更改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;tcp-udp区别&#34;&gt;tcp udp区别&lt;/h2&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;运输层主要使用以下两种协议:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  1. **传输控制协议 TCP**（Transmission Control Protocol）--提供**面向连接**的，**可靠的**数据传输服务。
  2. **用户数据协议 UDP**（User Datagram Protocol）--提供**无连接**的，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）。
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg&#34; alt=&#34;TCP、UDP协议的区别&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等&lt;/p&gt;
&lt;p&gt;TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。&lt;/p&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;
&lt;h2 id=&#34;三次握手四次挥手&#34;&gt;三次握手四次挥手&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA1MTEwNDA1NjY2?x-oss-process=image/format,png&#34; alt=&#34;三次握手&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;三次握手过程：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;客户端–发送带有 SYN 标志的数据包–一次握手–服务端&lt;/li&gt;
&lt;li&gt;服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端&lt;/li&gt;
&lt;li&gt;客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;当客户端和服务端通过三次握手建立了 TCP 连接以后，当数据传送完毕，断开连接就需要进行TCP的四次挥手。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四次挥手如下所示：&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA3MjA1NzU2MjU1?x-oss-process=image/format,png&#34; alt=&#34;这里写图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy?x-oss-process=image/format,png&#34; alt=&#34;四次挥手&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;断开一个-tcp-连接则需要四次挥手&#34;&gt;断开一个 TCP 连接则需要“四次挥手”：&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送&lt;/li&gt;
&lt;li&gt;服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号&lt;/li&gt;
&lt;li&gt;服务器-关闭与客户端的连接，发送一个FIN给客户端&lt;/li&gt;
&lt;li&gt;客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;为什么建立连接是三次握手关闭连接确是四次挥手呢&#34;&gt;为什么建立连接是三次握手，关闭连接确是四次挥手呢？&lt;/h5&gt;
&lt;p&gt;建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。&lt;br&gt;
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。&lt;/p&gt;
&lt;p&gt;上面讲的比较概括，推荐一篇讲的比较细致的文章：https://blog.csdn.net/qzcsu/article/details/72861891&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;快排思路&#34;&gt;快排思路&lt;/h2&gt;
&lt;h4 id=&#34;快排的思想&#34;&gt;快排的思想：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1.先从数组中取出一个数作为基准数；（第一个或者最后一个）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.分区过程，将比这个数大的数全部放到它的右边，小于或等于它的数全部放到它的左边；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.再对左右区间进行第二步，直到各区间只有一个数。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;快排思路-2&#34;&gt;&lt;strong&gt;快排思路：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;可以用补洞思路来实现上边的快排思想，简单来说就是挖洞之后，补洞。&lt;/p&gt;
&lt;p&gt;挖一个洞来补洞，目的是要把数分到两边。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https:////upload-images.jianshu.io/upload_images/1829401-1728cff508f62f6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;图一&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https:////upload-images.jianshu.io/upload_images/1829401-a59f520690465285.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;图二&lt;/p&gt;
&lt;p&gt;执行完毕后，比基准数小的在左边，比基准数大的在右边。因此对这两部分重复这个歌步骤就可以了。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1.洞在左边代表左边部分已经排好都是比基准数小的，洞在右边代表右边部分已经排好都是比基准数大的。&lt;/p&gt;
&lt;p&gt;2.要补左边的洞从后往前比基准数小的，j递增；要补右边的洞从前往后比基准数大的，i递增。&lt;/p&gt;
&lt;p&gt;作者：frankisbaby&lt;br&gt;
链接：https://www.jianshu.com/p/f01c64fd2f93&lt;br&gt;
来源：简书&lt;br&gt;
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h1 id=&#34;1-经典快速排序图示过程&#34;&gt;1. 经典快速排序图示过程&lt;/h1&gt;
&lt;h2 id=&#34;1-经典快速排序的总体流程&#34;&gt;(1) 经典快速排序的总体流程&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https:////upload-images.jianshu.io/upload_images/7789414-fb94ab5405281f89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-根据基准值分区的过程&#34;&gt;(2) 根据基准值分区的过程&lt;/h2&gt;
&lt;p&gt;在[&lt;a href=&#34;https://www.jianshu.com/p/356604b8903f&#34;&gt;算法题] 荷兰国旗问题&lt;/a&gt;中有详细的介绍。&lt;/p&gt;
&lt;h1 id=&#34;2-随机快速排序&#34;&gt;2. 随机快速排序&lt;/h1&gt;
&lt;p&gt;经典快速排序总是指定数组或者某部分的最后一个元素作为基准值，随机快速排序指定数组或者某一部分中的随机值作为基准值。&lt;/p&gt;
&lt;h1 id=&#34;3-动图展示&#34;&gt;3. 动图展示&lt;/h1&gt;
&lt;p&gt;作者：CoderJed&lt;br&gt;
链接：https://www.jianshu.com/p/a68f72278f8f&lt;br&gt;
来源：简书&lt;br&gt;
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
&lt;p&gt;动画演示：https://github.com/lzever/animationSort&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;快慢指针问题&#34;&gt;快慢指针问题&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;http10和-http11的区别及状态码&#34;&gt;http1.0和 http1.1的区别及状态码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HTTP的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;支持客户端、服务器端模式，简单快速，客户端向服务器端请求服务时，只需传送请求方法和路径，灵活，HTTP允许传输任意类型的数据对象，无连接，限制每次连接只处理一个请求，无状态，HTTP协议是无状态协议，指明协议对于事务处理没有记忆能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP都是由客户端发起请求的，并且由服务器端回应响应消息的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;灵活，我们知道允许可以任何类型的数据对象，包括音频，视频，图片，文件等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;无状态，HTTP就是说，每次HTTP请求都是独立的，任何两个请求之间没有必然的联系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;无连接的，每次服务器在处理完客户端的请求后，并收到客户的应答后，就断开了通信，当客户端再次发送请求时就是一个新的连接，采用这种方式可以节省传输时间。&lt;/p&gt;
&lt;p&gt;**这是HTTP/1.0版的主要缺点，**每个TCP连接只能发送一个请求，发送数据完毕后，连接就关闭了，如果还要请求就必须要新建一个请求连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HTTP是一种不保存状态，无状态协议，协议对于发送过来的请求或是响应都不做持久化处理。&lt;/p&gt;
&lt;p&gt;HTTP1.1虽然是无状态协议，但是为了实现期望的保持状态功能，于是引入了Cookie技术，有了Cookie，和HTTP协议通信，就可以管理状态了。&lt;/p&gt;
&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/12/25/16f3cf564dbef1a1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/12/25/16f3cf5650eb55e8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; style=&#34;zoom: 50%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;TCP连接的新建成本很高，因为需要客户端和服务器端三次握手。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**交流的简单流程：**客户端发起连接，客户端发起请求，服务器端响应请求，服务器端关闭连接。&lt;/p&gt;
&lt;p&gt;HTTP、1.1版本是最流行的版本，可以持久连接，TCP连接默认不关闭，可以被多个请求复用，只有在一段时间内，没有请求，就可以自动关闭。&lt;/p&gt;
&lt;h5 id=&#34;http10和http11区别&#34;&gt;HTTP1.0和HTTP1.1区别：&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;这部分回答引用这篇文章 https://www.jianshu.com/p/be29d679cbff 的一些内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;长连接&lt;/strong&gt; : &lt;strong&gt;在HTTP/1.0中，默认使用的是短连接&lt;/strong&gt;，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。&lt;strong&gt;HTTP 1.1起，默认使用长连接&lt;/strong&gt; ,默认开启Connection： keep-alive。 &lt;strong&gt;HTTP/1.1的持续连接有非流水线方式和流水线方式&lt;/strong&gt; 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。&lt;strong&gt;HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;错误状态响应码&lt;/strong&gt; :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存处理&lt;/strong&gt; :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;带宽优化及网络连接的使用&lt;/strong&gt; :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Host头处理&lt;/strong&gt;，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;延伸HTTP 2.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;HTTP2.0和HTTP1.X相比的新特性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;新的二进制格式&lt;/strong&gt;（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多路复用&lt;/strong&gt;（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;header压缩&lt;/strong&gt;，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务端推送&lt;/strong&gt;（server push），同SPDY一样，HTTP2.0也具有server push功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;HTTP2.0的升级改造&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。&lt;/li&gt;
&lt;li&gt;当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考&lt;strong&gt;NGINX白皮书，NGINX配置HTTP2.0官方指南&lt;/strong&gt; https://www.nginx.com/blog/nginx-1-9-5/。&lt;/li&gt;
&lt;li&gt;使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；&lt;/li&gt;
&lt;li&gt;HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；&lt;/li&gt;
&lt;li&gt;HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；&lt;br&gt;
具体如图：&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQriba5ygCTOOjIQH4wvoJS2iaFBseyEAUfvpJQThHmTjuGuaSspUo8xppiaA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;img&#34; style=&#34;zoom: 80%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;为什么需要头部压缩？&lt;/strong&gt;&lt;br&gt;
假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。具体参考：HTTP/2 头部压缩技术介绍&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP2.0多路复用有多好？&lt;/strong&gt;&lt;br&gt;
HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。&lt;br&gt;
HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;http和https的区别&#34;&gt;http和https的区别&lt;/h2&gt;
&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/3/13/169759640707ca8a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;端口&lt;/strong&gt; ：&lt;/p&gt;
&lt;p&gt;HTTP的URL由“http://”起始且默认使用&lt;strong&gt;端口80&lt;/strong&gt;，而HTTPS的URL由“https://”起始且默认使用&lt;strong&gt;端口443&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全性和资源消耗：&lt;/p&gt;
&lt;p&gt;HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是&lt;strong&gt;运行在SSL/TLS之上&lt;/strong&gt;的HTTP协议，SSL/TLS &lt;strong&gt;运行在TCP之上&lt;/strong&gt;。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；&lt;/li&gt;
&lt;li&gt;非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;redis缓存雪崩-缓存穿透-缓存击穿&#34;&gt;redis缓存雪崩、缓存穿透、缓存击穿&lt;/h2&gt;
&lt;h4 id=&#34;1-什么是缓存穿透&#34;&gt;1. 什么是缓存穿透？&lt;/h4&gt;
&lt;p&gt;缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。&lt;/p&gt;
&lt;h4 id=&#34;2-缓存穿透情况的处理流程是怎样的&#34;&gt;2. 缓存穿透情况的处理流程是怎样的？&lt;/h4&gt;
&lt;p&gt;如下图所示，用户的请求最终都要跑到数据库中查询一遍。&lt;/p&gt;
&lt;img src=&#34;https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E6%83%85%E5%86%B5.png&#34; alt=&#34;缓存穿透情况&#34; style=&#34;zoom: 80%;&#34; /&gt;
&lt;h4 id=&#34;3-有哪些解决办法&#34;&gt;3. 有哪些解决办法？&lt;/h4&gt;
&lt;p&gt;最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）缓存无效 key&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： &lt;code&gt;SET key value EX 10086&lt;/code&gt; 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。&lt;/p&gt;
&lt;p&gt;另外，这里多说一嘴，一般情况下我们是这样设计 key 的： &lt;code&gt;表名:列名:主键名:主键值&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）布隆过滤器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。&lt;/p&gt;
&lt;p&gt;具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。&lt;/p&gt;
&lt;p&gt;加入布隆过滤器之后的缓存处理流程图如下。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/%E5%8A%A0%E5%85%A5%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png&#34; alt=&#34;image&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： &lt;strong&gt;布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们先来看一下，&lt;strong&gt;当一个元素加入布隆过滤器中的时候，会进行哪些操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。&lt;/li&gt;
&lt;li&gt;根据得到的哈希值，在位数组中把对应下标的值置为 1。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们再来看一下，&lt;strong&gt;当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对给定元素再次进行相同的哈希计算；&lt;/li&gt;
&lt;li&gt;得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后，一定会出现这样一种情况：&lt;strong&gt;不同的字符串可能哈希出来的位置相同。&lt;/strong&gt; （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）&lt;/p&gt;
&lt;p&gt;更多关于布隆过滤器的内容可以看我的这篇原创：&lt;a href=&#34;https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md&#34;&gt;《不了解布隆过滤器？一文给你整的明明白白！》&lt;/a&gt; ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。&lt;/p&gt;
&lt;h4 id=&#34;1-什么是缓存雪崩&#34;&gt;1. 什么是缓存雪崩？&lt;/h4&gt;
&lt;p&gt;我发现缓存雪崩这名字起的有点意思，哈哈。&lt;/p&gt;
&lt;p&gt;实际上，缓存雪崩描述的就是这样一个简单的场景：&lt;strong&gt;缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。&lt;/strong&gt; 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。&lt;/p&gt;
&lt;p&gt;举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。&lt;/p&gt;
&lt;p&gt;还有一种缓存雪崩的场景是：&lt;strong&gt;有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。&lt;/strong&gt; 这样的情况，有下面几种解决办法：&lt;/p&gt;
&lt;p&gt;举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。&lt;/p&gt;
&lt;h4 id=&#34;2-有哪些解决办法&#34;&gt;2. 有哪些解决办法？&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;针对 Redis 服务不可用的情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。&lt;/li&gt;
&lt;li&gt;限流，避免同时处理大量的请求。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;针对热点缓存失效的情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置不同的失效时间比如随机设置缓存的失效时间。&lt;/li&gt;
&lt;li&gt;缓存永不失效。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;分布式锁的实现方式&#34;&gt;分布式锁的实现方式&lt;/h2&gt;
&lt;h2 id=&#34;为何需要分布式锁&#34;&gt;为何需要分布式锁&lt;/h2&gt;
&lt;p&gt;一般情况下，我们使用分布式锁主要有两个场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;避免不同节点重复相同的工作&lt;/strong&gt;：比如用户执行了某个操作有可能不同节点会发送多封邮件；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免破坏数据的正确性&lt;/strong&gt;：如果两个节点在同一条数据上同时进行操作，可能会造成数据错误或不一致的情况出现；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;redis-分布式锁的问题&#34;&gt;Redis 分布式锁的问题&lt;/h2&gt;
&lt;h3 id=&#34;1锁超时&#34;&gt;1）锁超时&lt;/h3&gt;
&lt;p&gt;假设现在我们有两台平行的服务 A B，其中 A 服务在 &lt;strong&gt;获取锁之后&lt;/strong&gt; 由于未知神秘力量突然 &lt;strong&gt;挂了&lt;/strong&gt;，那么 B 服务就永远无法获取到锁了：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/7896890-4ea386c23ef0eec9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;所以我们需要额外设置一个超时时间，来保证服务的可用性。&lt;/p&gt;
&lt;p&gt;但是另一个问题随即而来：&lt;strong&gt;如果在加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制&lt;/strong&gt;，也会出现问题。因为这时候第一个线程持有锁过期了，而临界区的逻辑还没有执行完，与此同时第二个线程就提前拥有了这把锁，导致临界区的代码不能得到严格的串行执行。&lt;/p&gt;
&lt;p&gt;为了避免这个问题，&lt;strong&gt;Redis 分布式锁不要用于较长时间的任务&lt;/strong&gt;。如果真的偶尔出现了问题，造成的数据小错乱可能就需要人工的干预。&lt;/p&gt;
&lt;p&gt;有一个稍微安全一点的方案是 &lt;strong&gt;将锁的 &lt;code&gt;value&lt;/code&gt; 值设置为一个随机数&lt;/strong&gt;，释放锁时先匹配随机数是否一致，然后再删除 key，这是为了 &lt;strong&gt;确保当前线程占有的锁不会被其他线程释放&lt;/strong&gt;，除非这个锁是因为过期了而被服务器自动释放的。&lt;/p&gt;
&lt;p&gt;但是匹配 &lt;code&gt;value&lt;/code&gt; 和删除 &lt;code&gt;key&lt;/code&gt; 在 Redis 中并不是一个原子性的操作，也没有类似保证原子性的指令，所以可能需要使用像 Lua 这样的脚本来处理了，因为 Lua 脚本可以 &lt;strong&gt;保证多个指令的原子性执行&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;延伸的讨论gc-可能引发的安全问题&#34;&gt;延伸的讨论：GC 可能引发的安全问题&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://martin.kleppmann.com/&#34;&gt;Martin Kleppmann&lt;/a&gt; 曾与 Redis 之父 Antirez 就 Redis 实现分布式锁的安全性问题进行过深入的讨论，其中有一个问题就涉及到 &lt;strong&gt;GC&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;熟悉 Java 的同学肯定对 GC 不陌生，在 GC 的时候会发生 &lt;strong&gt;STW(Stop-The-World)&lt;/strong&gt;，这本身是为了保障垃圾回收器的正常执行，但可能会引发如下的问题：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/7896890-cf3a403968a23be4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;服务 A 获取了锁并设置了超时时间，但是服务 A 出现了 STW 且时间较长，导致了分布式锁进行了超时释放，在这个期间服务 B 获取到了锁，待服务 A STW 结束之后又恢复了锁，这就导致了 &lt;strong&gt;服务 A 和服务 B 同时获取到了锁&lt;/strong&gt;，这个时候分布式锁就不安全了。&lt;/p&gt;
&lt;p&gt;不仅仅局限于 Redis，Zookeeper 和 MySQL 有同样的问题。&lt;/p&gt;
&lt;p&gt;想吃更多瓜的童鞋，可以访问下列网站看看 Redis 之父 Antirez 怎么说：http://antirez.com/news/101&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;redis有哪些数据类型及其应用场景&#34;&gt;redis有哪些数据类型及其应用场景&lt;/h2&gt;
&lt;h4 id=&#34;1-string&#34;&gt;1. string&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;介绍&lt;/strong&gt; ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 &lt;strong&gt;简单动态字符串&lt;/strong&gt;（simple dynamic string，&lt;strong&gt;SDS&lt;/strong&gt;）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外,Redis 的 SDS API 是安全的，不会造成缓冲区溢出。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常用命令:&lt;/strong&gt; &lt;code&gt;set,get,strlen,exists,dect,incr,setex&lt;/code&gt; 等等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt; ：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;普通字符串的基本操作：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;127.0.0.1:6379&amp;gt; set key value #设置 key-value 类型的值
OK
127.0.0.1:6379&amp;gt; get key # 根据 key 获得对应的 value
&amp;quot;value&amp;quot;
127.0.0.1:6379&amp;gt; exists key  # 判断某个 key 是否存在
(integer) 1
127.0.0.1:6379&amp;gt; strlen key # 返回 key 所储存的字符串值的长度。
(integer) 5
127.0.0.1:6379&amp;gt; del key # 删除某个 key 对应的值
(integer) 1
127.0.0.1:6379&amp;gt; get key
(nil)Copy to clipboardErrorCopied
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;批量设置&lt;/strong&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;127.0.0.1:6379&amp;gt; mset key1 value1 key2 value2 # 批量设置 key-value 类型的值
OK
127.0.0.1:6379&amp;gt; mget key1 key2 # 批量获取多个 key 对应的 value
1) &amp;quot;value1&amp;quot;
2) &amp;quot;value2&amp;quot;Copy to clipboardErrorCopied
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;计数器（字符串的内容为整数的时候可以使用）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;127.0.0.1:6379&amp;gt; set number 1
OK
127.0.0.1:6379&amp;gt; incr number # 将 key 中储存的数字值增一
(integer) 2
127.0.0.1:6379&amp;gt; get number
&amp;quot;2&amp;quot;
127.0.0.1:6379&amp;gt; decr number # 将 key 中储存的数字值减一
(integer) 1
127.0.0.1:6379&amp;gt; get number
&amp;quot;1&amp;quot;Copy to clipboardErrorCopied
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;过期&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;127.0.0.1:6379&amp;gt; expire key  60 # 数据在 60s 后过期
(integer) 1
127.0.0.1:6379&amp;gt; setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire)
OK
127.0.0.1:6379&amp;gt; ttl key # 查看数据还有多久过期
(integer) 56Copy to clipboardErrorCopied
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-list&#34;&gt;2. list&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;介绍&lt;/strong&gt; ：&lt;strong&gt;list&lt;/strong&gt; 即是 &lt;strong&gt;链表&lt;/strong&gt;。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 &lt;strong&gt;LinkedList&lt;/strong&gt;，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 &lt;strong&gt;双向链表&lt;/strong&gt;，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常用命令:&lt;/strong&gt; &lt;code&gt;rpush,lpop,lpush,rpop,lrange、llen&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景:&lt;/strong&gt; 发布与订阅或者说消息队列、慢查询。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们简单看看它的使用！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过 &lt;code&gt;rpush/lpop&lt;/code&gt; 实现队列：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;127.0.0.1:6379&amp;gt; rpush myList value1 # 向 list 的头部（右边）添加元素
(integer) 1
127.0.0.1:6379&amp;gt; rpush myList value2 value3 # 向list的头部（最右边）添加多个元素
(integer) 3
127.0.0.1:6379&amp;gt; lpop myList # 将 list的尾部(最左边)元素取出
&amp;quot;value1&amp;quot;
127.0.0.1:6379&amp;gt; lrange myList 0 1 # 查看对应下标的list列表， 0 为 start,1为 end
1) &amp;quot;value2&amp;quot;
2) &amp;quot;value3&amp;quot;
127.0.0.1:6379&amp;gt; lrange myList 0 -1 # 查看列表中的所有元素，-1表示倒数第一
1) &amp;quot;value2&amp;quot;
2) &amp;quot;value3&amp;quot;Copy to clipboardErrorCopied
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通过 &lt;code&gt;rpush/rpop&lt;/code&gt; 实现栈：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;127.0.0.1:6379&amp;gt; rpush myList2 value1 value2 value3
(integer) 3
127.0.0.1:6379&amp;gt; rpop myList2 # 将 list的头部(最右边)元素取出
&amp;quot;value3&amp;quot;Copy to clipboardErrorCopied
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我专门花了一个图方便小伙伴们来理解：&lt;/p&gt;
&lt;img src=&#34;https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/redis-list.png&#34; alt=&#34;redis list&#34; style=&#34;zoom: 80%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;通过 &lt;code&gt;lrange&lt;/code&gt; 查看对应下标范围的列表元素：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;127.0.0.1:6379&amp;gt; rpush myList value1 value2 value3
(integer) 3
127.0.0.1:6379&amp;gt; lrange myList 0 1 # 查看对应下标的list列表， 0 为 start,1为 end
1) &amp;quot;value1&amp;quot;
2) &amp;quot;value2&amp;quot;
127.0.0.1:6379&amp;gt; lrange myList 0 -1 # 查看列表中的所有元素，-1表示倒数第一
1) &amp;quot;value1&amp;quot;
2) &amp;quot;value2&amp;quot;
3) &amp;quot;value3&amp;quot;Copy to clipboardErrorCopied
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;lrange&lt;/code&gt; 命令，你可以基于 list 实现分页查询，性能非常高！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过 &lt;code&gt;llen&lt;/code&gt; 查看链表长度：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;127.0.0.1:6379&amp;gt; llen myList
(integer) 3Copy to clipboardErrorCopied
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-hash&#34;&gt;3. hash&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;介绍&lt;/strong&gt; ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，&lt;strong&gt;特别适合用于存储对象&lt;/strong&gt;，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常用命令：&lt;/strong&gt; &lt;code&gt;hset,hmset,hexists,hget,hgetall,hkeys,hvals&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景:&lt;/strong&gt; 系统中对象数据的存储。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们简单看看它的使用！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;127.0.0.1:6379&amp;gt; hset userInfoKey name &amp;quot;guide&amp;quot; description &amp;quot;dev&amp;quot; age &amp;quot;24&amp;quot;
OK
127.0.0.1:6379&amp;gt; hexists userInfoKey name # 查看 key 对应的 value中指定的字段是否存在。
(integer) 1
127.0.0.1:6379&amp;gt; hget userInfoKey name # 获取存储在哈希表中指定字段的值。
&amp;quot;guide&amp;quot;
127.0.0.1:6379&amp;gt; hget userInfoKey age
&amp;quot;24&amp;quot;
127.0.0.1:6379&amp;gt; hgetall userInfoKey # 获取在哈希表中指定 key 的所有字段和值
1) &amp;quot;name&amp;quot;
2) &amp;quot;guide&amp;quot;
3) &amp;quot;description&amp;quot;
4) &amp;quot;dev&amp;quot;
5) &amp;quot;age&amp;quot;
6) &amp;quot;24&amp;quot;
127.0.0.1:6379&amp;gt; hkeys userInfoKey # 获取 key 列表
1) &amp;quot;name&amp;quot;
2) &amp;quot;description&amp;quot;
3) &amp;quot;age&amp;quot;
127.0.0.1:6379&amp;gt; hvals userInfoKey # 获取 value 列表
1) &amp;quot;guide&amp;quot;
2) &amp;quot;dev&amp;quot;
3) &amp;quot;24&amp;quot;
127.0.0.1:6379&amp;gt; hset userInfoKey name &amp;quot;GuideGeGe&amp;quot; # 修改某个字段对应的值
127.0.0.1:6379&amp;gt; hget userInfoKey name
&amp;quot;GuideGeGe&amp;quot;Copy to clipboardErrorCopied
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-set&#34;&gt;4. set&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;介绍 ：&lt;/strong&gt; set 类似于 Java 中的 &lt;code&gt;HashSet&lt;/code&gt; 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常用命令：&lt;/strong&gt; &lt;code&gt;sadd,spop,smembers,sismember,scard,sinterstore,sunion&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景:&lt;/strong&gt; 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们简单看看它的使用！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;127.0.0.1:6379&amp;gt; sadd mySet value1 value2 # 添加元素进去
(integer) 2
127.0.0.1:6379&amp;gt; sadd mySet value1 # 不允许有重复元素
(integer) 0
127.0.0.1:6379&amp;gt; smembers mySet # 查看 set 中所有的元素
1) &amp;quot;value1&amp;quot;
2) &amp;quot;value2&amp;quot;
127.0.0.1:6379&amp;gt; scard mySet # 查看 set 的长度
(integer) 2
127.0.0.1:6379&amp;gt; sismember mySet value1 # 检查某个元素是否存在set 中，只能接收单个元素
(integer) 1
127.0.0.1:6379&amp;gt; sadd mySet2 value2 value3
(integer) 2
127.0.0.1:6379&amp;gt; sinterstore mySet3 mySet mySet2 # 获取 mySet 和 mySet2 的交集并存放在 mySet3 中
(integer) 1
127.0.0.1:6379&amp;gt; smembers mySet3
1) &amp;quot;value2&amp;quot;Copy to clipboardErrorCopied
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;5-sorted-set&#34;&gt;5. sorted set&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;介绍：&lt;/strong&gt; 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常用命令：&lt;/strong&gt; &lt;code&gt;zadd,zcard,zscore,zrange,zrevrange,zrem&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景：&lt;/strong&gt; 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;127.0.0.1:6379&amp;gt; zadd myZset 3.0 value1 # 添加元素到 sorted set 中 3.0 为权重
(integer) 1
127.0.0.1:6379&amp;gt; zadd myZset 2.0 value2 1.0 value3 # 一次添加多个元素
(integer) 2
127.0.0.1:6379&amp;gt; zcard myZset # 查看 sorted set 中的元素数量
(integer) 3
127.0.0.1:6379&amp;gt; zscore myZset value1 # 查看某个 value 的权重
&amp;quot;3&amp;quot;
127.0.0.1:6379&amp;gt; zrange  myZset 0 -1 # 顺序输出某个范围区间的元素，0 -1 表示输出所有元素
1) &amp;quot;value3&amp;quot;
2) &amp;quot;value2&amp;quot;
3) &amp;quot;value1&amp;quot;
127.0.0.1:6379&amp;gt; zrange  myZset 0 1 # 顺序输出某个范围区间的元素，0 为 start  1 为 stop
1) &amp;quot;value3&amp;quot;
2) &amp;quot;value2&amp;quot;
127.0.0.1:6379&amp;gt; zrevrange  myZset 0 1 # 逆序输出某个范围区间的元素，0 为 start  1 为 stop
1) &amp;quot;value1&amp;quot;
2) &amp;quot;value2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;redis集群架构&#34;&gt;redis集群架构&lt;/h2&gt;
&lt;h4 id=&#34;redis-主从复制&#34;&gt;Redis 主从复制&lt;/h4&gt;
&lt;p&gt;到 &lt;a href=&#34;https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/redis-collection/Redis(9)%E2%80%94%E2%80%94%E9%9B%86%E7%BE%A4%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B?id=%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB&#34;&gt;目前&lt;/a&gt; 为止，我们所学习的 Redis 都是 &lt;strong&gt;单机版&lt;/strong&gt; 的，这也就意味着一旦我们所依赖的 Redis 服务宕机了，我们的主流程也会受到一定的影响，这当然是我们不能够接受的。&lt;/p&gt;
&lt;p&gt;所以一开始我们的想法是：搞一台备用机。这样我们就可以在一台服务器出现问题的时候切换动态地到另一台去：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/7896890-c48d255bc0b13672.gif?imageMogr2/auto-orient/strip&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;幸运的是，两个节点数据的同步我们可以使用 Redis 的 &lt;strong&gt;主从同步&lt;/strong&gt; 功能帮助到我们，这样一来，有个备份，心里就踏实多了。&lt;/p&gt;
&lt;h4 id=&#34;redis-哨兵&#34;&gt;Redis 哨兵&lt;/h4&gt;
&lt;p&gt;后来因为某种神秘力量，Redis 老会在莫名其妙的时间点出问题 &lt;em&gt;(比如半夜 2 点)&lt;/em&gt;，我总不能 24 小时时刻守在电脑旁边切换节点吧，于是另一个想法又开始了：给所有的节点找一个 &lt;strong&gt;&amp;quot;管家&amp;quot;&lt;/strong&gt;，自动帮我监听照顾节点的状态并切换：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/7896890-de8d9ce9e77bf211.gif?imageMogr2/auto-orient/strip&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这大概就是 &lt;strong&gt;Redis 哨兵&lt;/strong&gt; &lt;em&gt;(Sentinel)&lt;/em&gt; 的简单理解啦。什么？管家宕机了怎么办？相较于有大量请求的 Redis 服务来说，管家宕机的概率就要小得多啦.. 如果真的宕机了，我们也可以直接切换成当前可用的节点保证可用.&lt;/p&gt;
&lt;h4 id=&#34;redis-集群化&#34;&gt;Redis 集群化&lt;/h4&gt;
&lt;p&gt;好了，通过上面的一些解决方案我们对 Redis 的 &lt;strong&gt;稳定性&lt;/strong&gt; 稍微有了一些底气了，但单台节点的计算能力始终有限，所谓人多力量大，如果我们把 &lt;strong&gt;多个节点组合&lt;/strong&gt; 成 &lt;strong&gt;一个可用的工作节点&lt;/strong&gt;，那就大大增加了 Redis 的 &lt;strong&gt;高可用、可扩展、分布式、容错&lt;/strong&gt; 等特性：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/7896890-516eb4a9465451a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;上图&lt;/em&gt; 展示了 &lt;strong&gt;Redis Cluster&lt;/strong&gt; 典型的架构图，集群中的每一个 Redis 节点都 &lt;strong&gt;互相两两相连&lt;/strong&gt;，客户端任意 &lt;strong&gt;直连&lt;/strong&gt; 到集群中的 &lt;strong&gt;任意一台&lt;/strong&gt;，就可以对其他 Redis 节点进行 &lt;strong&gt;读写&lt;/strong&gt; 的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;redis数据类型的底层数据结构&#34;&gt;redis数据类型的底层数据结构&lt;/h2&gt;
&lt;h1 id=&#34;redis-五种基本数据结构&#34;&gt;&lt;a href=&#34;https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/redis-collection/Redis(1)%E2%80%94%E2%80%945%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84?id=%E4%BA%8C%E3%80%81redis-%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#34;&gt;Redis 五种基本数据结构&lt;/a&gt;&lt;/h1&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&#34;redis为什么快说一下io多路复用及&#34;&gt;redis为什么快，说一下io多路复用及&lt;/h2&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大体上来说，&lt;strong&gt;Redis 6.0 之前主要还是单线程处理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那，Redis6.0 之前 为什么不使用多线程？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我觉得主要原因有下面 3 个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单线程编程容易并且更容易维护；&lt;/li&gt;
&lt;li&gt;Redis 的性能瓶颈不再 CPU ，主要在内存和网络；&lt;/li&gt;
&lt;li&gt;多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;既然是单线程，那怎么监听大量的客户端连接呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Redis 通过&lt;strong&gt;IO 多路复用程序&lt;/strong&gt; 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生。&lt;/p&gt;
&lt;p&gt;这样的好处非常明显： &lt;strong&gt;I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗&lt;/strong&gt;（和 NIO 中的 &lt;code&gt;Selector&lt;/code&gt; 组件很像）。&lt;/p&gt;
&lt;p&gt;另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件： 1. 文件事件; 2. 时间事件。&lt;/p&gt;
&lt;p&gt;时间事件不需要多花时间了解，我们接触最多的还是 &lt;strong&gt;文件事件&lt;/strong&gt;（客户端进行读取写入等操作，涉及一系列网络通信）。&lt;/p&gt;
&lt;p&gt;《Redis 设计与实现》有一段话是如是介绍文件事件的，我觉得写得挺不错。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。&lt;/p&gt;
&lt;p&gt;当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字&lt;/strong&gt;，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看出，文件事件处理器（file event handler）主要是包含 4 个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多个 socket（客户端连接）&lt;/li&gt;
&lt;li&gt;IO 多路复用程序（支持多个客户端连接的关键）&lt;/li&gt;
&lt;li&gt;文件事件分派器（将 socket 关联到相应的事件处理器）&lt;/li&gt;
&lt;li&gt;事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://snailclimb.gitee.io/javaguide/docs/database/Redis/images/redis-all/redis%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png&#34; alt=&#34;img&#34; style=&#34;zoom: 50%;&#34; /&gt;">Golang面试题，待更新</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ChicRingo.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;咸鱼个人用的博客，记录一些平时学到用到的技术知识&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;p&gt;咸鱼一条&lt;/p&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;p&gt;我爱学习&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;github.com/ChicRingo&#34;&gt;github.com/ChicRingo&lt;/a&gt;&lt;/p&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>



<script src="/media/js/cool.js"></script>



</html>